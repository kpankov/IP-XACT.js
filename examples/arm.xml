<?xml version="1.0" encoding="UTF-8"?>
<!-- 
// =============================================================================
// The confidential and proprietary information contained in this file may
// only be used by a person authorised under and to the extent permitted
// by a subsisting licensing agreement from ARM Limited.
//
//            (C) COPYRIGHT 2011-2016 ARM Limited.
//                ALL RIGHTS RESERVED
//
// This entire notice must be reproduced on all copies of this file
// and copies of this file may only be made by a person if such person is
// permitted to do so under the terms of a subsisting license agreement
// from ARM Limited.
//
//      Release Information : CORTEXA53-r0p4-51rel2
//
// =============================================================================
//
// Purpose :
//           This Component Definition describes CortexA53 MPCore CPU
//
// =============================================================================
  -->
<!-- Automatically generated IPXACT for CortexA53 -->
<spirit:component xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arm="http://www.arm.com/SPIRIT/1685-2009" xsi:schemaLocation="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009 http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009/index.xsd">
  <spirit:vendor>arm.com</spirit:vendor>
  <spirit:library>Cores</spirit:library>
  <spirit:name>CortexA53_configured</spirit:name>
  <spirit:version>r0p4-51rel2</spirit:version>
  <!-- Bus Interfaces -->
  <spirit:busInterfaces>
    <!--  Staticcfg_slave_SAMADDRMAP13  -->
    
    <!--  interrupt_slave_FIQ0  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_FIQ0</spirit:name>
      <spirit:displayName>interrupt_slave_FIQ0</spirit:displayName>
      <spirit:description>FIQ Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_FIQ0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_FIQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_FIQ: nFIQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nFIQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nFIQ  -->
              <!--  vector details: nFIQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_FIQ1  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_FIQ1</spirit:name>
      <spirit:displayName>interrupt_slave_FIQ1</spirit:displayName>
      <spirit:description>FIQ Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_FIQ1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_FIQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_FIQ: nFIQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nFIQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nFIQ  -->
              <!--  vector details: nFIQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_FIQ2  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_FIQ2</spirit:name>
      <spirit:displayName>interrupt_slave_FIQ2</spirit:displayName>
      <spirit:description>FIQ Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_FIQ2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_FIQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_FIQ: nFIQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nFIQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nFIQ  -->
              <!--  vector details: nFIQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_FIQ3  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_FIQ3</spirit:name>
      <spirit:displayName>interrupt_slave_FIQ3</spirit:displayName>
      <spirit:description>FIQ Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_FIQ3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_FIQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_FIQ: nFIQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nFIQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nFIQ  -->
              <!--  vector details: nFIQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  AXI4Stream_slave_DISTRIBUTOR  -->
    <spirit:busInterface>
      <spirit:name>AXI4Stream_slave_DISTRIBUTOR</spirit:name>
      <spirit:displayName>AXI4Stream_slave_DISTRIBUTOR</spirit:displayName>
      <spirit:description>AXI4Stream Distributor for GIC</spirit:description>
      <!--  Need to generate required attributes for Bus i/f AXI4Stream_slave_DISTRIBUTOR  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="AXI4Stream" spirit:version="r0p0_1"/>
      <spirit:abstractionType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="AXI4Stream_rtl" spirit:version="r0p0_1"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  AXI4Stream_slave_DISTRIBUTOR: ICDTDEST  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>TDEST</spirit:name>
            <spirit:vector>
              <!--  vector info: TDEST  -->
              <!--  vector details: TDEST, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ICDTDEST</spirit:name>
            <spirit:vector>
              <!--  vector info: ICDTDEST  -->
              <!--  vector details: ICDTDEST, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  AXI4Stream_slave_DISTRIBUTOR: nL2RESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nL2RESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  AXI4Stream_slave_DISTRIBUTOR: ICDTVALID  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>TVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ICDTVALID</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  AXI4Stream_slave_DISTRIBUTOR: ICDTREADY  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>TREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ICDTREADY</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  AXI4Stream_slave_DISTRIBUTOR: ICDTLAST  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>TLAST</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ICDTLAST</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  AXI4Stream_slave_DISTRIBUTOR: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ACLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  AXI4Stream_slave_DISTRIBUTOR: ICDTDATA  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>TDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: TDATA  -->
              <!--  vector details: TDATA, exp_per_cpu < >  -->
              <spirit:left>15</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ICDTDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: ICDTDATA  -->
              <!--  vector details: ICDTDATA, exp_per_cpu < >  -->
              <spirit:left>15</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  ATB_master_CPU3  -->
    <spirit:busInterface>
      <spirit:name>ATB_master_CPU3</spirit:name>
      <spirit:displayName>ATB_master_CPU3</spirit:displayName>
      <spirit:description>ATB Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f ATB_master_CPU3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="ATB" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="ATB_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  ATB_master_CPU3: AFREADYM3  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AFREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AFREADYM3</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU3: SYNCREQM3  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SYNCREQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SYNCREQM3</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU3: ATREADYM3  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATREADYM3</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU3: ATBYTESM3  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATBYTES</spirit:name>
            <spirit:vector>
              <!--  vector info: ATBYTES  -->
              <!--  vector details: ATBYTES, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATBYTESM3</spirit:name>
            <spirit:vector>
              <!--  vector info: ATBYTESM3  -->
              <!--  vector details: ATBYTESM3, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU3: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATCLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU3: ATDATAM3  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: ATDATA  -->
              <!--  vector details: ATDATA, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATDATAM3</spirit:name>
            <spirit:vector>
              <!--  vector info: ATDATAM3  -->
              <!--  vector details: ATDATAM3, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU3: ATCLKEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATCLKEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATCLKEN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU3: AFVALIDM3  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AFVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AFVALIDM3</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU3: ATIDM3  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATID</spirit:name>
            <spirit:vector>
              <!--  vector info: ATID  -->
              <!--  vector details: ATID, exp_per_cpu < >  -->
              <spirit:left>6</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATIDM3</spirit:name>
            <spirit:vector>
              <!--  vector info: ATIDM3  -->
              <!--  vector details: ATIDM3, exp_per_cpu < >  -->
              <spirit:left>6</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU3: nCPUPORESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATRESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCPUPORESET</spirit:name>
            <spirit:vector>
              <!--  vector info: nCPUPORESET  -->
              <!--  vector details: nCPUPORESET, exp_per_cpu <per_cpu_explicit>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU3: ATVALIDM3  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATVALIDM3</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMHNF1_NODEID  -->
    
    <!--  ATB_master_CPU2  -->
    <spirit:busInterface>
      <spirit:name>ATB_master_CPU2</spirit:name>
      <spirit:displayName>ATB_master_CPU2</spirit:displayName>
      <spirit:description>ATB Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f ATB_master_CPU2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="ATB" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="ATB_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  ATB_master_CPU2: AFREADYM2  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AFREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AFREADYM2</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU2: SYNCREQM2  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SYNCREQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SYNCREQM2</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU2: ATREADYM2  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATREADYM2</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU2: ATBYTESM2  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATBYTES</spirit:name>
            <spirit:vector>
              <!--  vector info: ATBYTES  -->
              <!--  vector details: ATBYTES, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATBYTESM2</spirit:name>
            <spirit:vector>
              <!--  vector info: ATBYTESM2  -->
              <!--  vector details: ATBYTESM2, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU2: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATCLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU2: ATDATAM2  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: ATDATA  -->
              <!--  vector details: ATDATA, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATDATAM2</spirit:name>
            <spirit:vector>
              <!--  vector info: ATDATAM2  -->
              <!--  vector details: ATDATAM2, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU2: ATCLKEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATCLKEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATCLKEN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU2: AFVALIDM2  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AFVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AFVALIDM2</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU2: ATIDM2  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATID</spirit:name>
            <spirit:vector>
              <!--  vector info: ATID  -->
              <!--  vector details: ATID, exp_per_cpu < >  -->
              <spirit:left>6</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATIDM2</spirit:name>
            <spirit:vector>
              <!--  vector info: ATIDM2  -->
              <!--  vector details: ATIDM2, exp_per_cpu < >  -->
              <spirit:left>6</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU2: nCPUPORESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATRESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCPUPORESET</spirit:name>
            <spirit:vector>
              <!--  vector info: nCPUPORESET  -->
              <!--  vector details: nCPUPORESET, exp_per_cpu <per_cpu_explicit>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU2: ATVALIDM2  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATVALIDM2</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_RVB_ARADDR3  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_RVB_ARADDR3</spirit:name>
      <spirit:displayName>Staticcfg_slave_RVB_ARADDR3</spirit:displayName>
      <spirit:description>RVBARADDR CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_RVB_ARADDR3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_RVB_ARADDR3: RVBARADDR3  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
            <spirit:vector>
              <!--  vector info: CONFIGURATION  -->
              <!--  vector details: CONFIGURATION, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RVBARADDR3</spirit:name>
            <spirit:vector>
              <!--  vector info: RVBARADDR3  -->
              <!--  vector details: RVBARADDR3, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  RESET_slave_CPU_PORESET0  -->
    <spirit:busInterface>
      <spirit:name>RESET_slave_CPU_PORESET0</spirit:name>
      <spirit:displayName>RESET_slave_CPU_PORESET0</spirit:displayName>
      <spirit:description>CPU-0 Power On Reset</spirit:description>
      <!--  Need to generate required attributes for Bus i/f RESET_slave_CPU_PORESET0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  RESET_slave_CPU_PORESET: nCPUPORESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCPUPORESET</spirit:name>
            <spirit:vector>
              <!--  vector info: nCPUPORESET  -->
              <!--  vector details: nCPUPORESET, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  RESET_slave_CPU_PORESET: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  RESET_slave_CPU_PORESET1  -->
    <spirit:busInterface>
      <spirit:name>RESET_slave_CPU_PORESET1</spirit:name>
      <spirit:displayName>RESET_slave_CPU_PORESET1</spirit:displayName>
      <spirit:description>CPU-1 Power On Reset</spirit:description>
      <!--  Need to generate required attributes for Bus i/f RESET_slave_CPU_PORESET1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  RESET_slave_CPU_PORESET: nCPUPORESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCPUPORESET</spirit:name>
            <spirit:vector>
              <!--  vector info: nCPUPORESET  -->
              <!--  vector details: nCPUPORESET, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  RESET_slave_CPU_PORESET: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  RESET_slave_CPU_PORESET2  -->
    <spirit:busInterface>
      <spirit:name>RESET_slave_CPU_PORESET2</spirit:name>
      <spirit:displayName>RESET_slave_CPU_PORESET2</spirit:displayName>
      <spirit:description>CPU-2 Power On Reset</spirit:description>
      <!--  Need to generate required attributes for Bus i/f RESET_slave_CPU_PORESET2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  RESET_slave_CPU_PORESET: nCPUPORESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCPUPORESET</spirit:name>
            <spirit:vector>
              <!--  vector info: nCPUPORESET  -->
              <!--  vector details: nCPUPORESET, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  RESET_slave_CPU_PORESET: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  RESET_slave_CPU_PORESET3  -->
    <spirit:busInterface>
      <spirit:name>RESET_slave_CPU_PORESET3</spirit:name>
      <spirit:displayName>RESET_slave_CPU_PORESET3</spirit:displayName>
      <spirit:description>CPU-3 Power On Reset</spirit:description>
      <!--  Need to generate required attributes for Bus i/f RESET_slave_CPU_PORESET3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  RESET_slave_CPU_PORESET: nCPUPORESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCPUPORESET</spirit:name>
            <spirit:vector>
              <!--  vector info: nCPUPORESET  -->
              <!--  vector details: nCPUPORESET, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  RESET_slave_CPU_PORESET: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  APB_slave_DEBUG  -->
    <spirit:busInterface>
      <spirit:name>APB_slave_DEBUG</spirit:name>
      <spirit:displayName>APB_slave_DEBUG</spirit:displayName>
      <spirit:description>APB Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f APB_slave_DEBUG  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="amba.com" spirit:library="AMBA3" spirit:name="APB" spirit:version="r2p0_0"/>
      <spirit:abstractionType spirit:vendor="amba.com" spirit:library="AMBA3" spirit:name="APB_rtl" spirit:version="r2p0_0"/>
      <spirit:slave>
        <spirit:memoryMapRef spirit:memoryMapRef="APB_Memory_Map"/>
      </spirit:slave>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  APB_slave_DEBUG: nPRESETDBG  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PRESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nPRESETDBG</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  APB_slave_DEBUG: PRDATADBG  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PRDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: PRDATA  -->
              <!--  vector details: PRDATA, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>PRDATADBG</spirit:name>
            <spirit:vector>
              <!--  vector info: PRDATADBG  -->
              <!--  vector details: PRDATADBG, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  APB_slave_DEBUG: PENABLEDBG  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PENABLE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>PENABLEDBG</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  APB_slave_DEBUG: PADDRDBG31  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PADDR</spirit:name>
            <spirit:vector>
              <!--  vector info: PADDR  -->
              <!--  vector details: PADDR, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>31</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>PADDRDBG31</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  APB_slave_DEBUG: PCLKENDBG  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PCLKEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>PCLKENDBG</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  APB_slave_DEBUG: PSLVERRDBG  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PSLVERR</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>PSLVERRDBG</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  APB_slave_DEBUG: PSELDBG  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PSELx</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>PSELDBG</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  APB_slave_DEBUG: PWDATADBG  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PWDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: PWDATA  -->
              <!--  vector details: PWDATA, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>PWDATADBG</spirit:name>
            <spirit:vector>
              <!--  vector info: PWDATADBG  -->
              <!--  vector details: PWDATADBG, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  APB_slave_DEBUG: PWRITEDBG  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PWRITE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>PWRITEDBG</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  APB_slave_DEBUG: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PCLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  APB_slave_DEBUG: PREADYDBG  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>PREADYDBG</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  APB_slave_DEBUG: PADDRDBG  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PADDR</spirit:name>
            <spirit:vector>
              <!--  vector info: PADDR  -->
              <!--  vector details: PADDR, exp_per_cpu < >  -->
              <spirit:left>21</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>PADDRDBG</spirit:name>
            <spirit:vector>
              <!--  vector info: PADDRDBG  -->
              <!--  vector details: PADDRDBG, exp_per_cpu < >  -->
              <spirit:left>21</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  Q-Channel_slave_L2  -->
    <spirit:busInterface>
      <spirit:name>Q-Channel_slave_L2</spirit:name>
      <spirit:displayName>Q-Channel_slave_L2</spirit:displayName>
      <spirit:description>Q channel for L2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Q-Channel_slave_L2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Q-Channel_slave_L2: L2QREQn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QREQn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>L2QREQn</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_L2: L2QACCEPTn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACCEPTn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>L2QACCEPTn</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_L2: L2QDENY  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QDENY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>L2QDENY</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_L2: L2QACTIVE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACTIVE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>L2QACTIVE</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_CFGEND0  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CFGEND0</spirit:name>
      <spirit:displayName>Staticcfg_slave_CFGEND0</spirit:displayName>
      <spirit:description>CFGENDInterface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CFGEND0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CFGEND: CFGEND  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CFGEND</spirit:name>
            <spirit:vector>
              <!--  vector info: CFGEND  -->
              <!--  vector details: CFGEND, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_CFGEND1  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CFGEND1</spirit:name>
      <spirit:displayName>Staticcfg_slave_CFGEND1</spirit:displayName>
      <spirit:description>CFGENDInterface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CFGEND1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CFGEND: CFGEND  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CFGEND</spirit:name>
            <spirit:vector>
              <!--  vector info: CFGEND  -->
              <!--  vector details: CFGEND, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_CFGEND2  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CFGEND2</spirit:name>
      <spirit:displayName>Staticcfg_slave_CFGEND2</spirit:displayName>
      <spirit:description>CFGENDInterface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CFGEND2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CFGEND: CFGEND  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CFGEND</spirit:name>
            <spirit:vector>
              <!--  vector info: CFGEND  -->
              <!--  vector details: CFGEND, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_CFGEND3  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CFGEND3</spirit:name>
      <spirit:displayName>Staticcfg_slave_CFGEND3</spirit:displayName>
      <spirit:description>CFGENDInterface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CFGEND3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CFGEND: CFGEND  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CFGEND</spirit:name>
            <spirit:vector>
              <!--  vector info: CFGEND  -->
              <!--  vector details: CFGEND, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Q-Channel_slave_NEON0  -->
    <spirit:busInterface>
      <spirit:name>Q-Channel_slave_NEON0</spirit:name>
      <spirit:displayName>Q-Channel_slave_NEON0</spirit:displayName>
      <spirit:description>Q channel for NEON-0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Q-Channel_slave_NEON0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Q-Channel_slave_NEON: NEONQREQn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QREQn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQREQn</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQREQn  -->
              <!--  vector details: NEONQREQn, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_NEON: NEONQACCEPTn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACCEPTn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQACCEPTn</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQACCEPTn  -->
              <!--  vector details: NEONQACCEPTn, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_NEON: NEONQDENY  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QDENY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQDENY</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQDENY  -->
              <!--  vector details: NEONQDENY, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_NEON: NEONQACTIVE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACTIVE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQACTIVE</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQACTIVE  -->
              <!--  vector details: NEONQACTIVE, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Q-Channel_slave_NEON1  -->
    <spirit:busInterface>
      <spirit:name>Q-Channel_slave_NEON1</spirit:name>
      <spirit:displayName>Q-Channel_slave_NEON1</spirit:displayName>
      <spirit:description>Q channel for NEON-1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Q-Channel_slave_NEON1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Q-Channel_slave_NEON: NEONQREQn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QREQn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQREQn</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQREQn  -->
              <!--  vector details: NEONQREQn, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_NEON: NEONQACCEPTn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACCEPTn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQACCEPTn</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQACCEPTn  -->
              <!--  vector details: NEONQACCEPTn, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_NEON: NEONQDENY  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QDENY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQDENY</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQDENY  -->
              <!--  vector details: NEONQDENY, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_NEON: NEONQACTIVE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACTIVE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQACTIVE</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQACTIVE  -->
              <!--  vector details: NEONQACTIVE, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Q-Channel_slave_NEON2  -->
    <spirit:busInterface>
      <spirit:name>Q-Channel_slave_NEON2</spirit:name>
      <spirit:displayName>Q-Channel_slave_NEON2</spirit:displayName>
      <spirit:description>Q channel for NEON-2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Q-Channel_slave_NEON2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Q-Channel_slave_NEON: NEONQREQn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QREQn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQREQn</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQREQn  -->
              <!--  vector details: NEONQREQn, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_NEON: NEONQACCEPTn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACCEPTn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQACCEPTn</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQACCEPTn  -->
              <!--  vector details: NEONQACCEPTn, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_NEON: NEONQDENY  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QDENY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQDENY</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQDENY  -->
              <!--  vector details: NEONQDENY, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_NEON: NEONQACTIVE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACTIVE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQACTIVE</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQACTIVE  -->
              <!--  vector details: NEONQACTIVE, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Q-Channel_slave_NEON3  -->
    <spirit:busInterface>
      <spirit:name>Q-Channel_slave_NEON3</spirit:name>
      <spirit:displayName>Q-Channel_slave_NEON3</spirit:displayName>
      <spirit:description>Q channel for NEON-3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Q-Channel_slave_NEON3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Q-Channel_slave_NEON: NEONQREQn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QREQn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQREQn</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQREQn  -->
              <!--  vector details: NEONQREQn, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_NEON: NEONQACCEPTn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACCEPTn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQACCEPTn</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQACCEPTn  -->
              <!--  vector details: NEONQACCEPTn, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_NEON: NEONQDENY  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QDENY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQDENY</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQDENY  -->
              <!--  vector details: NEONQDENY, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_NEON: NEONQACTIVE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACTIVE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NEONQACTIVE</spirit:name>
            <spirit:vector>
              <!--  vector info: NEONQACTIVE  -->
              <!--  vector details: NEONQACTIVE, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_CFGTE0  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CFGTE0</spirit:name>
      <spirit:displayName>Staticcfg_slave_CFGTE0</spirit:displayName>
      <spirit:description>CFGTE Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CFGTE0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CFGTE: CFGTE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CFGTE</spirit:name>
            <spirit:vector>
              <!--  vector info: CFGTE  -->
              <!--  vector details: CFGTE, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_CFGTE1  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CFGTE1</spirit:name>
      <spirit:displayName>Staticcfg_slave_CFGTE1</spirit:displayName>
      <spirit:description>CFGTE Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CFGTE1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CFGTE: CFGTE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CFGTE</spirit:name>
            <spirit:vector>
              <!--  vector info: CFGTE  -->
              <!--  vector details: CFGTE, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_CFGTE2  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CFGTE2</spirit:name>
      <spirit:displayName>Staticcfg_slave_CFGTE2</spirit:displayName>
      <spirit:description>CFGTE Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CFGTE2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CFGTE: CFGTE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CFGTE</spirit:name>
            <spirit:vector>
              <!--  vector info: CFGTE  -->
              <!--  vector details: CFGTE, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_CFGTE3  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CFGTE3</spirit:name>
      <spirit:displayName>Staticcfg_slave_CFGTE3</spirit:displayName>
      <spirit:description>CFGTE Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CFGTE3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CFGTE: CFGTE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CFGTE</spirit:name>
            <spirit:vector>
              <!--  vector info: CFGTE  -->
              <!--  vector details: CFGTE, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_VIRQ0  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_VIRQ0</spirit:name>
      <spirit:displayName>interrupt_slave_VIRQ0</spirit:displayName>
      <spirit:description>VIRQ Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_VIRQ0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_VIRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_VIRQ: nVIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nVIRQ  -->
              <!--  vector details: nVIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_VIRQ1  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_VIRQ1</spirit:name>
      <spirit:displayName>interrupt_slave_VIRQ1</spirit:displayName>
      <spirit:description>VIRQ Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_VIRQ1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_VIRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_VIRQ: nVIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nVIRQ  -->
              <!--  vector details: nVIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_VIRQ2  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_VIRQ2</spirit:name>
      <spirit:displayName>interrupt_slave_VIRQ2</spirit:displayName>
      <spirit:description>VIRQ Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_VIRQ2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_VIRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_VIRQ: nVIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nVIRQ  -->
              <!--  vector details: nVIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_VIRQ3  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_VIRQ3</spirit:name>
      <spirit:displayName>interrupt_slave_VIRQ3</spirit:displayName>
      <spirit:description>VIRQ Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_VIRQ3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_VIRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_VIRQ: nVIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nVIRQ  -->
              <!--  vector details: nVIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMADDRMAP4  -->
    
    <!--  Staticcfg_slave_SAMADDRMAP10  -->
    
    <!--  interrupt_slave_VFIQ0  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_VFIQ0</spirit:name>
      <spirit:displayName>interrupt_slave_VFIQ0</spirit:displayName>
      <spirit:description>VFIQ Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_VFIQ0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_VFIQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_VFIQ: nVFIQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVFIQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nVFIQ  -->
              <!--  vector details: nVFIQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_VFIQ1  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_VFIQ1</spirit:name>
      <spirit:displayName>interrupt_slave_VFIQ1</spirit:displayName>
      <spirit:description>VFIQ Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_VFIQ1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_VFIQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_VFIQ: nVFIQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVFIQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nVFIQ  -->
              <!--  vector details: nVFIQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_VFIQ2  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_VFIQ2</spirit:name>
      <spirit:displayName>interrupt_slave_VFIQ2</spirit:displayName>
      <spirit:description>VFIQ Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_VFIQ2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_VFIQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_VFIQ: nVFIQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVFIQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nVFIQ  -->
              <!--  vector details: nVFIQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_VFIQ3  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_VFIQ3</spirit:name>
      <spirit:displayName>interrupt_slave_VFIQ3</spirit:displayName>
      <spirit:description>VFIQ Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_VFIQ3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_VFIQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_VFIQ: nVFIQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVFIQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nVFIQ  -->
              <!--  vector details: nVFIQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_master_VCPU_MNT_IRQ0  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_VCPU_MNT_IRQ0</spirit:name>
      <spirit:displayName>interrupt_master_VCPU_MNT_IRQ0</spirit:displayName>
      <spirit:description>VCPUMNTIRQ Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_VCPU_MNT_IRQ0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_VCPU_MNT_IRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_VCPU_MNT_IRQ: nVCPUMNTIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVCPUMNTIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nVCPUMNTIRQ  -->
              <!--  vector details: nVCPUMNTIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_master_VCPU_MNT_IRQ1  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_VCPU_MNT_IRQ1</spirit:name>
      <spirit:displayName>interrupt_master_VCPU_MNT_IRQ1</spirit:displayName>
      <spirit:description>VCPUMNTIRQ Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_VCPU_MNT_IRQ1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_VCPU_MNT_IRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_VCPU_MNT_IRQ: nVCPUMNTIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVCPUMNTIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nVCPUMNTIRQ  -->
              <!--  vector details: nVCPUMNTIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_master_VCPU_MNT_IRQ2  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_VCPU_MNT_IRQ2</spirit:name>
      <spirit:displayName>interrupt_master_VCPU_MNT_IRQ2</spirit:displayName>
      <spirit:description>VCPUMNTIRQ Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_VCPU_MNT_IRQ2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_VCPU_MNT_IRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_VCPU_MNT_IRQ: nVCPUMNTIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVCPUMNTIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nVCPUMNTIRQ  -->
              <!--  vector details: nVCPUMNTIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_master_VCPU_MNT_IRQ3  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_VCPU_MNT_IRQ3</spirit:name>
      <spirit:displayName>interrupt_master_VCPU_MNT_IRQ3</spirit:displayName>
      <spirit:description>VCPUMNTIRQ Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_VCPU_MNT_IRQ3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_VCPU_MNT_IRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_VCPU_MNT_IRQ: nVCPUMNTIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVCPUMNTIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nVCPUMNTIRQ  -->
              <!--  vector details: nVCPUMNTIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  TimerEventInterface_master_CPU0  -->
    <spirit:busInterface>
      <spirit:name>TimerEventInterface_master_CPU0</spirit:name>
      <spirit:displayName>TimerEventInterface_master_CPU0</spirit:displayName>
      <spirit:description>TimerEventInterface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f TimerEventInterface_master_CPU0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="Cores" spirit:name="TimerEventInterface" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="Cores" spirit:name="TimerEventInterface_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  TimerEventInterface_master_CPU: nCNTVIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTVIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTVIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTVIRQ  -->
              <!--  vector details: nCNTVIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: nCNTPSIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTPSIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTPSIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTPSIRQ  -->
              <!--  vector details: nCNTPSIRQ, exp_per_cpu <per_cpu     >  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: nCNTPNSIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTPNSIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTPNSIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTPNSIRQ  -->
              <!--  vector details: nCNTPNSIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: nCNTHPIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTHPIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTHPIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTHPIRQ  -->
              <!--  vector details: nCNTHPIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  TimerEventInterface_master_CPU1  -->
    <spirit:busInterface>
      <spirit:name>TimerEventInterface_master_CPU1</spirit:name>
      <spirit:displayName>TimerEventInterface_master_CPU1</spirit:displayName>
      <spirit:description>TimerEventInterface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f TimerEventInterface_master_CPU1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="Cores" spirit:name="TimerEventInterface" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="Cores" spirit:name="TimerEventInterface_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  TimerEventInterface_master_CPU: nCNTVIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTVIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTVIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTVIRQ  -->
              <!--  vector details: nCNTVIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: nCNTPSIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTPSIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTPSIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTPSIRQ  -->
              <!--  vector details: nCNTPSIRQ, exp_per_cpu <per_cpu     >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: nCNTPNSIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTPNSIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTPNSIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTPNSIRQ  -->
              <!--  vector details: nCNTPNSIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: nCNTHPIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTHPIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTHPIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTHPIRQ  -->
              <!--  vector details: nCNTHPIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  TimerEventInterface_master_CPU2  -->
    <spirit:busInterface>
      <spirit:name>TimerEventInterface_master_CPU2</spirit:name>
      <spirit:displayName>TimerEventInterface_master_CPU2</spirit:displayName>
      <spirit:description>TimerEventInterface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f TimerEventInterface_master_CPU2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="Cores" spirit:name="TimerEventInterface" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="Cores" spirit:name="TimerEventInterface_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  TimerEventInterface_master_CPU: nCNTVIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTVIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTVIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTVIRQ  -->
              <!--  vector details: nCNTVIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: nCNTPSIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTPSIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTPSIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTPSIRQ  -->
              <!--  vector details: nCNTPSIRQ, exp_per_cpu <per_cpu     >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: nCNTPNSIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTPNSIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTPNSIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTPNSIRQ  -->
              <!--  vector details: nCNTPNSIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: nCNTHPIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTHPIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTHPIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTHPIRQ  -->
              <!--  vector details: nCNTHPIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  TimerEventInterface_master_CPU3  -->
    <spirit:busInterface>
      <spirit:name>TimerEventInterface_master_CPU3</spirit:name>
      <spirit:displayName>TimerEventInterface_master_CPU3</spirit:displayName>
      <spirit:description>TimerEventInterface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f TimerEventInterface_master_CPU3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="Cores" spirit:name="TimerEventInterface" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="Cores" spirit:name="TimerEventInterface_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  TimerEventInterface_master_CPU: nCNTVIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTVIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTVIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTVIRQ  -->
              <!--  vector details: nCNTVIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: nCNTPSIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTPSIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTPSIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTPSIRQ  -->
              <!--  vector details: nCNTPSIRQ, exp_per_cpu <per_cpu     >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: nCNTPNSIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTPNSIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTPNSIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTPNSIRQ  -->
              <!--  vector details: nCNTPNSIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  TimerEventInterface_master_CPU: nCNTHPIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>nCNTHPIRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCNTHPIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCNTHPIRQ  -->
              <!--  vector details: nCNTHPIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMADDRMAP9  -->
    
    <!--  ACP_slave  -->
    <spirit:busInterface>
      <spirit:name>ACP_slave</spirit:name>
      <spirit:displayName>ACP_slave</spirit:displayName>
      <spirit:description>ACP Slave</spirit:description>
      <!--  Need to generate required attributes for Bus i/f ACP_slave  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="ACP" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="ACP_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  ACP_slave: AWUSERS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWUSER</spirit:name>
            <spirit:vector>
              <!--  vector info: AWUSER  -->
              <!--  vector details: AWUSER, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWUSERS</spirit:name>
            <spirit:vector>
              <!--  vector info: AWUSERS  -->
              <!--  vector details: AWUSERS, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: ACLKENS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ACLKEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ACLKENS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ACLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: AWPROTS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWPROT</spirit:name>
            <spirit:vector>
              <!--  vector info: AWPROT  -->
              <!--  vector details: AWPROT, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWPROTS</spirit:name>
            <spirit:vector>
              <!--  vector info: AWPROTS  -->
              <!--  vector details: AWPROTS, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: AWREADYS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWREADYS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: RIDS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RID</spirit:name>
            <spirit:vector>
              <!--  vector info: RID  -->
              <!--  vector details: RID, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RIDS</spirit:name>
            <spirit:vector>
              <!--  vector info: RIDS  -->
              <!--  vector details: RIDS, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: AWIDS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWID</spirit:name>
            <spirit:vector>
              <!--  vector info: AWID  -->
              <!--  vector details: AWID, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWIDS</spirit:name>
            <spirit:vector>
              <!--  vector info: AWIDS  -->
              <!--  vector details: AWIDS, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: RRESPS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RRESP</spirit:name>
            <spirit:vector>
              <!--  vector info: RRESP  -->
              <!--  vector details: RRESP, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RRESPS</spirit:name>
            <spirit:vector>
              <!--  vector info: RRESPS  -->
              <!--  vector details: RRESPS, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: AWADDRS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWADDR</spirit:name>
            <spirit:vector>
              <!--  vector info: AWADDR  -->
              <!--  vector details: AWADDR, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWADDRS</spirit:name>
            <spirit:vector>
              <!--  vector info: AWADDRS  -->
              <!--  vector details: AWADDRS, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: WDATAS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: WDATA  -->
              <!--  vector details: WDATA, exp_per_cpu < >  -->
              <spirit:left>127</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>WDATAS</spirit:name>
            <spirit:vector>
              <!--  vector info: WDATAS  -->
              <!--  vector details: WDATAS, exp_per_cpu < >  -->
              <spirit:left>127</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: RDATAS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: RDATA  -->
              <!--  vector details: RDATA, exp_per_cpu < >  -->
              <spirit:left>127</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RDATAS</spirit:name>
            <spirit:vector>
              <!--  vector info: RDATAS  -->
              <!--  vector details: RDATAS, exp_per_cpu < >  -->
              <spirit:left>127</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: ARCACHES  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARCACHE</spirit:name>
            <spirit:vector>
              <!--  vector info: ARCACHE  -->
              <!--  vector details: ARCACHE, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARCACHES</spirit:name>
            <spirit:vector>
              <!--  vector info: ARCACHES  -->
              <!--  vector details: ARCACHES, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: ARREADYS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARREADYS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: RVALIDS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RVALIDS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: BIDS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BID</spirit:name>
            <spirit:vector>
              <!--  vector info: BID  -->
              <!--  vector details: BID, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>BIDS</spirit:name>
            <spirit:vector>
              <!--  vector info: BIDS  -->
              <!--  vector details: BIDS, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: WLASTS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WLAST</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>WLASTS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: WREADYS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>WREADYS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: WSTRBS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WSTRB</spirit:name>
            <spirit:vector>
              <!--  vector info: WSTRB  -->
              <!--  vector details: WSTRB, exp_per_cpu < >  -->
              <spirit:left>15</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>WSTRBS</spirit:name>
            <spirit:vector>
              <!--  vector info: WSTRBS  -->
              <!--  vector details: WSTRBS, exp_per_cpu < >  -->
              <spirit:left>15</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: ARUSERS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARUSER</spirit:name>
            <spirit:vector>
              <!--  vector info: ARUSER  -->
              <!--  vector details: ARUSER, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARUSERS</spirit:name>
            <spirit:vector>
              <!--  vector info: ARUSERS  -->
              <!--  vector details: ARUSERS, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: AWLENS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWLEN</spirit:name>
            <spirit:vector>
              <!--  vector info: AWLEN  -->
              <!--  vector details: AWLEN, exp_per_cpu < >  -->
              <spirit:left>7</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWLENS</spirit:name>
            <spirit:vector>
              <!--  vector info: AWLENS  -->
              <!--  vector details: AWLENS, exp_per_cpu < >  -->
              <spirit:left>7</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: RLASTS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RLAST</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RLASTS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: ARLENS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARLEN</spirit:name>
            <spirit:vector>
              <!--  vector info: ARLEN  -->
              <!--  vector details: ARLEN, exp_per_cpu < >  -->
              <spirit:left>7</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARLENS</spirit:name>
            <spirit:vector>
              <!--  vector info: ARLENS  -->
              <!--  vector details: ARLENS, exp_per_cpu < >  -->
              <spirit:left>7</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: ARPROTS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARPROT</spirit:name>
            <spirit:vector>
              <!--  vector info: ARPROT  -->
              <!--  vector details: ARPROT, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARPROTS</spirit:name>
            <spirit:vector>
              <!--  vector info: ARPROTS  -->
              <!--  vector details: ARPROTS, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: nL2RESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nL2RESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: WVALIDS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>WVALIDS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: AWCACHES  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWCACHE</spirit:name>
            <spirit:vector>
              <!--  vector info: AWCACHE  -->
              <!--  vector details: AWCACHE, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWCACHES</spirit:name>
            <spirit:vector>
              <!--  vector info: AWCACHES  -->
              <!--  vector details: AWCACHES, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: BVALIDS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>BVALIDS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: ARIDS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARID</spirit:name>
            <spirit:vector>
              <!--  vector info: ARID  -->
              <!--  vector details: ARID, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARIDS</spirit:name>
            <spirit:vector>
              <!--  vector info: ARIDS  -->
              <!--  vector details: ARIDS, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: BREADYS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>BREADYS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: AWVALIDS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWVALIDS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: ARADDRS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARADDR</spirit:name>
            <spirit:vector>
              <!--  vector info: ARADDR  -->
              <!--  vector details: ARADDR, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARADDRS</spirit:name>
            <spirit:vector>
              <!--  vector info: ARADDRS  -->
              <!--  vector details: ARADDRS, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: BRESPS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BRESP</spirit:name>
            <spirit:vector>
              <!--  vector info: BRESP  -->
              <!--  vector details: BRESP, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>BRESPS</spirit:name>
            <spirit:vector>
              <!--  vector info: BRESPS  -->
              <!--  vector details: BRESPS, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: ARVALIDS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARVALIDS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACP_slave: RREADYS  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RREADYS</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMMN_BASE  -->
    
    <!--  Staticcfg_slave_SAMADDRMAP5  -->
    
    <!--  Staticcfg_slave_SAMMN_NODEID  -->
    
    <!--  Staticcfg_slave_SAMADDRMAP0  -->
    
    <!--  Staticcfg_slave_VINITHI0  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_VINITHI0</spirit:name>
      <spirit:displayName>Staticcfg_slave_VINITHI0</spirit:displayName>
      <spirit:description>VINITHIInterface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_VINITHI0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_VINITHI: VINITHI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>VINITHI</spirit:name>
            <spirit:vector>
              <!--  vector info: VINITHI  -->
              <!--  vector details: VINITHI, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_VINITHI1  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_VINITHI1</spirit:name>
      <spirit:displayName>Staticcfg_slave_VINITHI1</spirit:displayName>
      <spirit:description>VINITHIInterface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_VINITHI1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_VINITHI: VINITHI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>VINITHI</spirit:name>
            <spirit:vector>
              <!--  vector info: VINITHI  -->
              <!--  vector details: VINITHI, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_VINITHI2  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_VINITHI2</spirit:name>
      <spirit:displayName>Staticcfg_slave_VINITHI2</spirit:displayName>
      <spirit:description>VINITHIInterface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_VINITHI2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_VINITHI: VINITHI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>VINITHI</spirit:name>
            <spirit:vector>
              <!--  vector info: VINITHI  -->
              <!--  vector details: VINITHI, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_VINITHI3  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_VINITHI3</spirit:name>
      <spirit:displayName>Staticcfg_slave_VINITHI3</spirit:displayName>
      <spirit:description>VINITHIInterface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_VINITHI3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_VINITHI: VINITHI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>VINITHI</spirit:name>
            <spirit:vector>
              <!--  vector info: VINITHI  -->
              <!--  vector details: VINITHI, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  ATB_master_CPU0  -->
    <spirit:busInterface>
      <spirit:name>ATB_master_CPU0</spirit:name>
      <spirit:displayName>ATB_master_CPU0</spirit:displayName>
      <spirit:description>ATB Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f ATB_master_CPU0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="ATB" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="ATB_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  ATB_master_CPU0: AFREADYM0  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AFREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AFREADYM0</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU0: SYNCREQM0  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SYNCREQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SYNCREQM0</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU0: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATCLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU0: ATREADYM0  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATREADYM0</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU0: ATBYTESM0  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATBYTES</spirit:name>
            <spirit:vector>
              <!--  vector info: ATBYTES  -->
              <!--  vector details: ATBYTES, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATBYTESM0</spirit:name>
            <spirit:vector>
              <!--  vector info: ATBYTESM0  -->
              <!--  vector details: ATBYTESM0, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU0: ATDATAM0  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: ATDATA  -->
              <!--  vector details: ATDATA, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATDATAM0</spirit:name>
            <spirit:vector>
              <!--  vector info: ATDATAM0  -->
              <!--  vector details: ATDATAM0, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU0: ATCLKEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATCLKEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATCLKEN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU0: AFVALIDM0  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AFVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AFVALIDM0</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU0: ATIDM0  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATID</spirit:name>
            <spirit:vector>
              <!--  vector info: ATID  -->
              <!--  vector details: ATID, exp_per_cpu < >  -->
              <spirit:left>6</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATIDM0</spirit:name>
            <spirit:vector>
              <!--  vector info: ATIDM0  -->
              <!--  vector details: ATIDM0, exp_per_cpu < >  -->
              <spirit:left>6</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU0: nCPUPORESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATRESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCPUPORESET</spirit:name>
            <spirit:vector>
              <!--  vector info: nCPUPORESET  -->
              <!--  vector details: nCPUPORESET, exp_per_cpu <per_cpu_explicit>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU0: ATVALIDM0  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATVALIDM0</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMADDRMAP12  -->
    
    <!--  RESET_slave_MBIST  -->
    <spirit:busInterface>
      <spirit:name>RESET_slave_MBIST</spirit:name>
      <spirit:displayName>RESET_slave_MBIST</spirit:displayName>
      <spirit:description>MBISTRESET Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f RESET_slave_MBIST  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  RESET_slave_MBIST: nMBISTRESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nMBISTRESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  RESET_slave_MBIST: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  Staticcfg_slave_CLUSTERIDAFF1  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CLUSTERIDAFF1</spirit:name>
      <spirit:displayName>Staticcfg_slave_CLUSTERIDAFF1</spirit:displayName>
      <spirit:description>CLUSTERID AFF1 Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CLUSTERIDAFF1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CLUSTERIDAFF1: CLUSTERIDAFF1  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
            <spirit:vector>
              <!--  vector info: CONFIGURATION  -->
              <!--  vector details: CONFIGURATION, exp_per_cpu < >  -->
              <spirit:left>7</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLUSTERIDAFF1</spirit:name>
            <spirit:vector>
              <!--  vector info: CLUSTERIDAFF1  -->
              <!--  vector details: CLUSTERIDAFF1, exp_per_cpu < >  -->
              <spirit:left>7</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  Staticcfg_slave_CRYPTO_DISABLE0  -->
    
    <!--  Staticcfg_slave_CRYPTO_DISABLE1  -->
    
    <!--  Staticcfg_slave_CRYPTO_DISABLE2  -->
    
    <!--  Staticcfg_slave_CRYPTO_DISABLE3  -->
    
    <!--  Authentication_slave_CPU0  -->
    <spirit:busInterface>
      <spirit:name>Authentication_slave_CPU0</spirit:name>
      <spirit:displayName>Authentication_slave_CPU0</spirit:displayName>
      <spirit:description>Authentication Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Authentication_slave_CPU0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="Authentication" spirit:version="r0p0_1"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="Authentication_rtl" spirit:version="r0p0_1"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Authentication_slave_CPU: SPIDEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SPIDEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SPIDEN</spirit:name>
            <spirit:vector>
              <!--  vector info: SPIDEN  -->
              <!--  vector details: SPIDEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Authentication_slave_CPU: DBGEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>DBGEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>DBGEN</spirit:name>
            <spirit:vector>
              <!--  vector info: DBGEN  -->
              <!--  vector details: DBGEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Authentication_slave_CPU: NIDEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>NIDEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NIDEN</spirit:name>
            <spirit:vector>
              <!--  vector info: NIDEN  -->
              <!--  vector details: NIDEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Authentication_slave_CPU: SPNIDEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SPNIDEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SPNIDEN</spirit:name>
            <spirit:vector>
              <!--  vector info: SPNIDEN  -->
              <!--  vector details: SPNIDEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Authentication_slave_CPU1  -->
    <spirit:busInterface>
      <spirit:name>Authentication_slave_CPU1</spirit:name>
      <spirit:displayName>Authentication_slave_CPU1</spirit:displayName>
      <spirit:description>Authentication Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Authentication_slave_CPU1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="Authentication" spirit:version="r0p0_1"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="Authentication_rtl" spirit:version="r0p0_1"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Authentication_slave_CPU: SPIDEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SPIDEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SPIDEN</spirit:name>
            <spirit:vector>
              <!--  vector info: SPIDEN  -->
              <!--  vector details: SPIDEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Authentication_slave_CPU: DBGEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>DBGEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>DBGEN</spirit:name>
            <spirit:vector>
              <!--  vector info: DBGEN  -->
              <!--  vector details: DBGEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Authentication_slave_CPU: NIDEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>NIDEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NIDEN</spirit:name>
            <spirit:vector>
              <!--  vector info: NIDEN  -->
              <!--  vector details: NIDEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Authentication_slave_CPU: SPNIDEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SPNIDEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SPNIDEN</spirit:name>
            <spirit:vector>
              <!--  vector info: SPNIDEN  -->
              <!--  vector details: SPNIDEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Authentication_slave_CPU2  -->
    <spirit:busInterface>
      <spirit:name>Authentication_slave_CPU2</spirit:name>
      <spirit:displayName>Authentication_slave_CPU2</spirit:displayName>
      <spirit:description>Authentication Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Authentication_slave_CPU2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="Authentication" spirit:version="r0p0_1"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="Authentication_rtl" spirit:version="r0p0_1"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Authentication_slave_CPU: SPIDEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SPIDEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SPIDEN</spirit:name>
            <spirit:vector>
              <!--  vector info: SPIDEN  -->
              <!--  vector details: SPIDEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Authentication_slave_CPU: DBGEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>DBGEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>DBGEN</spirit:name>
            <spirit:vector>
              <!--  vector info: DBGEN  -->
              <!--  vector details: DBGEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Authentication_slave_CPU: NIDEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>NIDEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NIDEN</spirit:name>
            <spirit:vector>
              <!--  vector info: NIDEN  -->
              <!--  vector details: NIDEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Authentication_slave_CPU: SPNIDEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SPNIDEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SPNIDEN</spirit:name>
            <spirit:vector>
              <!--  vector info: SPNIDEN  -->
              <!--  vector details: SPNIDEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Authentication_slave_CPU3  -->
    <spirit:busInterface>
      <spirit:name>Authentication_slave_CPU3</spirit:name>
      <spirit:displayName>Authentication_slave_CPU3</spirit:displayName>
      <spirit:description>Authentication Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Authentication_slave_CPU3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="Authentication" spirit:version="r0p0_1"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="Authentication_rtl" spirit:version="r0p0_1"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Authentication_slave_CPU: SPIDEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SPIDEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SPIDEN</spirit:name>
            <spirit:vector>
              <!--  vector info: SPIDEN  -->
              <!--  vector details: SPIDEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Authentication_slave_CPU: DBGEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>DBGEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>DBGEN</spirit:name>
            <spirit:vector>
              <!--  vector info: DBGEN  -->
              <!--  vector details: DBGEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Authentication_slave_CPU: NIDEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>NIDEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>NIDEN</spirit:name>
            <spirit:vector>
              <!--  vector info: NIDEN  -->
              <!--  vector details: NIDEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Authentication_slave_CPU: SPNIDEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SPNIDEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SPNIDEN</spirit:name>
            <spirit:vector>
              <!--  vector info: SPNIDEN  -->
              <!--  vector details: SPNIDEN, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  CHI-RNF_master  -->
    
    <!--  Staticcfg_slave_CP15SDISABLE0  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CP15SDISABLE0</spirit:name>
      <spirit:displayName>Staticcfg_slave_CP15SDISABLE0</spirit:displayName>
      <spirit:description>CP15SDISABLEInterface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CP15SDISABLE0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CP15SDISABLE: CP15SDISABLE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CP15SDISABLE</spirit:name>
            <spirit:vector>
              <!--  vector info: CP15SDISABLE  -->
              <!--  vector details: CP15SDISABLE, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_CP15SDISABLE1  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CP15SDISABLE1</spirit:name>
      <spirit:displayName>Staticcfg_slave_CP15SDISABLE1</spirit:displayName>
      <spirit:description>CP15SDISABLEInterface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CP15SDISABLE1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CP15SDISABLE: CP15SDISABLE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CP15SDISABLE</spirit:name>
            <spirit:vector>
              <!--  vector info: CP15SDISABLE  -->
              <!--  vector details: CP15SDISABLE, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_CP15SDISABLE2  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CP15SDISABLE2</spirit:name>
      <spirit:displayName>Staticcfg_slave_CP15SDISABLE2</spirit:displayName>
      <spirit:description>CP15SDISABLEInterface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CP15SDISABLE2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CP15SDISABLE: CP15SDISABLE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CP15SDISABLE</spirit:name>
            <spirit:vector>
              <!--  vector info: CP15SDISABLE  -->
              <!--  vector details: CP15SDISABLE, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_CP15SDISABLE3  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CP15SDISABLE3</spirit:name>
      <spirit:displayName>Staticcfg_slave_CP15SDISABLE3</spirit:displayName>
      <spirit:description>CP15SDISABLEInterface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CP15SDISABLE3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CP15SDISABLE: CP15SDISABLE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CP15SDISABLE</spirit:name>
            <spirit:vector>
              <!--  vector info: CP15SDISABLE  -->
              <!--  vector details: CP15SDISABLE, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Channel_slave_CTI_CHIN  -->
    <spirit:busInterface>
      <spirit:name>Channel_slave_CTI_CHIN</spirit:name>
      <spirit:displayName>Channel_slave_CTI_CHIN</spirit:displayName>
      <spirit:description>CoreSight CTICHIN Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Channel_slave_CTI_CHIN  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="Channel" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="Channel_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Channel_slave_CTI_CHIN: nL2RESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nL2RESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Channel_slave_CTI_CHIN: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CHCLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Channel_slave_CTI_CHIN: CTICHINACK  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CHACK</spirit:name>
            <spirit:vector>
              <!--  vector info: CHACK  -->
              <!--  vector details: CHACK, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CTICHINACK</spirit:name>
            <spirit:vector>
              <!--  vector info: CTICHINACK  -->
              <!--  vector details: CTICHINACK, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Channel_slave_CTI_CHIN: CTICHIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CH</spirit:name>
            <spirit:vector>
              <!--  vector info: CH  -->
              <!--  vector details: CH, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CTICHIN</spirit:name>
            <spirit:vector>
              <!--  vector info: CTICHIN  -->
              <!--  vector details: CTICHIN, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  AXI4Stream_master_PROCESSOR  -->
    <spirit:busInterface>
      <spirit:name>AXI4Stream_master_PROCESSOR</spirit:name>
      <spirit:displayName>AXI4Stream_master_PROCESSOR</spirit:displayName>
      <spirit:description>AXI4Stream Processor for GIC</spirit:description>
      <!--  Need to generate required attributes for Bus i/f AXI4Stream_master_PROCESSOR  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="AXI4Stream" spirit:version="r0p0_1"/>
      <spirit:abstractionType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="AXI4Stream_rtl" spirit:version="r0p0_1"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  AXI4Stream_master_PROCESSOR: nL2RESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nL2RESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  AXI4Stream_master_PROCESSOR: ICCTVALID  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>TVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ICCTVALID</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  AXI4Stream_master_PROCESSOR: ICCTREADY  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>TREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ICCTREADY</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  AXI4Stream_master_PROCESSOR: ICCTLAST  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>TLAST</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ICCTLAST</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  AXI4Stream_master_PROCESSOR: ICCTID  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>TID</spirit:name>
            <spirit:vector>
              <!--  vector info: TID  -->
              <!--  vector details: TID, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ICCTID</spirit:name>
            <spirit:vector>
              <!--  vector info: ICCTID  -->
              <!--  vector details: ICCTID, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  AXI4Stream_master_PROCESSOR: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ACLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  AXI4Stream_master_PROCESSOR: ICCTDATA  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>TDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: TDATA  -->
              <!--  vector details: TDATA, exp_per_cpu < >  -->
              <spirit:left>15</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ICCTDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: ICCTDATA  -->
              <!--  vector details: ICCTDATA, exp_per_cpu < >  -->
              <spirit:left>15</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  Channel_master_CTI_CHOUT  -->
    <spirit:busInterface>
      <spirit:name>Channel_master_CTI_CHOUT</spirit:name>
      <spirit:displayName>Channel_master_CTI_CHOUT</spirit:displayName>
      <spirit:description>CoreSight CTICHOUT Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Channel_master_CTI_CHOUT  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="Channel" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="Channel_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Channel_master_CTI_CHOUT: nL2RESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nL2RESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Channel_master_CTI_CHOUT: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CHCLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Channel_master_CTI_CHOUT: CTICHOUTACK  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CHACK</spirit:name>
            <spirit:vector>
              <!--  vector info: CHACK  -->
              <!--  vector details: CHACK, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CTICHOUTACK</spirit:name>
            <spirit:vector>
              <!--  vector info: CTICHOUTACK  -->
              <!--  vector details: CTICHOUTACK, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Channel_master_CTI_CHOUT: CTICHOUT  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CH</spirit:name>
            <spirit:vector>
              <!--  vector info: CH  -->
              <!--  vector details: CH, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CTICHOUT</spirit:name>
            <spirit:vector>
              <!--  vector info: CTICHOUT  -->
              <!--  vector details: CTICHOUT, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  Staticcfg_slave_NODEID  -->
    
    <!--  Staticcfg_slave_SAMADDRMAP8  -->
    
    <!--  Staticcfg_slave_SAMADDRMAP2  -->
    
    <!--  Staticcfg_slave_SAMHNF0_NODEID  -->
    
    <!--  Staticcfg_slave_RVB_ARADDR1  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_RVB_ARADDR1</spirit:name>
      <spirit:displayName>Staticcfg_slave_RVB_ARADDR1</spirit:displayName>
      <spirit:description>RVBARADDR CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_RVB_ARADDR1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_RVB_ARADDR1: RVBARADDR1  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
            <spirit:vector>
              <!--  vector info: CONFIGURATION  -->
              <!--  vector details: CONFIGURATION, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RVBARADDR1</spirit:name>
            <spirit:vector>
              <!--  vector info: RVBARADDR1  -->
              <!--  vector details: RVBARADDR1, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_master_INTERRIRQ  -->
    
    <!--  Staticcfg_slave_SAMHNF5_NODEID  -->
    
    <!--  Staticcfg_slave_SYSBARDISABLE  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_SYSBARDISABLE</spirit:name>
      <spirit:displayName>Staticcfg_slave_SYSBARDISABLE</spirit:displayName>
      <spirit:description>SYSBAR DISABLE Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_SYSBARDISABLE  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_SYSBARDISABLE: SYSBARDISABLE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SYSBARDISABLE</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  Staticcfg_slave_GICC_DISABLE  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_GICC_DISABLE</spirit:name>
      <spirit:displayName>Staticcfg_slave_GICC_DISABLE</spirit:displayName>
      <spirit:description>GICCDISABLE</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_GICC_DISABLE  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_GICC_DISABLE: GICCDISABLE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>GICCDISABLE</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  ACE_master  -->
    <spirit:busInterface>
      <spirit:name>ACE_master</spirit:name>
      <spirit:displayName>ACE_master</spirit:displayName>
      <spirit:description>ACE Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f ACE_master  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="ACE" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="ACE_rtl" spirit:version="r0p0_0"/>
      <spirit:master>
        <spirit:addressSpaceRef spirit:addressSpaceRef="Main_Bus"/>
      </spirit:master>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  ACE_master: ARSNOOPM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARSNOOP</spirit:name>
            <spirit:vector>
              <!--  vector info: ARSNOOP  -->
              <!--  vector details: ARSNOOP, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARSNOOPM</spirit:name>
            <spirit:vector>
              <!--  vector info: ARSNOOPM  -->
              <!--  vector details: ARSNOOPM, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: RACKM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RACK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RACKM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ACLKENM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ACLKEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ACLKENM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: CDLASTM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CDLAST</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CDLASTM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ACPROTM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ACPROT</spirit:name>
            <spirit:vector>
              <!--  vector info: ACPROT  -->
              <!--  vector details: ACPROT, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ACPROTM</spirit:name>
            <spirit:vector>
              <!--  vector info: ACPROTM  -->
              <!--  vector details: ACPROTM, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ARBARM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARBAR</spirit:name>
            <spirit:vector>
              <!--  vector info: ARBAR  -->
              <!--  vector details: ARBAR, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARBARM</spirit:name>
            <spirit:vector>
              <!--  vector info: ARBARM  -->
              <!--  vector details: ARBARM, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWLOCKM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWLOCK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWLOCKM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ACLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWPROTM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWPROT</spirit:name>
            <spirit:vector>
              <!--  vector info: AWPROT  -->
              <!--  vector details: AWPROT, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWPROTM</spirit:name>
            <spirit:vector>
              <!--  vector info: AWPROTM  -->
              <!--  vector details: AWPROTM, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ACREADYM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ACREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ACREADYM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWREADYM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWREADYM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: RIDM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RID</spirit:name>
            <spirit:vector>
              <!--  vector info: RID  -->
              <!--  vector details: RID, exp_per_cpu < >  -->
              <spirit:left>5</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RIDM</spirit:name>
            <spirit:vector>
              <!--  vector info: RIDM  -->
              <!--  vector details: RIDM, exp_per_cpu < >  -->
              <spirit:left>5</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWIDM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWID</spirit:name>
            <spirit:vector>
              <!--  vector info: AWID  -->
              <!--  vector details: AWID, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWIDM</spirit:name>
            <spirit:vector>
              <!--  vector info: AWIDM  -->
              <!--  vector details: AWIDM, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: RRESPM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RRESP</spirit:name>
            <spirit:vector>
              <!--  vector info: RRESP  -->
              <!--  vector details: RRESP, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RRESPM</spirit:name>
            <spirit:vector>
              <!--  vector info: RRESPM  -->
              <!--  vector details: RRESPM, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: WDATAM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: WDATA  -->
              <!--  vector details: WDATA, exp_per_cpu < >  -->
              <spirit:left>127</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>WDATAM</spirit:name>
            <spirit:vector>
              <!--  vector info: WDATAM  -->
              <!--  vector details: WDATAM, exp_per_cpu < >  -->
              <spirit:left>127</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWADDRM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWADDR</spirit:name>
            <spirit:vector>
              <!--  vector info: AWADDR  -->
              <!--  vector details: AWADDR, exp_per_cpu < >  -->
              <spirit:left>43</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWADDRM</spirit:name>
            <spirit:vector>
              <!--  vector info: AWADDRM  -->
              <!--  vector details: AWADDRM, exp_per_cpu < >  -->
              <spirit:left>43</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: RDATAM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: RDATA  -->
              <!--  vector details: RDATA, exp_per_cpu < >  -->
              <spirit:left>127</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RDATAM</spirit:name>
            <spirit:vector>
              <!--  vector info: RDATAM  -->
              <!--  vector details: RDATAM, exp_per_cpu < >  -->
              <spirit:left>127</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ARCACHEM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARCACHE</spirit:name>
            <spirit:vector>
              <!--  vector info: ARCACHE  -->
              <!--  vector details: ARCACHE, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARCACHEM</spirit:name>
            <spirit:vector>
              <!--  vector info: ARCACHEM  -->
              <!--  vector details: ARCACHEM, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ARREADYM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARREADYM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ARBURSTM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARBURST</spirit:name>
            <spirit:vector>
              <!--  vector info: ARBURST  -->
              <!--  vector details: ARBURST, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARBURSTM</spirit:name>
            <spirit:vector>
              <!--  vector info: ARBURSTM  -->
              <!--  vector details: ARBURSTM, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: WACKM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WACK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>WACKM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: RVALIDM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RVALIDM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: BIDM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BID</spirit:name>
            <spirit:vector>
              <!--  vector info: BID  -->
              <!--  vector details: BID, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>BIDM</spirit:name>
            <spirit:vector>
              <!--  vector info: BIDM  -->
              <!--  vector details: BIDM, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: WLASTM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WLAST</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>WLASTM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: CRRESPM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CRRESP</spirit:name>
            <spirit:vector>
              <!--  vector info: CRRESP  -->
              <!--  vector details: CRRESP, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CRRESPM</spirit:name>
            <spirit:vector>
              <!--  vector info: CRRESPM  -->
              <!--  vector details: CRRESPM, exp_per_cpu < >  -->
              <spirit:left>4</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWBARM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWBAR</spirit:name>
            <spirit:vector>
              <!--  vector info: AWBAR  -->
              <!--  vector details: AWBAR, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWBARM</spirit:name>
            <spirit:vector>
              <!--  vector info: AWBARM  -->
              <!--  vector details: AWBARM, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: WREADYM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>WREADYM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ARLOCKM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARLOCK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARLOCKM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ACVALIDM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ACVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ACVALIDM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: WSTRBM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WSTRB</spirit:name>
            <spirit:vector>
              <!--  vector info: WSTRB  -->
              <!--  vector details: WSTRB, exp_per_cpu < >  -->
              <spirit:left>15</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>WSTRBM</spirit:name>
            <spirit:vector>
              <!--  vector info: WSTRBM  -->
              <!--  vector details: WSTRBM, exp_per_cpu < >  -->
              <spirit:left>15</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWLENM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWLEN</spirit:name>
            <spirit:vector>
              <!--  vector info: AWLEN  -->
              <!--  vector details: AWLEN, exp_per_cpu < >  -->
              <spirit:left>7</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWLENM</spirit:name>
            <spirit:vector>
              <!--  vector info: AWLENM  -->
              <!--  vector details: AWLENM, exp_per_cpu < >  -->
              <spirit:left>7</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWBURSTM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWBURST</spirit:name>
            <spirit:vector>
              <!--  vector info: AWBURST  -->
              <!--  vector details: AWBURST, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWBURSTM</spirit:name>
            <spirit:vector>
              <!--  vector info: AWBURSTM  -->
              <!--  vector details: AWBURSTM, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ARSIZEM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARSIZE</spirit:name>
            <spirit:vector>
              <!--  vector info: ARSIZE  -->
              <!--  vector details: ARSIZE, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARSIZEM</spirit:name>
            <spirit:vector>
              <!--  vector info: ARSIZEM  -->
              <!--  vector details: ARSIZEM, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: RLASTM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RLAST</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RLASTM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ARPROTM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARPROT</spirit:name>
            <spirit:vector>
              <!--  vector info: ARPROT  -->
              <!--  vector details: ARPROT, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARPROTM</spirit:name>
            <spirit:vector>
              <!--  vector info: ARPROTM  -->
              <!--  vector details: ARPROTM, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ARLENM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARLEN</spirit:name>
            <spirit:vector>
              <!--  vector info: ARLEN  -->
              <!--  vector details: ARLEN, exp_per_cpu < >  -->
              <spirit:left>7</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARLENM</spirit:name>
            <spirit:vector>
              <!--  vector info: ARLENM  -->
              <!--  vector details: ARLENM, exp_per_cpu < >  -->
              <spirit:left>7</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: nL2RESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nL2RESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: WVALIDM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>WVALIDM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: CDVALIDM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CDVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CDVALIDM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ACADDRM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ACADDR</spirit:name>
            <spirit:vector>
              <!--  vector info: ACADDR  -->
              <!--  vector details: ACADDR, exp_per_cpu < >  -->
              <spirit:left>43</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ACADDRM</spirit:name>
            <spirit:vector>
              <!--  vector info: ACADDRM  -->
              <!--  vector details: ACADDRM, exp_per_cpu < >  -->
              <spirit:left>43</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: CDDATAM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CDDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: CDDATA  -->
              <!--  vector details: CDDATA, exp_per_cpu < >  -->
              <spirit:left>127</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CDDATAM</spirit:name>
            <spirit:vector>
              <!--  vector info: CDDATAM  -->
              <!--  vector details: CDDATAM, exp_per_cpu < >  -->
              <spirit:left>127</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWCACHEM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWCACHE</spirit:name>
            <spirit:vector>
              <!--  vector info: AWCACHE  -->
              <!--  vector details: AWCACHE, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWCACHEM</spirit:name>
            <spirit:vector>
              <!--  vector info: AWCACHEM  -->
              <!--  vector details: AWCACHEM, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: BVALIDM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>BVALIDM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: CRVALIDM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CRVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CRVALIDM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ARIDM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARID</spirit:name>
            <spirit:vector>
              <!--  vector info: ARID  -->
              <!--  vector details: ARID, exp_per_cpu < >  -->
              <spirit:left>5</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARIDM</spirit:name>
            <spirit:vector>
              <!--  vector info: ARIDM  -->
              <!--  vector details: ARIDM, exp_per_cpu < >  -->
              <spirit:left>5</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ARDOMAINM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARDOMAIN</spirit:name>
            <spirit:vector>
              <!--  vector info: ARDOMAIN  -->
              <!--  vector details: ARDOMAIN, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARDOMAINM</spirit:name>
            <spirit:vector>
              <!--  vector info: ARDOMAINM  -->
              <!--  vector details: ARDOMAINM, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: BREADYM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>BREADYM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWDOMAINM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWDOMAIN</spirit:name>
            <spirit:vector>
              <!--  vector info: AWDOMAIN  -->
              <!--  vector details: AWDOMAIN, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWDOMAINM</spirit:name>
            <spirit:vector>
              <!--  vector info: AWDOMAINM  -->
              <!--  vector details: AWDOMAINM, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: CDREADYM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CDREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CDREADYM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: CRREADYM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CRREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CRREADYM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ACSNOOPM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ACSNOOP</spirit:name>
            <spirit:vector>
              <!--  vector info: ACSNOOP  -->
              <!--  vector details: ACSNOOP, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ACSNOOPM</spirit:name>
            <spirit:vector>
              <!--  vector info: ACSNOOPM  -->
              <!--  vector details: ACSNOOPM, exp_per_cpu < >  -->
              <spirit:left>3</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWVALIDM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWVALIDM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWSNOOPM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWSNOOP</spirit:name>
            <spirit:vector>
              <!--  vector info: AWSNOOP  -->
              <!--  vector details: AWSNOOP, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWSNOOPM</spirit:name>
            <spirit:vector>
              <!--  vector info: AWSNOOPM  -->
              <!--  vector details: AWSNOOPM, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ARADDRM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARADDR</spirit:name>
            <spirit:vector>
              <!--  vector info: ARADDR  -->
              <!--  vector details: ARADDR, exp_per_cpu < >  -->
              <spirit:left>43</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARADDRM</spirit:name>
            <spirit:vector>
              <!--  vector info: ARADDRM  -->
              <!--  vector details: ARADDRM, exp_per_cpu < >  -->
              <spirit:left>43</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: AWSIZEM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWSIZE</spirit:name>
            <spirit:vector>
              <!--  vector info: AWSIZE  -->
              <!--  vector details: AWSIZE, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AWSIZEM</spirit:name>
            <spirit:vector>
              <!--  vector info: AWSIZEM  -->
              <!--  vector details: AWSIZEM, exp_per_cpu < >  -->
              <spirit:left>2</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: BRESPM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BRESP</spirit:name>
            <spirit:vector>
              <!--  vector info: BRESP  -->
              <!--  vector details: BRESP, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>BRESPM</spirit:name>
            <spirit:vector>
              <!--  vector info: BRESPM  -->
              <!--  vector details: BRESPM, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: ARVALIDM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ARVALIDM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ACE_master: RREADYM  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RREADYM</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMADDRMAP1  -->
    
    <!--  ATB_master_CPU1  -->
    <spirit:busInterface>
      <spirit:name>ATB_master_CPU1</spirit:name>
      <spirit:displayName>ATB_master_CPU1</spirit:displayName>
      <spirit:description>ATB Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f ATB_master_CPU1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="ATB" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="amba.com" spirit:library="AMBA4" spirit:name="ATB_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  ATB_master_CPU1: AFREADYM1  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AFREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AFREADYM1</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU1: SYNCREQM1  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SYNCREQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>SYNCREQM1</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU1: ATREADYM1  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATREADYM1</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU1: ATBYTESM1  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATBYTES</spirit:name>
            <spirit:vector>
              <!--  vector info: ATBYTES  -->
              <!--  vector details: ATBYTES, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATBYTESM1</spirit:name>
            <spirit:vector>
              <!--  vector info: ATBYTESM1  -->
              <!--  vector details: ATBYTESM1, exp_per_cpu < >  -->
              <spirit:left>1</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU1: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATCLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU1: ATDATAM1  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATDATA</spirit:name>
            <spirit:vector>
              <!--  vector info: ATDATA  -->
              <!--  vector details: ATDATA, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATDATAM1</spirit:name>
            <spirit:vector>
              <!--  vector info: ATDATAM1  -->
              <!--  vector details: ATDATAM1, exp_per_cpu < >  -->
              <spirit:left>31</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU1: ATCLKEN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATCLKEN</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATCLKEN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU1: AFVALIDM1  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AFVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AFVALIDM1</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU1: ATIDM1  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATID</spirit:name>
            <spirit:vector>
              <!--  vector info: ATID  -->
              <!--  vector details: ATID, exp_per_cpu < >  -->
              <spirit:left>6</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATIDM1</spirit:name>
            <spirit:vector>
              <!--  vector info: ATIDM1  -->
              <!--  vector details: ATIDM1, exp_per_cpu < >  -->
              <spirit:left>6</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU1: nCPUPORESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATRESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCPUPORESET</spirit:name>
            <spirit:vector>
              <!--  vector info: nCPUPORESET  -->
              <!--  vector details: nCPUPORESET, exp_per_cpu <per_cpu_explicit>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  ATB_master_CPU1: ATVALIDM1  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ATVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ATVALIDM1</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMHNF2_NODEID  -->
    
    <!--  interrupt_master_COMMIRQ0  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_COMMIRQ0</spirit:name>
      <spirit:displayName>interrupt_master_COMMIRQ0</spirit:displayName>
      <spirit:description>COMMIRQInterface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_COMMIRQ0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_COMMIRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_COMMIRQ: nCOMMIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCOMMIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCOMMIRQ  -->
              <!--  vector details: nCOMMIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_master_COMMIRQ1  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_COMMIRQ1</spirit:name>
      <spirit:displayName>interrupt_master_COMMIRQ1</spirit:displayName>
      <spirit:description>COMMIRQInterface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_COMMIRQ1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_COMMIRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_COMMIRQ: nCOMMIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCOMMIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCOMMIRQ  -->
              <!--  vector details: nCOMMIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_master_COMMIRQ2  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_COMMIRQ2</spirit:name>
      <spirit:displayName>interrupt_master_COMMIRQ2</spirit:displayName>
      <spirit:description>COMMIRQInterface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_COMMIRQ2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_COMMIRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_COMMIRQ: nCOMMIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCOMMIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCOMMIRQ  -->
              <!--  vector details: nCOMMIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_master_COMMIRQ3  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_COMMIRQ3</spirit:name>
      <spirit:displayName>interrupt_master_COMMIRQ3</spirit:displayName>
      <spirit:description>COMMIRQInterface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_COMMIRQ3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_COMMIRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_COMMIRQ: nCOMMIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCOMMIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nCOMMIRQ  -->
              <!--  vector details: nCOMMIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_AA64nAA32_CPU0  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_AA64nAA32_CPU0</spirit:name>
      <spirit:displayName>Staticcfg_slave_AA64nAA32_CPU0</spirit:displayName>
      <spirit:description>AA64nAA32Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_AA64nAA32_CPU0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_AA64nAA32_CPU: AA64nAA32  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AA64nAA32</spirit:name>
            <spirit:vector>
              <!--  vector info: AA64nAA32  -->
              <!--  vector details: AA64nAA32, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_AA64nAA32_CPU1  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_AA64nAA32_CPU1</spirit:name>
      <spirit:displayName>Staticcfg_slave_AA64nAA32_CPU1</spirit:displayName>
      <spirit:description>AA64nAA32Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_AA64nAA32_CPU1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_AA64nAA32_CPU: AA64nAA32  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AA64nAA32</spirit:name>
            <spirit:vector>
              <!--  vector info: AA64nAA32  -->
              <!--  vector details: AA64nAA32, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_AA64nAA32_CPU2  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_AA64nAA32_CPU2</spirit:name>
      <spirit:displayName>Staticcfg_slave_AA64nAA32_CPU2</spirit:displayName>
      <spirit:description>AA64nAA32Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_AA64nAA32_CPU2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_AA64nAA32_CPU: AA64nAA32  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AA64nAA32</spirit:name>
            <spirit:vector>
              <!--  vector info: AA64nAA32  -->
              <!--  vector details: AA64nAA32, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_AA64nAA32_CPU3  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_AA64nAA32_CPU3</spirit:name>
      <spirit:displayName>Staticcfg_slave_AA64nAA32_CPU3</spirit:displayName>
      <spirit:description>AA64nAA32Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_AA64nAA32_CPU3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_AA64nAA32_CPU: AA64nAA32  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>AA64nAA32</spirit:name>
            <spirit:vector>
              <!--  vector info: AA64nAA32  -->
              <!--  vector details: AA64nAA32, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_BROADCASTINNER  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_BROADCASTINNER</spirit:name>
      <spirit:displayName>Staticcfg_slave_BROADCASTINNER</spirit:displayName>
      <spirit:description>BROADCASTINNER Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_BROADCASTINNER  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_BROADCASTINNER: BROADCASTINNER  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>BROADCASTINNER</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  RESET_slave_CORE_RESET0  -->
    <spirit:busInterface>
      <spirit:name>RESET_slave_CORE_RESET0</spirit:name>
      <spirit:displayName>RESET_slave_CORE_RESET0</spirit:displayName>
      <spirit:description>CPU-0 Core Reset</spirit:description>
      <!--  Need to generate required attributes for Bus i/f RESET_slave_CORE_RESET0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  RESET_slave_CORE_RESET: nCORERESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCORERESET</spirit:name>
            <spirit:vector>
              <!--  vector info: nCORERESET  -->
              <!--  vector details: nCORERESET, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  RESET_slave_CORE_RESET: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  RESET_slave_CORE_RESET1  -->
    <spirit:busInterface>
      <spirit:name>RESET_slave_CORE_RESET1</spirit:name>
      <spirit:displayName>RESET_slave_CORE_RESET1</spirit:displayName>
      <spirit:description>CPU-1 Core Reset</spirit:description>
      <!--  Need to generate required attributes for Bus i/f RESET_slave_CORE_RESET1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  RESET_slave_CORE_RESET: nCORERESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCORERESET</spirit:name>
            <spirit:vector>
              <!--  vector info: nCORERESET  -->
              <!--  vector details: nCORERESET, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  RESET_slave_CORE_RESET: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  RESET_slave_CORE_RESET2  -->
    <spirit:busInterface>
      <spirit:name>RESET_slave_CORE_RESET2</spirit:name>
      <spirit:displayName>RESET_slave_CORE_RESET2</spirit:displayName>
      <spirit:description>CPU-2 Core Reset</spirit:description>
      <!--  Need to generate required attributes for Bus i/f RESET_slave_CORE_RESET2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  RESET_slave_CORE_RESET: nCORERESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCORERESET</spirit:name>
            <spirit:vector>
              <!--  vector info: nCORERESET  -->
              <!--  vector details: nCORERESET, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  RESET_slave_CORE_RESET: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  RESET_slave_CORE_RESET3  -->
    <spirit:busInterface>
      <spirit:name>RESET_slave_CORE_RESET3</spirit:name>
      <spirit:displayName>RESET_slave_CORE_RESET3</spirit:displayName>
      <spirit:description>CPU-3 Core Reset</spirit:description>
      <!--  Need to generate required attributes for Bus i/f RESET_slave_CORE_RESET3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  RESET_slave_CORE_RESET: nCORERESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nCORERESET</spirit:name>
            <spirit:vector>
              <!--  vector info: nCORERESET  -->
              <!--  vector details: nCORERESET, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  RESET_slave_CORE_RESET: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_SEI0  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_SEI0</spirit:name>
      <spirit:displayName>interrupt_slave_SEI0</spirit:displayName>
      <spirit:description>SEI Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_SEI0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_SEI: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_SEI: nSEI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nSEI</spirit:name>
            <spirit:vector>
              <!--  vector info: nSEI  -->
              <!--  vector details: nSEI, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_SEI1  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_SEI1</spirit:name>
      <spirit:displayName>interrupt_slave_SEI1</spirit:displayName>
      <spirit:description>SEI Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_SEI1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_SEI: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_SEI: nSEI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nSEI</spirit:name>
            <spirit:vector>
              <!--  vector info: nSEI  -->
              <!--  vector details: nSEI, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_SEI2  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_SEI2</spirit:name>
      <spirit:displayName>interrupt_slave_SEI2</spirit:displayName>
      <spirit:description>SEI Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_SEI2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_SEI: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_SEI: nSEI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nSEI</spirit:name>
            <spirit:vector>
              <!--  vector info: nSEI  -->
              <!--  vector details: nSEI, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_SEI3  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_SEI3</spirit:name>
      <spirit:displayName>interrupt_slave_SEI3</spirit:displayName>
      <spirit:description>SEI Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_SEI3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_SEI: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_SEI: nSEI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nSEI</spirit:name>
            <spirit:vector>
              <!--  vector info: nSEI  -->
              <!--  vector details: nSEI, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_CLUSTERIDAFF2  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_CLUSTERIDAFF2</spirit:name>
      <spirit:displayName>Staticcfg_slave_CLUSTERIDAFF2</spirit:displayName>
      <spirit:description>CLUSTERID AFF2 Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_CLUSTERIDAFF2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_CLUSTERIDAFF2: CLUSTERIDAFF2  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
            <spirit:vector>
              <!--  vector info: CONFIGURATION  -->
              <!--  vector details: CONFIGURATION, exp_per_cpu < >  -->
              <spirit:left>7</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLUSTERIDAFF2</spirit:name>
            <spirit:vector>
              <!--  vector info: CLUSTERIDAFF2  -->
              <!--  vector details: CLUSTERIDAFF2, exp_per_cpu < >  -->
              <spirit:left>7</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMHNI0_NODID  -->
    
    <!--  Staticcfg_slave_BROADCASTCACHEMAINT  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_BROADCASTCACHEMAINT</spirit:name>
      <spirit:displayName>Staticcfg_slave_BROADCASTCACHEMAINT</spirit:displayName>
      <spirit:description>BROADCAST CACHE MAINT Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_BROADCASTCACHEMAINT  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_BROADCASTCACHEMAINT: BROADCASTCACHEMAINT  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>BROADCASTCACHEMAINT</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMHNF4_NODEID  -->
    
    <!--  Staticcfg_slave_SAMADDRMAP6  -->
    
    <!--  Staticcfg_slave_SCLKEN  -->
    
    <!--  Staticcfg_slave_SAMADDRMAP3  -->
    
    <!--  Staticcfg_slave_SAMHNF6_NODEID  -->
    
    <!--  Staticcfg_slave_RVB_ARADDR2  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_RVB_ARADDR2</spirit:name>
      <spirit:displayName>Staticcfg_slave_RVB_ARADDR2</spirit:displayName>
      <spirit:description>RVBARADDR CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_RVB_ARADDR2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_RVB_ARADDR2: RVBARADDR2  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
            <spirit:vector>
              <!--  vector info: CONFIGURATION  -->
              <!--  vector details: CONFIGURATION, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RVBARADDR2</spirit:name>
            <spirit:vector>
              <!--  vector info: RVBARADDR2  -->
              <!--  vector details: RVBARADDR2, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_IRQ0  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_IRQ0</spirit:name>
      <spirit:displayName>interrupt_slave_IRQ0</spirit:displayName>
      <spirit:description>IRQ Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_IRQ0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_IRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_IRQ: nIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nIRQ  -->
              <!--  vector details: nIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_IRQ1  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_IRQ1</spirit:name>
      <spirit:displayName>interrupt_slave_IRQ1</spirit:displayName>
      <spirit:description>IRQ Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_IRQ1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_IRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_IRQ: nIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nIRQ  -->
              <!--  vector details: nIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_IRQ2  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_IRQ2</spirit:name>
      <spirit:displayName>interrupt_slave_IRQ2</spirit:displayName>
      <spirit:description>IRQ Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_IRQ2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_IRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_IRQ: nIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nIRQ  -->
              <!--  vector details: nIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_IRQ3  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_IRQ3</spirit:name>
      <spirit:displayName>interrupt_slave_IRQ3</spirit:displayName>
      <spirit:description>IRQ Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_IRQ3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_IRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_IRQ: nIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nIRQ  -->
              <!--  vector details: nIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMADDRMAP15  -->
    
    <!--  Staticcfg_slave_SAMHNF_MODE  -->
    
    <!--  RESET_slave_L2  -->
    <spirit:busInterface>
      <spirit:name>RESET_slave_L2</spirit:name>
      <spirit:displayName>RESET_slave_L2</spirit:displayName>
      <spirit:description>L2 Reset for CortexA53</spirit:description>
      <!--  Need to generate required attributes for Bus i/f RESET_slave_L2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="RESET_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  RESET_slave_L2: nL2RESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nL2RESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  RESET_slave_L2: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  interrupt_slave_VSEI0  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_VSEI0</spirit:name>
      <spirit:displayName>interrupt_slave_VSEI0</spirit:displayName>
      <spirit:description>VSEI Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_VSEI0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_VSEI: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_VSEI: nVSEI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVSEI</spirit:name>
            <spirit:vector>
              <!--  vector info: nVSEI  -->
              <!--  vector details: nVSEI, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_VSEI1  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_VSEI1</spirit:name>
      <spirit:displayName>interrupt_slave_VSEI1</spirit:displayName>
      <spirit:description>VSEI Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_VSEI1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_VSEI: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_VSEI: nVSEI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVSEI</spirit:name>
            <spirit:vector>
              <!--  vector info: nVSEI  -->
              <!--  vector details: nVSEI, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_VSEI2  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_VSEI2</spirit:name>
      <spirit:displayName>interrupt_slave_VSEI2</spirit:displayName>
      <spirit:description>VSEI Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_VSEI2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_VSEI: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_VSEI: nVSEI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVSEI</spirit:name>
            <spirit:vector>
              <!--  vector info: nVSEI  -->
              <!--  vector details: nVSEI, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_VSEI3  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_VSEI3</spirit:name>
      <spirit:displayName>interrupt_slave_VSEI3</spirit:displayName>
      <spirit:description>VSEI Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_VSEI3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_VSEI: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_VSEI: nVSEI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nVSEI</spirit:name>
            <spirit:vector>
              <!--  vector info: nVSEI  -->
              <!--  vector details: nVSEI, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMHNF7_NODEID  -->
    
    <!--  Staticcfg_slave_SAMADDRMAP7  -->
    
    <!--  interrupt_master_PMU_IRQ0  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_PMU_IRQ0</spirit:name>
      <spirit:displayName>interrupt_master_PMU_IRQ0</spirit:displayName>
      <spirit:description>PMUIRQ Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_PMU_IRQ0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_PMU_IRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_PMU_IRQ: nPMUIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nPMUIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nPMUIRQ  -->
              <!--  vector details: nPMUIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_master_PMU_IRQ1  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_PMU_IRQ1</spirit:name>
      <spirit:displayName>interrupt_master_PMU_IRQ1</spirit:displayName>
      <spirit:description>PMUIRQ Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_PMU_IRQ1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_PMU_IRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_PMU_IRQ: nPMUIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nPMUIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nPMUIRQ  -->
              <!--  vector details: nPMUIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_master_PMU_IRQ2  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_PMU_IRQ2</spirit:name>
      <spirit:displayName>interrupt_master_PMU_IRQ2</spirit:displayName>
      <spirit:description>PMUIRQ Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_PMU_IRQ2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_PMU_IRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_PMU_IRQ: nPMUIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nPMUIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nPMUIRQ  -->
              <!--  vector details: nPMUIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_master_PMU_IRQ3  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_PMU_IRQ3</spirit:name>
      <spirit:displayName>interrupt_master_PMU_IRQ3</spirit:displayName>
      <spirit:description>PMUIRQ Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_PMU_IRQ3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_PMU_IRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_PMU_IRQ: nPMUIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nPMUIRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: nPMUIRQ  -->
              <!--  vector details: nPMUIRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMHNI1_NODID  -->
    
    <!--  EVENT_slave_EDBGRQ0  -->
    <spirit:busInterface>
      <spirit:name>EVENT_slave_EDBGRQ0</spirit:name>
      <spirit:displayName>EVENT_slave_EDBGRQ0</spirit:displayName>
      <spirit:description>EVENT_Bus_EDBGRQ CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f EVENT_slave_EDBGRQ0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="EVENT" spirit:version="r1p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="EVENT_rtl" spirit:version="r1p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  EVENT_slave_EDBGRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>EVENTCLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  EVENT_slave_EDBGRQ: EDBGRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>EVENT</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>EDBGRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: EDBGRQ  -->
              <!--  vector details: EDBGRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  EVENT_slave_EDBGRQ: nL2RESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>EVENTRESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nL2RESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  EVENT_slave_EDBGRQ1  -->
    <spirit:busInterface>
      <spirit:name>EVENT_slave_EDBGRQ1</spirit:name>
      <spirit:displayName>EVENT_slave_EDBGRQ1</spirit:displayName>
      <spirit:description>EVENT_Bus_EDBGRQ CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f EVENT_slave_EDBGRQ1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="EVENT" spirit:version="r1p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="EVENT_rtl" spirit:version="r1p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  EVENT_slave_EDBGRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>EVENTCLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  EVENT_slave_EDBGRQ: EDBGRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>EVENT</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>EDBGRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: EDBGRQ  -->
              <!--  vector details: EDBGRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  EVENT_slave_EDBGRQ: nL2RESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>EVENTRESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nL2RESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  EVENT_slave_EDBGRQ2  -->
    <spirit:busInterface>
      <spirit:name>EVENT_slave_EDBGRQ2</spirit:name>
      <spirit:displayName>EVENT_slave_EDBGRQ2</spirit:displayName>
      <spirit:description>EVENT_Bus_EDBGRQ CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f EVENT_slave_EDBGRQ2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="EVENT" spirit:version="r1p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="EVENT_rtl" spirit:version="r1p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  EVENT_slave_EDBGRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>EVENTCLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  EVENT_slave_EDBGRQ: EDBGRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>EVENT</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>EDBGRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: EDBGRQ  -->
              <!--  vector details: EDBGRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  EVENT_slave_EDBGRQ: nL2RESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>EVENTRESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nL2RESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  EVENT_slave_EDBGRQ3  -->
    <spirit:busInterface>
      <spirit:name>EVENT_slave_EDBGRQ3</spirit:name>
      <spirit:displayName>EVENT_slave_EDBGRQ3</spirit:displayName>
      <spirit:description>EVENT_Bus_EDBGRQ CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f EVENT_slave_EDBGRQ3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="EVENT" spirit:version="r1p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="EVENT_rtl" spirit:version="r1p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  EVENT_slave_EDBGRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>EVENTCLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  EVENT_slave_EDBGRQ: EDBGRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>EVENT</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>EDBGRQ</spirit:name>
            <spirit:vector>
              <!--  vector info: EDBGRQ  -->
              <!--  vector details: EDBGRQ, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  EVENT_slave_EDBGRQ: nL2RESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>EVENTRESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nL2RESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_DBGROMADDR  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_DBGROMADDR</spirit:name>
      <spirit:displayName>Staticcfg_slave_DBGROMADDR</spirit:displayName>
      <spirit:description>DBGROMADDR Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_DBGROMADDR  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_DBGROMADDR: DBGROMADDR  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
            <spirit:vector>
              <!--  vector info: CONFIGURATION  -->
              <!--  vector details: CONFIGURATION, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>12</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>DBGROMADDR</spirit:name>
            <spirit:vector>
              <!--  vector info: DBGROMADDR  -->
              <!--  vector details: DBGROMADDR, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>12</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  Q-Channel_slave_CPU0  -->
    <spirit:busInterface>
      <spirit:name>Q-Channel_slave_CPU0</spirit:name>
      <spirit:displayName>Q-Channel_slave_CPU0</spirit:displayName>
      <spirit:description>Q channel for CPU-0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Q-Channel_slave_CPU0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Q-Channel_slave_CPU: CPUQREQn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QREQn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQREQn</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQREQn  -->
              <!--  vector details: CPUQREQn, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_CPU: CPUQACCEPTn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACCEPTn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQACCEPTn</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQACCEPTn  -->
              <!--  vector details: CPUQACCEPTn, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_CPU: CPUQDENY  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QDENY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQDENY</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQDENY  -->
              <!--  vector details: CPUQDENY, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_CPU: CPUQACTIVE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACTIVE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQACTIVE</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQACTIVE  -->
              <!--  vector details: CPUQACTIVE, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Q-Channel_slave_CPU1  -->
    <spirit:busInterface>
      <spirit:name>Q-Channel_slave_CPU1</spirit:name>
      <spirit:displayName>Q-Channel_slave_CPU1</spirit:displayName>
      <spirit:description>Q channel for CPU-1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Q-Channel_slave_CPU1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Q-Channel_slave_CPU: CPUQREQn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QREQn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQREQn</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQREQn  -->
              <!--  vector details: CPUQREQn, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_CPU: CPUQACCEPTn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACCEPTn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQACCEPTn</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQACCEPTn  -->
              <!--  vector details: CPUQACCEPTn, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_CPU: CPUQDENY  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QDENY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQDENY</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQDENY  -->
              <!--  vector details: CPUQDENY, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_CPU: CPUQACTIVE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACTIVE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQACTIVE</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQACTIVE  -->
              <!--  vector details: CPUQACTIVE, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Q-Channel_slave_CPU2  -->
    <spirit:busInterface>
      <spirit:name>Q-Channel_slave_CPU2</spirit:name>
      <spirit:displayName>Q-Channel_slave_CPU2</spirit:displayName>
      <spirit:description>Q channel for CPU-2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Q-Channel_slave_CPU2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Q-Channel_slave_CPU: CPUQREQn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QREQn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQREQn</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQREQn  -->
              <!--  vector details: CPUQREQn, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_CPU: CPUQACCEPTn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACCEPTn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQACCEPTn</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQACCEPTn  -->
              <!--  vector details: CPUQACCEPTn, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_CPU: CPUQDENY  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QDENY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQDENY</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQDENY  -->
              <!--  vector details: CPUQDENY, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_CPU: CPUQACTIVE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACTIVE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQACTIVE</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQACTIVE  -->
              <!--  vector details: CPUQACTIVE, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Q-Channel_slave_CPU3  -->
    <spirit:busInterface>
      <spirit:name>Q-Channel_slave_CPU3</spirit:name>
      <spirit:displayName>Q-Channel_slave_CPU3</spirit:displayName>
      <spirit:description>Q channel for CPU-3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Q-Channel_slave_CPU3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Q-Channel_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Q-Channel_slave_CPU: CPUQREQn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QREQn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQREQn</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQREQn  -->
              <!--  vector details: CPUQREQn, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_CPU: CPUQACCEPTn  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACCEPTn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQACCEPTn</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQACCEPTn  -->
              <!--  vector details: CPUQACCEPTn, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_CPU: CPUQDENY  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QDENY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQDENY</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQDENY  -->
              <!--  vector details: CPUQDENY, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  Q-Channel_slave_CPU: CPUQACTIVE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>QACTIVE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CPUQACTIVE</spirit:name>
            <spirit:vector>
              <!--  vector info: CPUQACTIVE  -->
              <!--  vector details: CPUQACTIVE, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SINACT  -->
    
    <!--  Staticcfg_slave_BROADCASTOUTER  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_BROADCASTOUTER</spirit:name>
      <spirit:displayName>Staticcfg_slave_BROADCASTOUTER</spirit:displayName>
      <spirit:description>BROADCASTOUTER Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_BROADCASTOUTER  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_BROADCASTOUTER: BROADCASTOUTER  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>BROADCASTOUTER</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  Staticcfg_slave_RVB_ARADDR0  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_RVB_ARADDR0</spirit:name>
      <spirit:displayName>Staticcfg_slave_RVB_ARADDR0</spirit:displayName>
      <spirit:description>RVBARADDR CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_RVB_ARADDR0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_RVB_ARADDR0: RVBARADDR0  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
            <spirit:vector>
              <!--  vector info: CONFIGURATION  -->
              <!--  vector details: CONFIGURATION, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>RVBARADDR0</spirit:name>
            <spirit:vector>
              <!--  vector info: RVBARADDR0  -->
              <!--  vector details: RVBARADDR0, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMADDRMAP14  -->
    
    <!--  WTimestamp_slave  -->
    <spirit:busInterface>
      <spirit:name>WTimestamp_slave</spirit:name>
      <spirit:displayName>WTimestamp_slave</spirit:displayName>
      <spirit:description>WTimestampInterface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f WTimestamp_slave  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="WTimestamp" spirit:version="r1p0_1"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="CoreSight" spirit:name="WTimestamp_rtl" spirit:version="r1p0_1"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  WTimestamp_slave: nL2RESET  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RESETn</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nL2RESET</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  WTimestamp_slave: TSVALUEB  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>TSVALUE</spirit:name>
            <spirit:vector>
              <!--  vector info: TSVALUE  -->
              <!--  vector details: TSVALUE, exp_per_cpu < >  -->
              <spirit:left>63</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>TSVALUEB</spirit:name>
            <spirit:vector>
              <!--  vector info: TSVALUEB  -->
              <!--  vector details: TSVALUEB, exp_per_cpu < >  -->
              <spirit:left>63</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  WTimestamp_slave: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  Staticcfg_slave_DBGROMADDRV  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_DBGROMADDRV</spirit:name>
      <spirit:displayName>Staticcfg_slave_DBGROMADDRV</spirit:displayName>
      <spirit:description>DBGROMADDRV Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_DBGROMADDRV  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_DBGROMADDRV: DBGROMADDRV  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>DBGROMADDRV</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  interrupt_master_EXTERRIRQ  -->
    <spirit:busInterface>
      <spirit:name>interrupt_master_EXTERRIRQ</spirit:name>
      <spirit:displayName>interrupt_master_EXTERRIRQ</spirit:displayName>
      <spirit:description>EXTERRIRQInterface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_master_EXTERRIRQ  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:master/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_master_EXTERRIRQ: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_master_EXTERRIRQ: nEXTERRIRQ  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nEXTERRIRQ</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMADDRMAP11  -->
    
    <!--  Staticcfg_slave_PERIPHBASE  -->
    <spirit:busInterface>
      <spirit:name>Staticcfg_slave_PERIPHBASE</spirit:name>
      <spirit:displayName>Staticcfg_slave_PERIPHBASE</spirit:displayName>
      <spirit:description>PERIPHBASE Interface</spirit:description>
      <!--  Need to generate required attributes for Bus i/f Staticcfg_slave_PERIPHBASE  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>true</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  Staticcfg_slave_PERIPHBASE: PERIPHBASE  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CONFIGURATION</spirit:name>
            <spirit:vector>
              <!--  vector info: CONFIGURATION  -->
              <!--  vector details: CONFIGURATION, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>18</spirit:right>
            </spirit:vector>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>PERIPHBASE</spirit:name>
            <spirit:vector>
              <!--  vector info: PERIPHBASE  -->
              <!--  vector details: PERIPHBASE, exp_per_cpu < >  -->
              <spirit:left>39</spirit:left>
              <spirit:right>18</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <!--  interrupt_slave_REI0  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_REI0</spirit:name>
      <spirit:displayName>interrupt_slave_REI0</spirit:displayName>
      <spirit:description>REI Interface CPU0</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_REI0  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_REI: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_REI: nREI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nREI</spirit:name>
            <spirit:vector>
              <!--  vector info: nREI  -->
              <!--  vector details: nREI, exp_per_cpu <per_cpu>  -->
              <spirit:left>0</spirit:left>
              <spirit:right>0</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_REI1  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_REI1</spirit:name>
      <spirit:displayName>interrupt_slave_REI1</spirit:displayName>
      <spirit:description>REI Interface CPU1</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_REI1  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_REI: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_REI: nREI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nREI</spirit:name>
            <spirit:vector>
              <!--  vector info: nREI  -->
              <!--  vector details: nREI, exp_per_cpu <per_cpu>  -->
              <spirit:left>1</spirit:left>
              <spirit:right>1</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_REI2  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_REI2</spirit:name>
      <spirit:displayName>interrupt_slave_REI2</spirit:displayName>
      <spirit:description>REI Interface CPU2</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_REI2  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_REI: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_REI: nREI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nREI</spirit:name>
            <spirit:vector>
              <!--  vector info: nREI  -->
              <!--  vector details: nREI, exp_per_cpu <per_cpu>  -->
              <spirit:left>2</spirit:left>
              <spirit:right>2</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  interrupt_slave_REI3  -->
    <spirit:busInterface>
      <spirit:name>interrupt_slave_REI3</spirit:name>
      <spirit:displayName>interrupt_slave_REI3</spirit:displayName>
      <spirit:description>REI Interface CPU3</spirit:description>
      <!--  Need to generate required attributes for Bus i/f interrupt_slave_REI3  -->
      <!--  Attributes in lines busType, abstractionType, slave or master, etc.  -->
      <spirit:busType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt" spirit:version="r0p0_0"/>
      <spirit:abstractionType spirit:vendor="arm.com" spirit:library="generic" spirit:name="interrupt_rtl" spirit:version="r0p0_0"/>
      <spirit:slave/>
      <spirit:connectionRequired>false</spirit:connectionRequired>
      <spirit:portMaps>
        <!--  interrupt_slave_REI: CLKIN  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>CLKIN</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <!--  interrupt_slave_REI: nREI  -->
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>IRQ</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>nREI</spirit:name>
            <spirit:vector>
              <!--  vector info: nREI  -->
              <!--  vector details: nREI, exp_per_cpu <per_cpu>  -->
              <spirit:left>3</spirit:left>
              <spirit:right>3</spirit:right>
            </spirit:vector>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      
    </spirit:busInterface>
    <!--  Staticcfg_slave_SAMHNF3_NODEID  -->
    
  </spirit:busInterfaces>
  <!--  addressSpaces section  -->
  <spirit:addressSpaces>
    <spirit:addressSpace>
      <spirit:name>Main_Bus</spirit:name>
      <spirit:displayName>ACE or CHI-RNF Interface</spirit:displayName>
      <spirit:description>ACE or CHI-RNF Interface Connection</spirit:description>
      <spirit:range>1T</spirit:range>
      <spirit:width>128</spirit:width>
    </spirit:addressSpace>
    <spirit:addressSpace>
      <spirit:name>GIC_CPU1</spirit:name>
      <spirit:displayName>GIC Interface CPU1</spirit:displayName>
      <spirit:description>GIC Interface</spirit:description>
      <spirit:range>256K</spirit:range>
      <spirit:width>32</spirit:width>
      <!--  Local Memory Map for GIC_CPU1  -->
      <spirit:localMemoryMap>
        <spirit:name>GIC_Memory_Map_CPU1</spirit:name>
        <spirit:addressBlock>
          <spirit:name>Virtual_CPU_Interface_CPU1</spirit:name>
          <spirit:displayName>Virtual CPU Interface Memory Map CPU1</spirit:displayName>
          <spirit:description>Virtual Processor interface forwards virtual Interrupts connected to a processor. </spirit:description>
          <spirit:baseAddress>0x20000</spirit:baseAddress>
          <spirit:range>64K</spirit:range>
          <spirit:width>32</spirit:width>
          <!--  Registers for Local/Memory Map for GIC_CPU1 <Virtual_CPU_Interface_CPU1>  -->
          <spirit:register>
            <spirit:name>GICV_ABPR</spirit:name>
            <spirit:description>VM Aliased Binary Point Register</spirit:description>
            <spirit:addressOffset>0x001C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000003</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_ABPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The value of this field controls how the 8-bit interrupt priority field is split into a group priority field used to determine interrupt preemption and a subpriority field.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_ABPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_AEOIR</spirit:name>
            <spirit:description>VM Aliased End of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0024</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICV_AEOIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_AIAR or Non-secure GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_AEOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_AHPPIR</spirit:name>
            <spirit:description>VM Aliased Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0028</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_AHPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt if that interrupt is a Group 1 interrupt. Otherwise the spurious interrupt ID 1023.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_AHPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_AIAR</spirit:name>
            <spirit:description>VM Aliased Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x0020</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICV_AIAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_AIAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_APR0</spirit:name>
            <spirit:description>VM Active Priority Register </spirit:description>
            <spirit:addressOffset>0x00D0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_APR0 -->
            <spirit:field>
              <spirit:name>GICV_APR</spirit:name>
              <spirit:displayName>GICV_APR</spirit:displayName>
              <spirit:description>Active Priorities Register </spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_BPR</spirit:name>
            <spirit:description>VM Binary Point Register</spirit:description>
            <spirit:addressOffset>0x0008</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000002</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_BPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The GICV_BPR bit assignments are the same as assignments for the GICC_BPR the corresponding register in the physical CPU interface.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_BPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_CTLR</spirit:name>
            <spirit:description>VM Control Register</spirit:description>
            <spirit:addressOffset>0x0000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_CTLR -->
            <spirit:field>
              <spirit:name>EnableGrp0</spirit:name>
              <spirit:displayName>EnableGrp0</spirit:displayName>
              <spirit:description>Enables the signaling of Group 0 virtual interrupts by the virtual CPU interface to the virtual machine</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EnableGrp1</spirit:name>
              <spirit:displayName>EnableGrp1</spirit:displayName>
              <spirit:description>Enables the signaling of Group 1 virtual interrupts by the virtual CPU interface to the virtual machine</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>AckCtl</spirit:name>
              <spirit:displayName>AckCtl</spirit:displayName>
              <spirit:description>ARM deprecates use of this bit. ARM strongly recommends that software is written to operate with this bit always set to 0. Controls whether a read of the GICV_IAR when the highest priority pending interrupt is a Group 1 interrupt causes the CPU interface to acknowledge the interrupt</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>FIQEn</spirit:name>
              <spirit:displayName>FIQEn</spirit:displayName>
              <spirit:description>Controls whether interrupts marked as Group 0 are presented as virtual FIQs</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>CBPR</spirit:name>
              <spirit:displayName>CBPR</spirit:displayName>
              <spirit:description>Controls whether the GICV_BPR controls both Group 0 and Group 1 virtual interrupts</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_CTLR_8_5</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EOImode</spirit:name>
              <spirit:displayName>EOImode</spirit:displayName>
              <spirit:description>Controls the behavior associated with the GICV_EOIR GICV_AEOIR and GICV_DIR registers</spirit:description>
              <spirit:bitOffset>9</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_CTLR_31_10</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>22</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_DIR</spirit:name>
            <spirit:description>VM Deactivate Interrupt Register</spirit:description>
            <spirit:addressOffset>0x1000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICV_DIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>CPUID</spirit:name>
              <spirit:displayName>CPUID</spirit:displayName>
              <spirit:description>For an SGI in a multiprocessor implementation this field identifies the processor that requested the interrupt. For all other interrupts this field is RAZ.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_DIR_31_13</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>13</spirit:bitOffset>
              <spirit:bitWidth>19</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_EOIR</spirit:name>
            <spirit:description>VM End Of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0010</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICV_EOIR -->
            <spirit:field>
              <spirit:name>EOIINTID</spirit:name>
              <spirit:displayName>EOIINTID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_EOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_HPPIR</spirit:name>
            <spirit:description>VM Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0018</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_HPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_HPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_IAR</spirit:name>
            <spirit:description>VM Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x000C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICV_IAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_IAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_IIDR</spirit:name>
            <spirit:description>VM CPU Interface Identification Register</spirit:description>
            <spirit:addressOffset>0x00FC</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x0034443B</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_IIDR -->
            <spirit:field>
              <spirit:name>Implementer</spirit:name>
              <spirit:displayName>Implementer</spirit:displayName>
              <spirit:description>Contains the JEP106 code of the company that implements the CPU interface. For an ARM implementation these values are: Bits[11:8] = 0x4 The JEP106 continuation code of the implementer. Bit-7 Always 0. Bits 6:0 = 0x3B The JEP106 identity code of the implementer.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Revision</spirit:name>
              <spirit:displayName>Revision</spirit:displayName>
              <spirit:description>Identifies the revision number for the CPU interface: 0x0 Revision 0.</spirit:description>
              <spirit:bitOffset>12</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Architectureversion</spirit:name>
              <spirit:displayName>Architecture version</spirit:displayName>
              <spirit:description>Identifies the architecture version of the GIC: 0x4 Version 4.</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>ProductID</spirit:name>
              <spirit:displayName>ProductID</spirit:displayName>
              <spirit:description>Identifies the product: 0x003 Cortex-A53 MPCore processor.</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_PMR</spirit:name>
            <spirit:description>VM Priority Mask Register</spirit:description>
            <spirit:addressOffset>0x0004</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_PMR -->
            <spirit:field>
              <spirit:name>RESERVED_GICV_PMR_2_0</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>GICV_PMR is similar to GICC_PMR the corresponding register in the GIC physical CPU interface except that bits [2:0] are reserved. This is because the virtual CPU interface supports fewer priority values than the maximum number of values that the physical CPU interface can support.</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_PMR_31_8</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_RPR</spirit:name>
            <spirit:description>VM Running Priority Register</spirit:description>
            <spirit:addressOffset>0x0014</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000000FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_RPR -->
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The current running priority on the CPU interface.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_RPR_31_8</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
        </spirit:addressBlock>
        <spirit:addressBlock>
          <spirit:name>Virtual_Interface_control_CPU1</spirit:name>
          <spirit:displayName>Virtual Interface control Memory Map CPU1</spirit:displayName>
          <spirit:description>Virtual Interface control registers are management registers.</spirit:description>
          <spirit:baseAddress>0x10000</spirit:baseAddress>
          <spirit:range>64K</spirit:range>
          <spirit:width>32</spirit:width>
          <!--  Registers for Local/Memory Map for GIC_CPU1 <Virtual_Interface_control_CPU1>  -->
          <spirit:register>
            <spirit:name>GICH_APR0</spirit:name>
            <spirit:description>Active Priorities Register</spirit:description>
            <spirit:addressOffset>0x0F0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_APR0 -->
            <spirit:field>
              <spirit:name>GICH_APR</spirit:name>
              <spirit:displayName>GICH_APR</spirit:displayName>
              <spirit:description>Determines whether the corresponding preemption level is active: 0 the preemption level is not active. 1 the preemption level is active.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_EISR0</spirit:name>
            <spirit:description>End of Interrupt Status Registers</spirit:description>
            <spirit:addressOffset>0x020</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_EISR0 -->
            <spirit:field>
              <spirit:name>GICH_EISR0</spirit:name>
              <spirit:displayName>GICH_EISR0</spirit:displayName>
              <spirit:description>For each bit - 0 Corresponding List register does not have an EOI. 1 Corresponding List register has an EOI</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_ELRSR0</spirit:name>
            <spirit:description>Empty List Register Status Registers</spirit:description>
            <spirit:addressOffset>0x030</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x0000000F</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_ELRSR0 -->
            <spirit:field>
              <spirit:name>GICH_ELRSR0</spirit:name>
              <spirit:displayName>GICH_ELRSR0</spirit:displayName>
              <spirit:description>For each bit: 0 The corresponding List register if implemented contains a valid interrupt. Using this List register can result in overwriting a valid interrupt. 1 The corresponding List register does not contain a valid interrupt. The List register is empty and can be used without overwriting a valid interrupt or losing an EOI maintenance interrupt</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_HCR</spirit:name>
            <spirit:description>Hypervisor Control Register</spirit:description>
            <spirit:addressOffset>0x000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_HCR -->
            <spirit:field>
              <spirit:name>En</spirit:name>
              <spirit:displayName>Enable</spirit:displayName>
              <spirit:description>When this field is set to 0 - the virtual CPU interface does not signal any maintenance interrupts. The virtual CPU interface does not signal any virtual interrupts A read of GICV_IAR or GICV_AIAR returns a spurious interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>UIE</spirit:name>
              <spirit:displayName>Underflow Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt when the List registers are empty or hold only one valid entry</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>LRENPIE</spirit:name>
              <spirit:displayName>List Register Entry Not Present Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while the virtual CPU interface does not have a corresponding valid List register entry for an EOI request</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>NPIE</spirit:name>
              <spirit:displayName>No Pending Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while no pending interrupts are present in the List registers</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0EIE</spirit:name>
              <spirit:displayName>VM Enable Group 0 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is enabled</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0DIE</spirit:name>
              <spirit:displayName>VM Disable Group 0 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is disabled</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1EIE</spirit:name>
              <spirit:displayName>VM Enable Group 1 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is enabled</spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1DIE</spirit:name>
              <spirit:displayName>VM Disable Group 1 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is disabled</spirit:description>
              <spirit:bitOffset>7</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_HCR_26_8</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>19</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EOICount</spirit:name>
              <spirit:displayName>EOICount</spirit:displayName>
              <spirit:description>Counts the number of EOIs received that do not have a corresponding entry in the List registers. The virtual CPU interface increments this field automatically when a matching EOI is received. EOIs that do not clear a bit in the Active Priorities register GICH_APR do not cause an increment. Although not possible under correct operation if an EOI occurs when the value of this field is 31 this field wraps to 0. The maintenance interrupt is asserted whenever this field is non-zero and the LRENPIE bit is set to 1.</spirit:description>
              <spirit:bitOffset>27</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR0</spirit:name>
            <spirit:description>List Register 0</spirit:description>
            <spirit:addressOffset>0x100</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR0 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR0_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR1</spirit:name>
            <spirit:description>List Register 1</spirit:description>
            <spirit:addressOffset>0x104</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR1 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR1_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR2</spirit:name>
            <spirit:description>List Register 2</spirit:description>
            <spirit:addressOffset>0x108</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR2 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR2_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR3</spirit:name>
            <spirit:description>List Register 3</spirit:description>
            <spirit:addressOffset>0x10C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR3 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR3_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_MISR</spirit:name>
            <spirit:description>Maintenance Interrupt Status Register</spirit:description>
            <spirit:addressOffset>0x010</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_MISR -->
            <spirit:field>
              <spirit:name>EOI</spirit:name>
              <spirit:displayName>EOI maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever at least one List register is asserting an EOI Interrupt. At least one bit in GICH_EISRn==1</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>U</spirit:name>
              <spirit:displayName>Underflow maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.UIE is set and if none or only one of the List register entries are marked as a valid interrupt that is if the corresponding GICH_LRn.State bits do not equal 0x0.</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>LRENP</spirit:name>
              <spirit:displayName>List Register Entry Not Present maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.LRENPIE==1 and GICH_HCR.EOICount is non-zero.</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>NP</spirit:name>
              <spirit:displayName>No Pending maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.NPIE==1 and no List register is in pending state</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0E</spirit:name>
              <spirit:displayName>Enabled Group 0 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp0EIE is set and GICH_VMCR.VMGrp0En==1</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0D</spirit:name>
              <spirit:displayName>Disabled Group 0 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp0DIE is set and GICH_VMCR.VMGrp0En==0</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1E</spirit:name>
              <spirit:displayName>Enabled Group 1 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp1EIE isset and GICH_VMCR.VMGrp1En==1.</spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1D</spirit:name>
              <spirit:displayName>Disabled Group 1 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp1DIE is set and GICH_VMCR.VMGrp1En==0</spirit:description>
              <spirit:bitOffset>7</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_MISR_31_8</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_VMCR</spirit:name>
            <spirit:description>Virtual Machine Control Register</spirit:description>
            <spirit:addressOffset>0x008</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x004C0000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_VMCR -->
            <spirit:field>
              <spirit:name>VMGrp0En</spirit:name>
              <spirit:displayName>VMGrp0En</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.EnableGrp0.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMGrp1En</spirit:name>
              <spirit:displayName>VMGrp1En</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.EnableGrp1.</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMAckCtl</spirit:name>
              <spirit:displayName>VMAckCtl</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.AckCtl.</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMFIQEn</spirit:name>
              <spirit:displayName>VMFIQEn</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.FIQEn.</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMCBPR</spirit:name>
              <spirit:displayName>VMCBPR</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.CBPR.</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VMCR_8_5</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VEM</spirit:name>
              <spirit:displayName>VEM</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.EOImode.</spirit:description>
              <spirit:bitOffset>9</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VMCR_17_10</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMABP</spirit:name>
              <spirit:displayName>VMABP</spirit:displayName>
              <spirit:description>Alias of GICV_ABPR.Binary point.</spirit:description>
              <spirit:bitOffset>18</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMBP</spirit:name>
              <spirit:displayName>VMBP</spirit:displayName>
              <spirit:description>Alias of GICV_BPR.Binary point. On reset this bit is set to the minimum supported value of GICV_BPR.</spirit:description>
              <spirit:bitOffset>21</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VMCR_26_24</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>24</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMPriMask</spirit:name>
              <spirit:displayName>VMPriMask</spirit:displayName>
              <spirit:description>Alias of GICV_PMR.Priority.</spirit:description>
              <spirit:bitOffset>27</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_VTR</spirit:name>
            <spirit:description>VGIC Type Register</spirit:description>
            <spirit:addressOffset>0x004</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x90000003</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_VTR -->
            <spirit:field>
              <spirit:name>ListRegs</spirit:name>
              <spirit:displayName>ListRegs</spirit:displayName>
              <spirit:description>Indicates the number of implemented List Registers minus one: 0x3 Four List Registers.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>6</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VTR_25_6</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved RAZ</spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>20</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PREbits</spirit:name>
              <spirit:displayName>PREbits</spirit:displayName>
              <spirit:description>Indicates the number of preemption bits implemented minus one: 0x4 Five bits of preemption and 32 preemption levels.</spirit:description>
              <spirit:bitOffset>26</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PRIbits</spirit:name>
              <spirit:displayName>PRIbits</spirit:displayName>
              <spirit:description>Indicates the number of priority bits implemented minus one: 0x4 Five bits of priority and 32 priority levels.</spirit:description>
              <spirit:bitOffset>29</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
        </spirit:addressBlock>
        <spirit:addressBlock>
          <spirit:name>Processor_Interface_CPU1</spirit:name>
          <spirit:displayName>Processor Interface Memory Map CPU1</spirit:displayName>
          <spirit:description>Enabling signaling by processor Interface. Acknowledging and indicating a completion of an interrupt.</spirit:description>
          <spirit:baseAddress>0x00000</spirit:baseAddress>
          <spirit:range>64K</spirit:range>
          <spirit:width>32</spirit:width>
          <!--  Registers for Local/Memory Map for GIC_CPU1 <Processor_Interface_CPU1>  -->
          <spirit:register>
            <spirit:name>GICC_ABPR</spirit:name>
            <spirit:description>Aliased Binary Point Register</spirit:description>
            <spirit:addressOffset>0x001C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000003</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_ABPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The value of this field controls how the 8-bit interrupt priority field is split into a group priority field used to determine interrupt preemption and a subpriority field.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_ABPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_AEOIR</spirit:name>
            <spirit:description>Aliased End of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0024</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICC_AEOIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_AIAR or Non-secure GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_AEOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_AHPPIR</spirit:name>
            <spirit:description>Aliased Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0028</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_AHPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt if that interrupt is a Group 1 interrupt. Otherwise the spurious interrupt ID 1023.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_AHPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_AIAR</spirit:name>
            <spirit:description>Aliased Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x0020</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICC_AIAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_AIAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_APR0</spirit:name>
            <spirit:description>Active Priority Register</spirit:description>
            <spirit:addressOffset>0x00D0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_APR0 -->
            <spirit:field>
              <spirit:name>GICC_APR</spirit:name>
              <spirit:displayName>GICC_APR</spirit:displayName>
              <spirit:description>Active Priorities Register </spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_BPR</spirit:name>
            <spirit:description>Binary Point Register</spirit:description>
            <spirit:addressOffset>0x0008</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000002</spirit:value>
              <spirit:mask>0x00000003</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_BPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The value of this field controls how the 8-bit interrupt priority field is split into a group priority field used to determine interrupt preemption and a subpriority field.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_BPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_CTLR</spirit:name>
            <spirit:description>CPU Interface Control Register</spirit:description>
            <spirit:addressOffset>0x0000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_CTLR -->
            <spirit:field>
              <spirit:name>Enable</spirit:name>
              <spirit:displayName>Enable</spirit:displayName>
              <spirit:description>Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_CTLR_4_1</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>FIQBypDisGrp1</spirit:name>
              <spirit:displayName>FIQBypDisGrp1</spirit:displayName>
              <spirit:description> </spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>IRQBypDisGrp1</spirit:name>
              <spirit:displayName>IRQBypDisGrp1</spirit:displayName>
              <spirit:description> </spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_CTLR_8_7</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>7</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EOImodeNS</spirit:name>
              <spirit:displayName>EOImodeNS</spirit:displayName>
              <spirit:description>Controls the behavior of non-secure accesses to the GICC_EOIR GICC_AEOIR and GICC_DIR registers</spirit:description>
              <spirit:bitOffset>9</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_CTLR_31_10</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>22</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_DIR</spirit:name>
            <spirit:description>Deactivate Interrupt Register</spirit:description>
            <spirit:addressOffset>0x1000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICC_DIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_DIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_EOIR</spirit:name>
            <spirit:description>End Of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0010</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICC_EOIR -->
            <spirit:field>
              <spirit:name>EOIINTID</spirit:name>
              <spirit:displayName>EOIINTID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_EOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_HPPIR</spirit:name>
            <spirit:description>Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0018</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_HPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_HPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_IAR</spirit:name>
            <spirit:description>Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x000C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICC_IAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_IAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_IIDR</spirit:name>
            <spirit:description>CPU Interface Identification Register</spirit:description>
            <spirit:addressOffset>0x00FC</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x0034443B</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_IIDR -->
            <spirit:field>
              <spirit:name>Implementer</spirit:name>
              <spirit:displayName>Implementer</spirit:displayName>
              <spirit:description>Contains the JEP106 code of the company that implements the CPU interface. For an ARM implementation these values are: Bits[11:8] = 0x4 The JEP106 continuation code of the implementer. Bit-7 Always 0. Bits 6:0 = 0x3B The JEP106 identity code of the implementer.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Revision</spirit:name>
              <spirit:displayName>Revision</spirit:displayName>
              <spirit:description>Identifies the revision number for the CPU interface: 0x0 Revision 0.</spirit:description>
              <spirit:bitOffset>12</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Architectureversion</spirit:name>
              <spirit:displayName>Architecture version</spirit:displayName>
              <spirit:description>Identifies the architecture version of the GIC: 0x4 Version 4.</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>ProductID</spirit:name>
              <spirit:displayName>ProductID</spirit:displayName>
              <spirit:description>Identifies the product: 0x003 Cortex-A53 MPCore processor.</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_NSAPR0</spirit:name>
            <spirit:description>Non-secure Active Priority Register</spirit:description>
            <spirit:addressOffset>0x00E0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_NSAPR0 -->
            <spirit:field>
              <spirit:name>GICC_NSAPR</spirit:name>
              <spirit:displayName>GICC_NSAPR</spirit:displayName>
              <spirit:description>Non-secure Active Priorities Register </spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_PMR</spirit:name>
            <spirit:description>Interrupt Priority Mask Register</spirit:description>
            <spirit:addressOffset>0x0004</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_PMR -->
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority mask level for the CPU interface. If the priority of an interrupt is higher than the value indicated by this field the interface signals the interrupt to the processor. If the GIC supports fewer than 256 priority levels then some bits are RAZ/WI as follows: 128 supported levels Bit [0] = 0. 64 supported levels Bit [1:0] = 0b00. 32 supported levels Bit [2:0] = 0b000. 16 supported levels Bit [3:0] = 0b0000.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_PMR_31_8</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_RPR</spirit:name>
            <spirit:description>Running Priority Register</spirit:description>
            <spirit:addressOffset>0x0014</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000000FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_RPR -->
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The current running priority on the CPU interface.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_RPR_31_8</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
        </spirit:addressBlock>
      </spirit:localMemoryMap>
      
    </spirit:addressSpace>
    <spirit:addressSpace>
      <spirit:name>GIC_CPU3</spirit:name>
      <spirit:displayName>GIC Interface CPU3</spirit:displayName>
      <spirit:description>GIC Interface</spirit:description>
      <spirit:range>256K</spirit:range>
      <spirit:width>32</spirit:width>
      <!--  Local Memory Map for GIC_CPU3  -->
      <spirit:localMemoryMap>
        <spirit:name>GIC_Memory_Map_CPU3</spirit:name>
        <spirit:addressBlock>
          <spirit:name>Virtual_CPU_Interface_CPU3</spirit:name>
          <spirit:displayName>Virtual CPU Interface Memory Map CPU3</spirit:displayName>
          <spirit:description>Virtual Processor interface forwards virtual Interrupts connected to a processor. </spirit:description>
          <spirit:baseAddress>0x20000</spirit:baseAddress>
          <spirit:range>64K</spirit:range>
          <spirit:width>32</spirit:width>
          <!--  Registers for Local/Memory Map for GIC_CPU3 <Virtual_CPU_Interface_CPU3>  -->
          <spirit:register>
            <spirit:name>GICV_ABPR</spirit:name>
            <spirit:description>VM Aliased Binary Point Register</spirit:description>
            <spirit:addressOffset>0x001C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000003</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_ABPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The value of this field controls how the 8-bit interrupt priority field is split into a group priority field used to determine interrupt preemption and a subpriority field.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_ABPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_AEOIR</spirit:name>
            <spirit:description>VM Aliased End of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0024</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICV_AEOIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_AIAR or Non-secure GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_AEOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_AHPPIR</spirit:name>
            <spirit:description>VM Aliased Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0028</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_AHPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt if that interrupt is a Group 1 interrupt. Otherwise the spurious interrupt ID 1023.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_AHPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_AIAR</spirit:name>
            <spirit:description>VM Aliased Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x0020</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICV_AIAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_AIAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_APR0</spirit:name>
            <spirit:description>VM Active Priority Register </spirit:description>
            <spirit:addressOffset>0x00D0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_APR0 -->
            <spirit:field>
              <spirit:name>GICV_APR</spirit:name>
              <spirit:displayName>GICV_APR</spirit:displayName>
              <spirit:description>Active Priorities Register </spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_BPR</spirit:name>
            <spirit:description>VM Binary Point Register</spirit:description>
            <spirit:addressOffset>0x0008</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000002</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_BPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The GICV_BPR bit assignments are the same as assignments for the GICC_BPR the corresponding register in the physical CPU interface.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_BPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_CTLR</spirit:name>
            <spirit:description>VM Control Register</spirit:description>
            <spirit:addressOffset>0x0000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_CTLR -->
            <spirit:field>
              <spirit:name>EnableGrp0</spirit:name>
              <spirit:displayName>EnableGrp0</spirit:displayName>
              <spirit:description>Enables the signaling of Group 0 virtual interrupts by the virtual CPU interface to the virtual machine</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EnableGrp1</spirit:name>
              <spirit:displayName>EnableGrp1</spirit:displayName>
              <spirit:description>Enables the signaling of Group 1 virtual interrupts by the virtual CPU interface to the virtual machine</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>AckCtl</spirit:name>
              <spirit:displayName>AckCtl</spirit:displayName>
              <spirit:description>ARM deprecates use of this bit. ARM strongly recommends that software is written to operate with this bit always set to 0. Controls whether a read of the GICV_IAR when the highest priority pending interrupt is a Group 1 interrupt causes the CPU interface to acknowledge the interrupt</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>FIQEn</spirit:name>
              <spirit:displayName>FIQEn</spirit:displayName>
              <spirit:description>Controls whether interrupts marked as Group 0 are presented as virtual FIQs</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>CBPR</spirit:name>
              <spirit:displayName>CBPR</spirit:displayName>
              <spirit:description>Controls whether the GICV_BPR controls both Group 0 and Group 1 virtual interrupts</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_CTLR_8_5</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EOImode</spirit:name>
              <spirit:displayName>EOImode</spirit:displayName>
              <spirit:description>Controls the behavior associated with the GICV_EOIR GICV_AEOIR and GICV_DIR registers</spirit:description>
              <spirit:bitOffset>9</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_CTLR_31_10</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>22</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_DIR</spirit:name>
            <spirit:description>VM Deactivate Interrupt Register</spirit:description>
            <spirit:addressOffset>0x1000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICV_DIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>CPUID</spirit:name>
              <spirit:displayName>CPUID</spirit:displayName>
              <spirit:description>For an SGI in a multiprocessor implementation this field identifies the processor that requested the interrupt. For all other interrupts this field is RAZ.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_DIR_31_13</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>13</spirit:bitOffset>
              <spirit:bitWidth>19</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_EOIR</spirit:name>
            <spirit:description>VM End Of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0010</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICV_EOIR -->
            <spirit:field>
              <spirit:name>EOIINTID</spirit:name>
              <spirit:displayName>EOIINTID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_EOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_HPPIR</spirit:name>
            <spirit:description>VM Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0018</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_HPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_HPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_IAR</spirit:name>
            <spirit:description>VM Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x000C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICV_IAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_IAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_IIDR</spirit:name>
            <spirit:description>VM CPU Interface Identification Register</spirit:description>
            <spirit:addressOffset>0x00FC</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x0034443B</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_IIDR -->
            <spirit:field>
              <spirit:name>Implementer</spirit:name>
              <spirit:displayName>Implementer</spirit:displayName>
              <spirit:description>Contains the JEP106 code of the company that implements the CPU interface. For an ARM implementation these values are: Bits[11:8] = 0x4 The JEP106 continuation code of the implementer. Bit-7 Always 0. Bits 6:0 = 0x3B The JEP106 identity code of the implementer.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Revision</spirit:name>
              <spirit:displayName>Revision</spirit:displayName>
              <spirit:description>Identifies the revision number for the CPU interface: 0x0 Revision 0.</spirit:description>
              <spirit:bitOffset>12</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Architectureversion</spirit:name>
              <spirit:displayName>Architecture version</spirit:displayName>
              <spirit:description>Identifies the architecture version of the GIC: 0x4 Version 4.</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>ProductID</spirit:name>
              <spirit:displayName>ProductID</spirit:displayName>
              <spirit:description>Identifies the product: 0x003 Cortex-A53 MPCore processor.</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_PMR</spirit:name>
            <spirit:description>VM Priority Mask Register</spirit:description>
            <spirit:addressOffset>0x0004</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_PMR -->
            <spirit:field>
              <spirit:name>RESERVED_GICV_PMR_2_0</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>GICV_PMR is similar to GICC_PMR the corresponding register in the GIC physical CPU interface except that bits [2:0] are reserved. This is because the virtual CPU interface supports fewer priority values than the maximum number of values that the physical CPU interface can support.</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_PMR_31_8</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_RPR</spirit:name>
            <spirit:description>VM Running Priority Register</spirit:description>
            <spirit:addressOffset>0x0014</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000000FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_RPR -->
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The current running priority on the CPU interface.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_RPR_31_8</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
        </spirit:addressBlock>
        <spirit:addressBlock>
          <spirit:name>Virtual_Interface_control_CPU3</spirit:name>
          <spirit:displayName>Virtual Interface control Memory Map CPU3</spirit:displayName>
          <spirit:description>Virtual Interface control registers are management registers.</spirit:description>
          <spirit:baseAddress>0x10000</spirit:baseAddress>
          <spirit:range>64K</spirit:range>
          <spirit:width>32</spirit:width>
          <!--  Registers for Local/Memory Map for GIC_CPU3 <Virtual_Interface_control_CPU3>  -->
          <spirit:register>
            <spirit:name>GICH_APR0</spirit:name>
            <spirit:description>Active Priorities Register</spirit:description>
            <spirit:addressOffset>0x0F0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_APR0 -->
            <spirit:field>
              <spirit:name>GICH_APR</spirit:name>
              <spirit:displayName>GICH_APR</spirit:displayName>
              <spirit:description>Determines whether the corresponding preemption level is active: 0 the preemption level is not active. 1 the preemption level is active.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_EISR0</spirit:name>
            <spirit:description>End of Interrupt Status Registers</spirit:description>
            <spirit:addressOffset>0x020</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_EISR0 -->
            <spirit:field>
              <spirit:name>GICH_EISR0</spirit:name>
              <spirit:displayName>GICH_EISR0</spirit:displayName>
              <spirit:description>For each bit - 0 Corresponding List register does not have an EOI. 1 Corresponding List register has an EOI</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_ELRSR0</spirit:name>
            <spirit:description>Empty List Register Status Registers</spirit:description>
            <spirit:addressOffset>0x030</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x0000000F</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_ELRSR0 -->
            <spirit:field>
              <spirit:name>GICH_ELRSR0</spirit:name>
              <spirit:displayName>GICH_ELRSR0</spirit:displayName>
              <spirit:description>For each bit: 0 The corresponding List register if implemented contains a valid interrupt. Using this List register can result in overwriting a valid interrupt. 1 The corresponding List register does not contain a valid interrupt. The List register is empty and can be used without overwriting a valid interrupt or losing an EOI maintenance interrupt</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_HCR</spirit:name>
            <spirit:description>Hypervisor Control Register</spirit:description>
            <spirit:addressOffset>0x000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_HCR -->
            <spirit:field>
              <spirit:name>En</spirit:name>
              <spirit:displayName>Enable</spirit:displayName>
              <spirit:description>When this field is set to 0 - the virtual CPU interface does not signal any maintenance interrupts. The virtual CPU interface does not signal any virtual interrupts A read of GICV_IAR or GICV_AIAR returns a spurious interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>UIE</spirit:name>
              <spirit:displayName>Underflow Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt when the List registers are empty or hold only one valid entry</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>LRENPIE</spirit:name>
              <spirit:displayName>List Register Entry Not Present Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while the virtual CPU interface does not have a corresponding valid List register entry for an EOI request</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>NPIE</spirit:name>
              <spirit:displayName>No Pending Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while no pending interrupts are present in the List registers</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0EIE</spirit:name>
              <spirit:displayName>VM Enable Group 0 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is enabled</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0DIE</spirit:name>
              <spirit:displayName>VM Disable Group 0 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is disabled</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1EIE</spirit:name>
              <spirit:displayName>VM Enable Group 1 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is enabled</spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1DIE</spirit:name>
              <spirit:displayName>VM Disable Group 1 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is disabled</spirit:description>
              <spirit:bitOffset>7</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_HCR_26_8</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>19</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EOICount</spirit:name>
              <spirit:displayName>EOICount</spirit:displayName>
              <spirit:description>Counts the number of EOIs received that do not have a corresponding entry in the List registers. The virtual CPU interface increments this field automatically when a matching EOI is received. EOIs that do not clear a bit in the Active Priorities register GICH_APR do not cause an increment. Although not possible under correct operation if an EOI occurs when the value of this field is 31 this field wraps to 0. The maintenance interrupt is asserted whenever this field is non-zero and the LRENPIE bit is set to 1.</spirit:description>
              <spirit:bitOffset>27</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR0</spirit:name>
            <spirit:description>List Register 0</spirit:description>
            <spirit:addressOffset>0x100</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR0 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR0_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR1</spirit:name>
            <spirit:description>List Register 1</spirit:description>
            <spirit:addressOffset>0x104</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR1 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR1_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR2</spirit:name>
            <spirit:description>List Register 2</spirit:description>
            <spirit:addressOffset>0x108</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR2 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR2_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR3</spirit:name>
            <spirit:description>List Register 3</spirit:description>
            <spirit:addressOffset>0x10C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR3 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR3_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_MISR</spirit:name>
            <spirit:description>Maintenance Interrupt Status Register</spirit:description>
            <spirit:addressOffset>0x010</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_MISR -->
            <spirit:field>
              <spirit:name>EOI</spirit:name>
              <spirit:displayName>EOI maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever at least one List register is asserting an EOI Interrupt. At least one bit in GICH_EISRn==1</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>U</spirit:name>
              <spirit:displayName>Underflow maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.UIE is set and if none or only one of the List register entries are marked as a valid interrupt that is if the corresponding GICH_LRn.State bits do not equal 0x0.</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>LRENP</spirit:name>
              <spirit:displayName>List Register Entry Not Present maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.LRENPIE==1 and GICH_HCR.EOICount is non-zero.</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>NP</spirit:name>
              <spirit:displayName>No Pending maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.NPIE==1 and no List register is in pending state</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0E</spirit:name>
              <spirit:displayName>Enabled Group 0 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp0EIE is set and GICH_VMCR.VMGrp0En==1</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0D</spirit:name>
              <spirit:displayName>Disabled Group 0 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp0DIE is set and GICH_VMCR.VMGrp0En==0</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1E</spirit:name>
              <spirit:displayName>Enabled Group 1 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp1EIE isset and GICH_VMCR.VMGrp1En==1.</spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1D</spirit:name>
              <spirit:displayName>Disabled Group 1 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp1DIE is set and GICH_VMCR.VMGrp1En==0</spirit:description>
              <spirit:bitOffset>7</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_MISR_31_8</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_VMCR</spirit:name>
            <spirit:description>Virtual Machine Control Register</spirit:description>
            <spirit:addressOffset>0x008</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x004C0000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_VMCR -->
            <spirit:field>
              <spirit:name>VMGrp0En</spirit:name>
              <spirit:displayName>VMGrp0En</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.EnableGrp0.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMGrp1En</spirit:name>
              <spirit:displayName>VMGrp1En</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.EnableGrp1.</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMAckCtl</spirit:name>
              <spirit:displayName>VMAckCtl</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.AckCtl.</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMFIQEn</spirit:name>
              <spirit:displayName>VMFIQEn</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.FIQEn.</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMCBPR</spirit:name>
              <spirit:displayName>VMCBPR</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.CBPR.</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VMCR_8_5</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VEM</spirit:name>
              <spirit:displayName>VEM</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.EOImode.</spirit:description>
              <spirit:bitOffset>9</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VMCR_17_10</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMABP</spirit:name>
              <spirit:displayName>VMABP</spirit:displayName>
              <spirit:description>Alias of GICV_ABPR.Binary point.</spirit:description>
              <spirit:bitOffset>18</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMBP</spirit:name>
              <spirit:displayName>VMBP</spirit:displayName>
              <spirit:description>Alias of GICV_BPR.Binary point. On reset this bit is set to the minimum supported value of GICV_BPR.</spirit:description>
              <spirit:bitOffset>21</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VMCR_26_24</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>24</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMPriMask</spirit:name>
              <spirit:displayName>VMPriMask</spirit:displayName>
              <spirit:description>Alias of GICV_PMR.Priority.</spirit:description>
              <spirit:bitOffset>27</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_VTR</spirit:name>
            <spirit:description>VGIC Type Register</spirit:description>
            <spirit:addressOffset>0x004</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x90000003</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_VTR -->
            <spirit:field>
              <spirit:name>ListRegs</spirit:name>
              <spirit:displayName>ListRegs</spirit:displayName>
              <spirit:description>Indicates the number of implemented List Registers minus one: 0x3 Four List Registers.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>6</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VTR_25_6</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved RAZ</spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>20</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PREbits</spirit:name>
              <spirit:displayName>PREbits</spirit:displayName>
              <spirit:description>Indicates the number of preemption bits implemented minus one: 0x4 Five bits of preemption and 32 preemption levels.</spirit:description>
              <spirit:bitOffset>26</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PRIbits</spirit:name>
              <spirit:displayName>PRIbits</spirit:displayName>
              <spirit:description>Indicates the number of priority bits implemented minus one: 0x4 Five bits of priority and 32 priority levels.</spirit:description>
              <spirit:bitOffset>29</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
        </spirit:addressBlock>
        <spirit:addressBlock>
          <spirit:name>Processor_Interface_CPU3</spirit:name>
          <spirit:displayName>Processor Interface Memory Map CPU3</spirit:displayName>
          <spirit:description>Enabling signaling by processor Interface. Acknowledging and indicating a completion of an interrupt.</spirit:description>
          <spirit:baseAddress>0x00000</spirit:baseAddress>
          <spirit:range>64K</spirit:range>
          <spirit:width>32</spirit:width>
          <!--  Registers for Local/Memory Map for GIC_CPU3 <Processor_Interface_CPU3>  -->
          <spirit:register>
            <spirit:name>GICC_ABPR</spirit:name>
            <spirit:description>Aliased Binary Point Register</spirit:description>
            <spirit:addressOffset>0x001C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000003</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_ABPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The value of this field controls how the 8-bit interrupt priority field is split into a group priority field used to determine interrupt preemption and a subpriority field.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_ABPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_AEOIR</spirit:name>
            <spirit:description>Aliased End of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0024</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICC_AEOIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_AIAR or Non-secure GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_AEOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_AHPPIR</spirit:name>
            <spirit:description>Aliased Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0028</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_AHPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt if that interrupt is a Group 1 interrupt. Otherwise the spurious interrupt ID 1023.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_AHPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_AIAR</spirit:name>
            <spirit:description>Aliased Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x0020</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICC_AIAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_AIAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_APR0</spirit:name>
            <spirit:description>Active Priority Register</spirit:description>
            <spirit:addressOffset>0x00D0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_APR0 -->
            <spirit:field>
              <spirit:name>GICC_APR</spirit:name>
              <spirit:displayName>GICC_APR</spirit:displayName>
              <spirit:description>Active Priorities Register </spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_BPR</spirit:name>
            <spirit:description>Binary Point Register</spirit:description>
            <spirit:addressOffset>0x0008</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000002</spirit:value>
              <spirit:mask>0x00000003</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_BPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The value of this field controls how the 8-bit interrupt priority field is split into a group priority field used to determine interrupt preemption and a subpriority field.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_BPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_CTLR</spirit:name>
            <spirit:description>CPU Interface Control Register</spirit:description>
            <spirit:addressOffset>0x0000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_CTLR -->
            <spirit:field>
              <spirit:name>Enable</spirit:name>
              <spirit:displayName>Enable</spirit:displayName>
              <spirit:description>Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_CTLR_4_1</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>FIQBypDisGrp1</spirit:name>
              <spirit:displayName>FIQBypDisGrp1</spirit:displayName>
              <spirit:description> </spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>IRQBypDisGrp1</spirit:name>
              <spirit:displayName>IRQBypDisGrp1</spirit:displayName>
              <spirit:description> </spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_CTLR_8_7</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>7</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EOImodeNS</spirit:name>
              <spirit:displayName>EOImodeNS</spirit:displayName>
              <spirit:description>Controls the behavior of non-secure accesses to the GICC_EOIR GICC_AEOIR and GICC_DIR registers</spirit:description>
              <spirit:bitOffset>9</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_CTLR_31_10</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>22</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_DIR</spirit:name>
            <spirit:description>Deactivate Interrupt Register</spirit:description>
            <spirit:addressOffset>0x1000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICC_DIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_DIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_EOIR</spirit:name>
            <spirit:description>End Of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0010</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICC_EOIR -->
            <spirit:field>
              <spirit:name>EOIINTID</spirit:name>
              <spirit:displayName>EOIINTID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_EOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_HPPIR</spirit:name>
            <spirit:description>Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0018</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_HPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_HPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_IAR</spirit:name>
            <spirit:description>Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x000C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICC_IAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_IAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_IIDR</spirit:name>
            <spirit:description>CPU Interface Identification Register</spirit:description>
            <spirit:addressOffset>0x00FC</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x0034443B</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_IIDR -->
            <spirit:field>
              <spirit:name>Implementer</spirit:name>
              <spirit:displayName>Implementer</spirit:displayName>
              <spirit:description>Contains the JEP106 code of the company that implements the CPU interface. For an ARM implementation these values are: Bits[11:8] = 0x4 The JEP106 continuation code of the implementer. Bit-7 Always 0. Bits 6:0 = 0x3B The JEP106 identity code of the implementer.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Revision</spirit:name>
              <spirit:displayName>Revision</spirit:displayName>
              <spirit:description>Identifies the revision number for the CPU interface: 0x0 Revision 0.</spirit:description>
              <spirit:bitOffset>12</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Architectureversion</spirit:name>
              <spirit:displayName>Architecture version</spirit:displayName>
              <spirit:description>Identifies the architecture version of the GIC: 0x4 Version 4.</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>ProductID</spirit:name>
              <spirit:displayName>ProductID</spirit:displayName>
              <spirit:description>Identifies the product: 0x003 Cortex-A53 MPCore processor.</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_NSAPR0</spirit:name>
            <spirit:description>Non-secure Active Priority Register</spirit:description>
            <spirit:addressOffset>0x00E0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_NSAPR0 -->
            <spirit:field>
              <spirit:name>GICC_NSAPR</spirit:name>
              <spirit:displayName>GICC_NSAPR</spirit:displayName>
              <spirit:description>Non-secure Active Priorities Register </spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_PMR</spirit:name>
            <spirit:description>Interrupt Priority Mask Register</spirit:description>
            <spirit:addressOffset>0x0004</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_PMR -->
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority mask level for the CPU interface. If the priority of an interrupt is higher than the value indicated by this field the interface signals the interrupt to the processor. If the GIC supports fewer than 256 priority levels then some bits are RAZ/WI as follows: 128 supported levels Bit [0] = 0. 64 supported levels Bit [1:0] = 0b00. 32 supported levels Bit [2:0] = 0b000. 16 supported levels Bit [3:0] = 0b0000.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_PMR_31_8</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_RPR</spirit:name>
            <spirit:description>Running Priority Register</spirit:description>
            <spirit:addressOffset>0x0014</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000000FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_RPR -->
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The current running priority on the CPU interface.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_RPR_31_8</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
        </spirit:addressBlock>
      </spirit:localMemoryMap>
      
    </spirit:addressSpace>
    <spirit:addressSpace>
      <spirit:name>GIC_CPU0</spirit:name>
      <spirit:displayName>GIC Interface CPU0</spirit:displayName>
      <spirit:description>GIC Interface</spirit:description>
      <spirit:range>256K</spirit:range>
      <spirit:width>32</spirit:width>
      <!--  Local Memory Map for GIC_CPU0  -->
      <spirit:localMemoryMap>
        <spirit:name>GIC_Memory_Map_CPU0</spirit:name>
        <spirit:addressBlock>
          <spirit:name>Virtual_CPU_Interface_CPU0</spirit:name>
          <spirit:displayName>Virtual CPU Interface Memory Map CPU0</spirit:displayName>
          <spirit:description>Virtual Processor interface forwards virtual Interrupts connected to a processor. </spirit:description>
          <spirit:baseAddress>0x20000</spirit:baseAddress>
          <spirit:range>64K</spirit:range>
          <spirit:width>32</spirit:width>
          <!--  Registers for Local/Memory Map for GIC_CPU0 <Virtual_CPU_Interface_CPU0>  -->
          <spirit:register>
            <spirit:name>GICV_ABPR</spirit:name>
            <spirit:description>VM Aliased Binary Point Register</spirit:description>
            <spirit:addressOffset>0x001C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000003</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_ABPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The value of this field controls how the 8-bit interrupt priority field is split into a group priority field used to determine interrupt preemption and a subpriority field.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_ABPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_AEOIR</spirit:name>
            <spirit:description>VM Aliased End of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0024</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICV_AEOIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_AIAR or Non-secure GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_AEOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_AHPPIR</spirit:name>
            <spirit:description>VM Aliased Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0028</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_AHPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt if that interrupt is a Group 1 interrupt. Otherwise the spurious interrupt ID 1023.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_AHPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_AIAR</spirit:name>
            <spirit:description>VM Aliased Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x0020</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICV_AIAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_AIAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_APR0</spirit:name>
            <spirit:description>VM Active Priority Register </spirit:description>
            <spirit:addressOffset>0x00D0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_APR0 -->
            <spirit:field>
              <spirit:name>GICV_APR</spirit:name>
              <spirit:displayName>GICV_APR</spirit:displayName>
              <spirit:description>Active Priorities Register </spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_BPR</spirit:name>
            <spirit:description>VM Binary Point Register</spirit:description>
            <spirit:addressOffset>0x0008</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000002</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_BPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The GICV_BPR bit assignments are the same as assignments for the GICC_BPR the corresponding register in the physical CPU interface.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_BPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_CTLR</spirit:name>
            <spirit:description>VM Control Register</spirit:description>
            <spirit:addressOffset>0x0000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_CTLR -->
            <spirit:field>
              <spirit:name>EnableGrp0</spirit:name>
              <spirit:displayName>EnableGrp0</spirit:displayName>
              <spirit:description>Enables the signaling of Group 0 virtual interrupts by the virtual CPU interface to the virtual machine</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EnableGrp1</spirit:name>
              <spirit:displayName>EnableGrp1</spirit:displayName>
              <spirit:description>Enables the signaling of Group 1 virtual interrupts by the virtual CPU interface to the virtual machine</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>AckCtl</spirit:name>
              <spirit:displayName>AckCtl</spirit:displayName>
              <spirit:description>ARM deprecates use of this bit. ARM strongly recommends that software is written to operate with this bit always set to 0. Controls whether a read of the GICV_IAR when the highest priority pending interrupt is a Group 1 interrupt causes the CPU interface to acknowledge the interrupt</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>FIQEn</spirit:name>
              <spirit:displayName>FIQEn</spirit:displayName>
              <spirit:description>Controls whether interrupts marked as Group 0 are presented as virtual FIQs</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>CBPR</spirit:name>
              <spirit:displayName>CBPR</spirit:displayName>
              <spirit:description>Controls whether the GICV_BPR controls both Group 0 and Group 1 virtual interrupts</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_CTLR_8_5</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EOImode</spirit:name>
              <spirit:displayName>EOImode</spirit:displayName>
              <spirit:description>Controls the behavior associated with the GICV_EOIR GICV_AEOIR and GICV_DIR registers</spirit:description>
              <spirit:bitOffset>9</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_CTLR_31_10</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>22</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_DIR</spirit:name>
            <spirit:description>VM Deactivate Interrupt Register</spirit:description>
            <spirit:addressOffset>0x1000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICV_DIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>CPUID</spirit:name>
              <spirit:displayName>CPUID</spirit:displayName>
              <spirit:description>For an SGI in a multiprocessor implementation this field identifies the processor that requested the interrupt. For all other interrupts this field is RAZ.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_DIR_31_13</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>13</spirit:bitOffset>
              <spirit:bitWidth>19</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_EOIR</spirit:name>
            <spirit:description>VM End Of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0010</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICV_EOIR -->
            <spirit:field>
              <spirit:name>EOIINTID</spirit:name>
              <spirit:displayName>EOIINTID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_EOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_HPPIR</spirit:name>
            <spirit:description>VM Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0018</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_HPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_HPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_IAR</spirit:name>
            <spirit:description>VM Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x000C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICV_IAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_IAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_IIDR</spirit:name>
            <spirit:description>VM CPU Interface Identification Register</spirit:description>
            <spirit:addressOffset>0x00FC</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x0034443B</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_IIDR -->
            <spirit:field>
              <spirit:name>Implementer</spirit:name>
              <spirit:displayName>Implementer</spirit:displayName>
              <spirit:description>Contains the JEP106 code of the company that implements the CPU interface. For an ARM implementation these values are: Bits[11:8] = 0x4 The JEP106 continuation code of the implementer. Bit-7 Always 0. Bits 6:0 = 0x3B The JEP106 identity code of the implementer.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Revision</spirit:name>
              <spirit:displayName>Revision</spirit:displayName>
              <spirit:description>Identifies the revision number for the CPU interface: 0x0 Revision 0.</spirit:description>
              <spirit:bitOffset>12</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Architectureversion</spirit:name>
              <spirit:displayName>Architecture version</spirit:displayName>
              <spirit:description>Identifies the architecture version of the GIC: 0x4 Version 4.</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>ProductID</spirit:name>
              <spirit:displayName>ProductID</spirit:displayName>
              <spirit:description>Identifies the product: 0x003 Cortex-A53 MPCore processor.</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_PMR</spirit:name>
            <spirit:description>VM Priority Mask Register</spirit:description>
            <spirit:addressOffset>0x0004</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_PMR -->
            <spirit:field>
              <spirit:name>RESERVED_GICV_PMR_2_0</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>GICV_PMR is similar to GICC_PMR the corresponding register in the GIC physical CPU interface except that bits [2:0] are reserved. This is because the virtual CPU interface supports fewer priority values than the maximum number of values that the physical CPU interface can support.</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_PMR_31_8</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_RPR</spirit:name>
            <spirit:description>VM Running Priority Register</spirit:description>
            <spirit:addressOffset>0x0014</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000000FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_RPR -->
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The current running priority on the CPU interface.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_RPR_31_8</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
        </spirit:addressBlock>
        <spirit:addressBlock>
          <spirit:name>Virtual_Interface_control_CPU0</spirit:name>
          <spirit:displayName>Virtual Interface control Memory Map CPU0</spirit:displayName>
          <spirit:description>Virtual Interface control registers are management registers.</spirit:description>
          <spirit:baseAddress>0x10000</spirit:baseAddress>
          <spirit:range>64K</spirit:range>
          <spirit:width>32</spirit:width>
          <!--  Registers for Local/Memory Map for GIC_CPU0 <Virtual_Interface_control_CPU0>  -->
          <spirit:register>
            <spirit:name>GICH_APR0</spirit:name>
            <spirit:description>Active Priorities Register</spirit:description>
            <spirit:addressOffset>0x0F0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_APR0 -->
            <spirit:field>
              <spirit:name>GICH_APR</spirit:name>
              <spirit:displayName>GICH_APR</spirit:displayName>
              <spirit:description>Determines whether the corresponding preemption level is active: 0 the preemption level is not active. 1 the preemption level is active.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_EISR0</spirit:name>
            <spirit:description>End of Interrupt Status Registers</spirit:description>
            <spirit:addressOffset>0x020</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_EISR0 -->
            <spirit:field>
              <spirit:name>GICH_EISR0</spirit:name>
              <spirit:displayName>GICH_EISR0</spirit:displayName>
              <spirit:description>For each bit - 0 Corresponding List register does not have an EOI. 1 Corresponding List register has an EOI</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_ELRSR0</spirit:name>
            <spirit:description>Empty List Register Status Registers</spirit:description>
            <spirit:addressOffset>0x030</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x0000000F</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_ELRSR0 -->
            <spirit:field>
              <spirit:name>GICH_ELRSR0</spirit:name>
              <spirit:displayName>GICH_ELRSR0</spirit:displayName>
              <spirit:description>For each bit: 0 The corresponding List register if implemented contains a valid interrupt. Using this List register can result in overwriting a valid interrupt. 1 The corresponding List register does not contain a valid interrupt. The List register is empty and can be used without overwriting a valid interrupt or losing an EOI maintenance interrupt</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_HCR</spirit:name>
            <spirit:description>Hypervisor Control Register</spirit:description>
            <spirit:addressOffset>0x000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_HCR -->
            <spirit:field>
              <spirit:name>En</spirit:name>
              <spirit:displayName>Enable</spirit:displayName>
              <spirit:description>When this field is set to 0 - the virtual CPU interface does not signal any maintenance interrupts. The virtual CPU interface does not signal any virtual interrupts A read of GICV_IAR or GICV_AIAR returns a spurious interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>UIE</spirit:name>
              <spirit:displayName>Underflow Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt when the List registers are empty or hold only one valid entry</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>LRENPIE</spirit:name>
              <spirit:displayName>List Register Entry Not Present Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while the virtual CPU interface does not have a corresponding valid List register entry for an EOI request</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>NPIE</spirit:name>
              <spirit:displayName>No Pending Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while no pending interrupts are present in the List registers</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0EIE</spirit:name>
              <spirit:displayName>VM Enable Group 0 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is enabled</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0DIE</spirit:name>
              <spirit:displayName>VM Disable Group 0 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is disabled</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1EIE</spirit:name>
              <spirit:displayName>VM Enable Group 1 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is enabled</spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1DIE</spirit:name>
              <spirit:displayName>VM Disable Group 1 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is disabled</spirit:description>
              <spirit:bitOffset>7</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_HCR_26_8</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>19</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EOICount</spirit:name>
              <spirit:displayName>EOICount</spirit:displayName>
              <spirit:description>Counts the number of EOIs received that do not have a corresponding entry in the List registers. The virtual CPU interface increments this field automatically when a matching EOI is received. EOIs that do not clear a bit in the Active Priorities register GICH_APR do not cause an increment. Although not possible under correct operation if an EOI occurs when the value of this field is 31 this field wraps to 0. The maintenance interrupt is asserted whenever this field is non-zero and the LRENPIE bit is set to 1.</spirit:description>
              <spirit:bitOffset>27</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR0</spirit:name>
            <spirit:description>List Register 0</spirit:description>
            <spirit:addressOffset>0x100</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR0 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR0_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR1</spirit:name>
            <spirit:description>List Register 1</spirit:description>
            <spirit:addressOffset>0x104</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR1 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR1_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR2</spirit:name>
            <spirit:description>List Register 2</spirit:description>
            <spirit:addressOffset>0x108</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR2 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR2_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR3</spirit:name>
            <spirit:description>List Register 3</spirit:description>
            <spirit:addressOffset>0x10C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR3 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR3_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_MISR</spirit:name>
            <spirit:description>Maintenance Interrupt Status Register</spirit:description>
            <spirit:addressOffset>0x010</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_MISR -->
            <spirit:field>
              <spirit:name>EOI</spirit:name>
              <spirit:displayName>EOI maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever at least one List register is asserting an EOI Interrupt. At least one bit in GICH_EISRn==1</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>U</spirit:name>
              <spirit:displayName>Underflow maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.UIE is set and if none or only one of the List register entries are marked as a valid interrupt that is if the corresponding GICH_LRn.State bits do not equal 0x0.</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>LRENP</spirit:name>
              <spirit:displayName>List Register Entry Not Present maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.LRENPIE==1 and GICH_HCR.EOICount is non-zero.</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>NP</spirit:name>
              <spirit:displayName>No Pending maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.NPIE==1 and no List register is in pending state</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0E</spirit:name>
              <spirit:displayName>Enabled Group 0 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp0EIE is set and GICH_VMCR.VMGrp0En==1</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0D</spirit:name>
              <spirit:displayName>Disabled Group 0 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp0DIE is set and GICH_VMCR.VMGrp0En==0</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1E</spirit:name>
              <spirit:displayName>Enabled Group 1 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp1EIE isset and GICH_VMCR.VMGrp1En==1.</spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1D</spirit:name>
              <spirit:displayName>Disabled Group 1 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp1DIE is set and GICH_VMCR.VMGrp1En==0</spirit:description>
              <spirit:bitOffset>7</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_MISR_31_8</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_VMCR</spirit:name>
            <spirit:description>Virtual Machine Control Register</spirit:description>
            <spirit:addressOffset>0x008</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x004C0000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_VMCR -->
            <spirit:field>
              <spirit:name>VMGrp0En</spirit:name>
              <spirit:displayName>VMGrp0En</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.EnableGrp0.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMGrp1En</spirit:name>
              <spirit:displayName>VMGrp1En</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.EnableGrp1.</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMAckCtl</spirit:name>
              <spirit:displayName>VMAckCtl</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.AckCtl.</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMFIQEn</spirit:name>
              <spirit:displayName>VMFIQEn</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.FIQEn.</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMCBPR</spirit:name>
              <spirit:displayName>VMCBPR</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.CBPR.</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VMCR_8_5</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VEM</spirit:name>
              <spirit:displayName>VEM</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.EOImode.</spirit:description>
              <spirit:bitOffset>9</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VMCR_17_10</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMABP</spirit:name>
              <spirit:displayName>VMABP</spirit:displayName>
              <spirit:description>Alias of GICV_ABPR.Binary point.</spirit:description>
              <spirit:bitOffset>18</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMBP</spirit:name>
              <spirit:displayName>VMBP</spirit:displayName>
              <spirit:description>Alias of GICV_BPR.Binary point. On reset this bit is set to the minimum supported value of GICV_BPR.</spirit:description>
              <spirit:bitOffset>21</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VMCR_26_24</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>24</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMPriMask</spirit:name>
              <spirit:displayName>VMPriMask</spirit:displayName>
              <spirit:description>Alias of GICV_PMR.Priority.</spirit:description>
              <spirit:bitOffset>27</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_VTR</spirit:name>
            <spirit:description>VGIC Type Register</spirit:description>
            <spirit:addressOffset>0x004</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x90000003</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_VTR -->
            <spirit:field>
              <spirit:name>ListRegs</spirit:name>
              <spirit:displayName>ListRegs</spirit:displayName>
              <spirit:description>Indicates the number of implemented List Registers minus one: 0x3 Four List Registers.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>6</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VTR_25_6</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved RAZ</spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>20</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PREbits</spirit:name>
              <spirit:displayName>PREbits</spirit:displayName>
              <spirit:description>Indicates the number of preemption bits implemented minus one: 0x4 Five bits of preemption and 32 preemption levels.</spirit:description>
              <spirit:bitOffset>26</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PRIbits</spirit:name>
              <spirit:displayName>PRIbits</spirit:displayName>
              <spirit:description>Indicates the number of priority bits implemented minus one: 0x4 Five bits of priority and 32 priority levels.</spirit:description>
              <spirit:bitOffset>29</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
        </spirit:addressBlock>
        <spirit:addressBlock>
          <spirit:name>Processor_Interface_CPU0</spirit:name>
          <spirit:displayName>Processor Interface Memory Map CPU0</spirit:displayName>
          <spirit:description>Enabling signaling by processor Interface. Acknowledging and indicating a completion of an interrupt.</spirit:description>
          <spirit:baseAddress>0x00000</spirit:baseAddress>
          <spirit:range>64K</spirit:range>
          <spirit:width>32</spirit:width>
          <!--  Registers for Local/Memory Map for GIC_CPU0 <Processor_Interface_CPU0>  -->
          <spirit:register>
            <spirit:name>GICC_ABPR</spirit:name>
            <spirit:description>Aliased Binary Point Register</spirit:description>
            <spirit:addressOffset>0x001C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000003</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_ABPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The value of this field controls how the 8-bit interrupt priority field is split into a group priority field used to determine interrupt preemption and a subpriority field.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_ABPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_AEOIR</spirit:name>
            <spirit:description>Aliased End of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0024</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICC_AEOIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_AIAR or Non-secure GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_AEOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_AHPPIR</spirit:name>
            <spirit:description>Aliased Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0028</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_AHPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt if that interrupt is a Group 1 interrupt. Otherwise the spurious interrupt ID 1023.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_AHPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_AIAR</spirit:name>
            <spirit:description>Aliased Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x0020</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICC_AIAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_AIAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_APR0</spirit:name>
            <spirit:description>Active Priority Register</spirit:description>
            <spirit:addressOffset>0x00D0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_APR0 -->
            <spirit:field>
              <spirit:name>GICC_APR</spirit:name>
              <spirit:displayName>GICC_APR</spirit:displayName>
              <spirit:description>Active Priorities Register </spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_BPR</spirit:name>
            <spirit:description>Binary Point Register</spirit:description>
            <spirit:addressOffset>0x0008</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000002</spirit:value>
              <spirit:mask>0x00000003</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_BPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The value of this field controls how the 8-bit interrupt priority field is split into a group priority field used to determine interrupt preemption and a subpriority field.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_BPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_CTLR</spirit:name>
            <spirit:description>CPU Interface Control Register</spirit:description>
            <spirit:addressOffset>0x0000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_CTLR -->
            <spirit:field>
              <spirit:name>Enable</spirit:name>
              <spirit:displayName>Enable</spirit:displayName>
              <spirit:description>Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_CTLR_4_1</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>FIQBypDisGrp1</spirit:name>
              <spirit:displayName>FIQBypDisGrp1</spirit:displayName>
              <spirit:description> </spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>IRQBypDisGrp1</spirit:name>
              <spirit:displayName>IRQBypDisGrp1</spirit:displayName>
              <spirit:description> </spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_CTLR_8_7</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>7</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EOImodeNS</spirit:name>
              <spirit:displayName>EOImodeNS</spirit:displayName>
              <spirit:description>Controls the behavior of non-secure accesses to the GICC_EOIR GICC_AEOIR and GICC_DIR registers</spirit:description>
              <spirit:bitOffset>9</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_CTLR_31_10</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>22</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_DIR</spirit:name>
            <spirit:description>Deactivate Interrupt Register</spirit:description>
            <spirit:addressOffset>0x1000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICC_DIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_DIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_EOIR</spirit:name>
            <spirit:description>End Of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0010</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICC_EOIR -->
            <spirit:field>
              <spirit:name>EOIINTID</spirit:name>
              <spirit:displayName>EOIINTID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_EOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_HPPIR</spirit:name>
            <spirit:description>Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0018</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_HPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_HPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_IAR</spirit:name>
            <spirit:description>Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x000C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICC_IAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_IAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_IIDR</spirit:name>
            <spirit:description>CPU Interface Identification Register</spirit:description>
            <spirit:addressOffset>0x00FC</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x0034443B</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_IIDR -->
            <spirit:field>
              <spirit:name>Implementer</spirit:name>
              <spirit:displayName>Implementer</spirit:displayName>
              <spirit:description>Contains the JEP106 code of the company that implements the CPU interface. For an ARM implementation these values are: Bits[11:8] = 0x4 The JEP106 continuation code of the implementer. Bit-7 Always 0. Bits 6:0 = 0x3B The JEP106 identity code of the implementer.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Revision</spirit:name>
              <spirit:displayName>Revision</spirit:displayName>
              <spirit:description>Identifies the revision number for the CPU interface: 0x0 Revision 0.</spirit:description>
              <spirit:bitOffset>12</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Architectureversion</spirit:name>
              <spirit:displayName>Architecture version</spirit:displayName>
              <spirit:description>Identifies the architecture version of the GIC: 0x4 Version 4.</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>ProductID</spirit:name>
              <spirit:displayName>ProductID</spirit:displayName>
              <spirit:description>Identifies the product: 0x003 Cortex-A53 MPCore processor.</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_NSAPR0</spirit:name>
            <spirit:description>Non-secure Active Priority Register</spirit:description>
            <spirit:addressOffset>0x00E0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_NSAPR0 -->
            <spirit:field>
              <spirit:name>GICC_NSAPR</spirit:name>
              <spirit:displayName>GICC_NSAPR</spirit:displayName>
              <spirit:description>Non-secure Active Priorities Register </spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_PMR</spirit:name>
            <spirit:description>Interrupt Priority Mask Register</spirit:description>
            <spirit:addressOffset>0x0004</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_PMR -->
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority mask level for the CPU interface. If the priority of an interrupt is higher than the value indicated by this field the interface signals the interrupt to the processor. If the GIC supports fewer than 256 priority levels then some bits are RAZ/WI as follows: 128 supported levels Bit [0] = 0. 64 supported levels Bit [1:0] = 0b00. 32 supported levels Bit [2:0] = 0b000. 16 supported levels Bit [3:0] = 0b0000.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_PMR_31_8</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_RPR</spirit:name>
            <spirit:description>Running Priority Register</spirit:description>
            <spirit:addressOffset>0x0014</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000000FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_RPR -->
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The current running priority on the CPU interface.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_RPR_31_8</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
        </spirit:addressBlock>
      </spirit:localMemoryMap>
      
    </spirit:addressSpace>
    <spirit:addressSpace>
      <spirit:name>GIC_CPU2</spirit:name>
      <spirit:displayName>GIC Interface CPU2</spirit:displayName>
      <spirit:description>GIC Interface</spirit:description>
      <spirit:range>256K</spirit:range>
      <spirit:width>32</spirit:width>
      <!--  Local Memory Map for GIC_CPU2  -->
      <spirit:localMemoryMap>
        <spirit:name>GIC_Memory_Map_CPU2</spirit:name>
        <spirit:addressBlock>
          <spirit:name>Processor_Interface_CPU2</spirit:name>
          <spirit:displayName>Processor Interface Memory Map CPU2</spirit:displayName>
          <spirit:description>Enabling signaling by processor Interface. Acknowledging and indicating a completion of an interrupt.</spirit:description>
          <spirit:baseAddress>0x00000</spirit:baseAddress>
          <spirit:range>64K</spirit:range>
          <spirit:width>32</spirit:width>
          <!--  Registers for Local/Memory Map for GIC_CPU2 <Processor_Interface_CPU2>  -->
          <spirit:register>
            <spirit:name>GICC_ABPR</spirit:name>
            <spirit:description>Aliased Binary Point Register</spirit:description>
            <spirit:addressOffset>0x001C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000003</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_ABPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The value of this field controls how the 8-bit interrupt priority field is split into a group priority field used to determine interrupt preemption and a subpriority field.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_ABPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_AEOIR</spirit:name>
            <spirit:description>Aliased End of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0024</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICC_AEOIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_AIAR or Non-secure GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_AEOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_AHPPIR</spirit:name>
            <spirit:description>Aliased Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0028</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_AHPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt if that interrupt is a Group 1 interrupt. Otherwise the spurious interrupt ID 1023.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_AHPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_AIAR</spirit:name>
            <spirit:description>Aliased Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x0020</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICC_AIAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_AIAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_APR0</spirit:name>
            <spirit:description>Active Priority Register</spirit:description>
            <spirit:addressOffset>0x00D0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_APR0 -->
            <spirit:field>
              <spirit:name>GICC_APR</spirit:name>
              <spirit:displayName>GICC_APR</spirit:displayName>
              <spirit:description>Active Priorities Register </spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_BPR</spirit:name>
            <spirit:description>Binary Point Register</spirit:description>
            <spirit:addressOffset>0x0008</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000002</spirit:value>
              <spirit:mask>0x00000003</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_BPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The value of this field controls how the 8-bit interrupt priority field is split into a group priority field used to determine interrupt preemption and a subpriority field.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_BPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_CTLR</spirit:name>
            <spirit:description>CPU Interface Control Register</spirit:description>
            <spirit:addressOffset>0x0000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_CTLR -->
            <spirit:field>
              <spirit:name>Enable</spirit:name>
              <spirit:displayName>Enable</spirit:displayName>
              <spirit:description>Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_CTLR_4_1</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>FIQBypDisGrp1</spirit:name>
              <spirit:displayName>FIQBypDisGrp1</spirit:displayName>
              <spirit:description> </spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>IRQBypDisGrp1</spirit:name>
              <spirit:displayName>IRQBypDisGrp1</spirit:displayName>
              <spirit:description> </spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_CTLR_8_7</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>7</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EOImodeNS</spirit:name>
              <spirit:displayName>EOImodeNS</spirit:displayName>
              <spirit:description>Controls the behavior of non-secure accesses to the GICC_EOIR GICC_AEOIR and GICC_DIR registers</spirit:description>
              <spirit:bitOffset>9</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_CTLR_31_10</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>22</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_DIR</spirit:name>
            <spirit:description>Deactivate Interrupt Register</spirit:description>
            <spirit:addressOffset>0x1000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICC_DIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_DIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_EOIR</spirit:name>
            <spirit:description>End Of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0010</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICC_EOIR -->
            <spirit:field>
              <spirit:name>EOIINTID</spirit:name>
              <spirit:displayName>EOIINTID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_EOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_HPPIR</spirit:name>
            <spirit:description>Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0018</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_HPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_HPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_IAR</spirit:name>
            <spirit:description>Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x000C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICC_IAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_IAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_IIDR</spirit:name>
            <spirit:description>CPU Interface Identification Register</spirit:description>
            <spirit:addressOffset>0x00FC</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x0034443B</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_IIDR -->
            <spirit:field>
              <spirit:name>Implementer</spirit:name>
              <spirit:displayName>Implementer</spirit:displayName>
              <spirit:description>Contains the JEP106 code of the company that implements the CPU interface. For an ARM implementation these values are: Bits[11:8] = 0x4 The JEP106 continuation code of the implementer. Bit-7 Always 0. Bits 6:0 = 0x3B The JEP106 identity code of the implementer.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Revision</spirit:name>
              <spirit:displayName>Revision</spirit:displayName>
              <spirit:description>Identifies the revision number for the CPU interface: 0x0 Revision 0.</spirit:description>
              <spirit:bitOffset>12</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Architectureversion</spirit:name>
              <spirit:displayName>Architecture version</spirit:displayName>
              <spirit:description>Identifies the architecture version of the GIC: 0x4 Version 4.</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>ProductID</spirit:name>
              <spirit:displayName>ProductID</spirit:displayName>
              <spirit:description>Identifies the product: 0x003 Cortex-A53 MPCore processor.</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_NSAPR0</spirit:name>
            <spirit:description>Non-secure Active Priority Register</spirit:description>
            <spirit:addressOffset>0x00E0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_NSAPR0 -->
            <spirit:field>
              <spirit:name>GICC_NSAPR</spirit:name>
              <spirit:displayName>GICC_NSAPR</spirit:displayName>
              <spirit:description>Non-secure Active Priorities Register </spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_PMR</spirit:name>
            <spirit:description>Interrupt Priority Mask Register</spirit:description>
            <spirit:addressOffset>0x0004</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_PMR -->
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority mask level for the CPU interface. If the priority of an interrupt is higher than the value indicated by this field the interface signals the interrupt to the processor. If the GIC supports fewer than 256 priority levels then some bits are RAZ/WI as follows: 128 supported levels Bit [0] = 0. 64 supported levels Bit [1:0] = 0b00. 32 supported levels Bit [2:0] = 0b000. 16 supported levels Bit [3:0] = 0b0000.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_PMR_31_8</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICC_RPR</spirit:name>
            <spirit:description>Running Priority Register</spirit:description>
            <spirit:addressOffset>0x0014</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000000FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICC_RPR -->
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The current running priority on the CPU interface.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICC_RPR_31_8</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
        </spirit:addressBlock>
        <spirit:addressBlock>
          <spirit:name>Virtual_Interface_control_CPU2</spirit:name>
          <spirit:displayName>Virtual Interface control Memory Map CPU2</spirit:displayName>
          <spirit:description>Virtual Interface control registers are management registers.</spirit:description>
          <spirit:baseAddress>0x10000</spirit:baseAddress>
          <spirit:range>64K</spirit:range>
          <spirit:width>32</spirit:width>
          <!--  Registers for Local/Memory Map for GIC_CPU2 <Virtual_Interface_control_CPU2>  -->
          <spirit:register>
            <spirit:name>GICH_APR0</spirit:name>
            <spirit:description>Active Priorities Register</spirit:description>
            <spirit:addressOffset>0x0F0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_APR0 -->
            <spirit:field>
              <spirit:name>GICH_APR</spirit:name>
              <spirit:displayName>GICH_APR</spirit:displayName>
              <spirit:description>Determines whether the corresponding preemption level is active: 0 the preemption level is not active. 1 the preemption level is active.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_EISR0</spirit:name>
            <spirit:description>End of Interrupt Status Registers</spirit:description>
            <spirit:addressOffset>0x020</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_EISR0 -->
            <spirit:field>
              <spirit:name>GICH_EISR0</spirit:name>
              <spirit:displayName>GICH_EISR0</spirit:displayName>
              <spirit:description>For each bit - 0 Corresponding List register does not have an EOI. 1 Corresponding List register has an EOI</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_ELRSR0</spirit:name>
            <spirit:description>Empty List Register Status Registers</spirit:description>
            <spirit:addressOffset>0x030</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x0000000F</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_ELRSR0 -->
            <spirit:field>
              <spirit:name>GICH_ELRSR0</spirit:name>
              <spirit:displayName>GICH_ELRSR0</spirit:displayName>
              <spirit:description>For each bit: 0 The corresponding List register if implemented contains a valid interrupt. Using this List register can result in overwriting a valid interrupt. 1 The corresponding List register does not contain a valid interrupt. The List register is empty and can be used without overwriting a valid interrupt or losing an EOI maintenance interrupt</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_HCR</spirit:name>
            <spirit:description>Hypervisor Control Register</spirit:description>
            <spirit:addressOffset>0x000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_HCR -->
            <spirit:field>
              <spirit:name>En</spirit:name>
              <spirit:displayName>Enable</spirit:displayName>
              <spirit:description>When this field is set to 0 - the virtual CPU interface does not signal any maintenance interrupts. The virtual CPU interface does not signal any virtual interrupts A read of GICV_IAR or GICV_AIAR returns a spurious interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>UIE</spirit:name>
              <spirit:displayName>Underflow Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt when the List registers are empty or hold only one valid entry</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>LRENPIE</spirit:name>
              <spirit:displayName>List Register Entry Not Present Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while the virtual CPU interface does not have a corresponding valid List register entry for an EOI request</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>NPIE</spirit:name>
              <spirit:displayName>No Pending Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while no pending interrupts are present in the List registers</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0EIE</spirit:name>
              <spirit:displayName>VM Enable Group 0 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is enabled</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0DIE</spirit:name>
              <spirit:displayName>VM Disable Group 0 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is disabled</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1EIE</spirit:name>
              <spirit:displayName>VM Enable Group 1 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is enabled</spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1DIE</spirit:name>
              <spirit:displayName>VM Disable Group 1 Interrupt Enable</spirit:displayName>
              <spirit:description>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is disabled</spirit:description>
              <spirit:bitOffset>7</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_HCR_26_8</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>19</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EOICount</spirit:name>
              <spirit:displayName>EOICount</spirit:displayName>
              <spirit:description>Counts the number of EOIs received that do not have a corresponding entry in the List registers. The virtual CPU interface increments this field automatically when a matching EOI is received. EOIs that do not clear a bit in the Active Priorities register GICH_APR do not cause an increment. Although not possible under correct operation if an EOI occurs when the value of this field is 31 this field wraps to 0. The maintenance interrupt is asserted whenever this field is non-zero and the LRENPIE bit is set to 1.</spirit:description>
              <spirit:bitOffset>27</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR0</spirit:name>
            <spirit:description>List Register 0</spirit:description>
            <spirit:addressOffset>0x100</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR0 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR0_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR1</spirit:name>
            <spirit:description>List Register 1</spirit:description>
            <spirit:addressOffset>0x104</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR1 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR1_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR2</spirit:name>
            <spirit:description>List Register 2</spirit:description>
            <spirit:addressOffset>0x108</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR2 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR2_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_LR3</spirit:name>
            <spirit:description>List Register 3</spirit:description>
            <spirit:addressOffset>0x10C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_LR3 -->
            <spirit:field>
              <spirit:name>VirtualID</spirit:name>
              <spirit:displayName>VirtualID</spirit:displayName>
              <spirit:description>This ID is returned to the Guest OS when the interrupt is acknowledged through the VM Interrupt Acknowledge register GICV_IAR. Each valid interrupt stored in the List registers must have a unique VirtualID for that virtual CPU interface. If the value of VirtualID is 1020-1023 behavior is UNPREDICTABLE.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PhysicalID</spirit:name>
              <spirit:displayName>PhysicalID</spirit:displayName>
              <spirit:description>The function of this bit depends on the value of the GICH_LR.HW bit as follows. 0 When GICH_LR.HW is set to 0 bits [19:10] have the following meanings: [19] EOI Indicates whether this interrupt triggers an EOI maintenance interrupt. 0 No maintenance interrupt is asserted. 1 A maintenance interrupt is asserted to signal EOI when the interrupt state is invalid which typically occurs when the interrupt is deactivated. [18:13] Reserved SBZ [12:10] CPUID. If the interrupt has the VirtualID for an SGI that is 0-15 this field shows the requesting CPU ID. This appears in the relevant field of the VM Interrupt Acknowledge register GICV_IAR or GICV_AIAR. Otherwise this field must be set to 0. 1 When GICH_LR.HW is set to 1 this field indicates the physical interrupt ID that the hypervisor forwards to the Distributor.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_LR3_22_20</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The priority of this interrupt</spirit:description>
              <spirit:bitOffset>23</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>State</spirit:name>
              <spirit:displayName>State</spirit:displayName>
              <spirit:description>The state of the interrupt. The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored except for the purpose of generating virtual maintenance interrupts</spirit:description>
              <spirit:bitOffset>28</spirit:bitOffset>
              <spirit:bitWidth>2</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Grp1</spirit:name>
              <spirit:displayName>Grp1</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a Group 1 virtual interrupt</spirit:description>
              <spirit:bitOffset>30</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>HW</spirit:name>
              <spirit:displayName>HW</spirit:displayName>
              <spirit:description>Indicates whether this virtual interrupt is a hardware interrupt meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the PhysicalID field indicates</spirit:description>
              <spirit:bitOffset>31</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_MISR</spirit:name>
            <spirit:description>Maintenance Interrupt Status Register</spirit:description>
            <spirit:addressOffset>0x010</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_MISR -->
            <spirit:field>
              <spirit:name>EOI</spirit:name>
              <spirit:displayName>EOI maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever at least one List register is asserting an EOI Interrupt. At least one bit in GICH_EISRn==1</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>U</spirit:name>
              <spirit:displayName>Underflow maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.UIE is set and if none or only one of the List register entries are marked as a valid interrupt that is if the corresponding GICH_LRn.State bits do not equal 0x0.</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>LRENP</spirit:name>
              <spirit:displayName>List Register Entry Not Present maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.LRENPIE==1 and GICH_HCR.EOICount is non-zero.</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>NP</spirit:name>
              <spirit:displayName>No Pending maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.NPIE==1 and no List register is in pending state</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0E</spirit:name>
              <spirit:displayName>Enabled Group 0 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp0EIE is set and GICH_VMCR.VMGrp0En==1</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp0D</spirit:name>
              <spirit:displayName>Disabled Group 0 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp0DIE is set and GICH_VMCR.VMGrp0En==0</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1E</spirit:name>
              <spirit:displayName>Enabled Group 1 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp1EIE isset and GICH_VMCR.VMGrp1En==1.</spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VGrp1D</spirit:name>
              <spirit:displayName>Disabled Group 1 maintenance interrupt</spirit:displayName>
              <spirit:description>Asserted whenever GICH_HCR.VGrp1DIE is set and GICH_VMCR.VMGrp1En==0</spirit:description>
              <spirit:bitOffset>7</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_MISR_31_8</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_VMCR</spirit:name>
            <spirit:description>Virtual Machine Control Register</spirit:description>
            <spirit:addressOffset>0x008</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x004C0000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_VMCR -->
            <spirit:field>
              <spirit:name>VMGrp0En</spirit:name>
              <spirit:displayName>VMGrp0En</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.EnableGrp0.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMGrp1En</spirit:name>
              <spirit:displayName>VMGrp1En</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.EnableGrp1.</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMAckCtl</spirit:name>
              <spirit:displayName>VMAckCtl</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.AckCtl.</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMFIQEn</spirit:name>
              <spirit:displayName>VMFIQEn</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.FIQEn.</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMCBPR</spirit:name>
              <spirit:displayName>VMCBPR</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.CBPR.</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VMCR_8_5</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VEM</spirit:name>
              <spirit:displayName>VEM</spirit:displayName>
              <spirit:description>Alias of GICV_CTLR.EOImode.</spirit:description>
              <spirit:bitOffset>9</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VMCR_17_10</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMABP</spirit:name>
              <spirit:displayName>VMABP</spirit:displayName>
              <spirit:description>Alias of GICV_ABPR.Binary point.</spirit:description>
              <spirit:bitOffset>18</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMBP</spirit:name>
              <spirit:displayName>VMBP</spirit:displayName>
              <spirit:description>Alias of GICV_BPR.Binary point. On reset this bit is set to the minimum supported value of GICV_BPR.</spirit:description>
              <spirit:bitOffset>21</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VMCR_26_24</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>24</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>VMPriMask</spirit:name>
              <spirit:displayName>VMPriMask</spirit:displayName>
              <spirit:description>Alias of GICV_PMR.Priority.</spirit:description>
              <spirit:bitOffset>27</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICH_VTR</spirit:name>
            <spirit:description>VGIC Type Register</spirit:description>
            <spirit:addressOffset>0x004</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x90000003</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICH_VTR -->
            <spirit:field>
              <spirit:name>ListRegs</spirit:name>
              <spirit:displayName>ListRegs</spirit:displayName>
              <spirit:description>Indicates the number of implemented List Registers minus one: 0x3 Four List Registers.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>6</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICH_VTR_25_6</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved RAZ</spirit:description>
              <spirit:bitOffset>6</spirit:bitOffset>
              <spirit:bitWidth>20</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PREbits</spirit:name>
              <spirit:displayName>PREbits</spirit:displayName>
              <spirit:description>Indicates the number of preemption bits implemented minus one: 0x4 Five bits of preemption and 32 preemption levels.</spirit:description>
              <spirit:bitOffset>26</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>PRIbits</spirit:name>
              <spirit:displayName>PRIbits</spirit:displayName>
              <spirit:description>Indicates the number of priority bits implemented minus one: 0x4 Five bits of priority and 32 priority levels.</spirit:description>
              <spirit:bitOffset>29</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
        </spirit:addressBlock>
        <spirit:addressBlock>
          <spirit:name>Virtual_CPU_Interface_CPU2</spirit:name>
          <spirit:displayName>Virtual CPU Interface Memory Map CPU2</spirit:displayName>
          <spirit:description>Virtual Processor interface forwards virtual Interrupts connected to a processor. </spirit:description>
          <spirit:baseAddress>0x20000</spirit:baseAddress>
          <spirit:range>64K</spirit:range>
          <spirit:width>32</spirit:width>
          <!--  Registers for Local/Memory Map for GIC_CPU2 <Virtual_CPU_Interface_CPU2>  -->
          <spirit:register>
            <spirit:name>GICV_ABPR</spirit:name>
            <spirit:description>VM Aliased Binary Point Register</spirit:description>
            <spirit:addressOffset>0x001C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000003</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_ABPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The value of this field controls how the 8-bit interrupt priority field is split into a group priority field used to determine interrupt preemption and a subpriority field.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_ABPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_AEOIR</spirit:name>
            <spirit:description>VM Aliased End of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0024</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICV_AEOIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_AIAR or Non-secure GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_AEOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_AHPPIR</spirit:name>
            <spirit:description>VM Aliased Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0028</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_AHPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt if that interrupt is a Group 1 interrupt. Otherwise the spurious interrupt ID 1023.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_AHPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_AIAR</spirit:name>
            <spirit:description>VM Aliased Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x0020</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICV_AIAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_AIAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_APR0</spirit:name>
            <spirit:description>VM Active Priority Register </spirit:description>
            <spirit:addressOffset>0x00D0</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_APR0 -->
            <spirit:field>
              <spirit:name>GICV_APR</spirit:name>
              <spirit:displayName>GICV_APR</spirit:displayName>
              <spirit:description>Active Priorities Register </spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>32</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_BPR</spirit:name>
            <spirit:description>VM Binary Point Register</spirit:description>
            <spirit:addressOffset>0x0008</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000002</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_BPR -->
            <spirit:field>
              <spirit:name>Binarypoint</spirit:name>
              <spirit:displayName>Binary point</spirit:displayName>
              <spirit:description>The GICV_BPR bit assignments are the same as assignments for the GICC_BPR the corresponding register in the physical CPU interface.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_BPR_31_3</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>29</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_CTLR</spirit:name>
            <spirit:description>VM Control Register</spirit:description>
            <spirit:addressOffset>0x0000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_CTLR -->
            <spirit:field>
              <spirit:name>EnableGrp0</spirit:name>
              <spirit:displayName>EnableGrp0</spirit:displayName>
              <spirit:description>Enables the signaling of Group 0 virtual interrupts by the virtual CPU interface to the virtual machine</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EnableGrp1</spirit:name>
              <spirit:displayName>EnableGrp1</spirit:displayName>
              <spirit:description>Enables the signaling of Group 1 virtual interrupts by the virtual CPU interface to the virtual machine</spirit:description>
              <spirit:bitOffset>1</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>AckCtl</spirit:name>
              <spirit:displayName>AckCtl</spirit:displayName>
              <spirit:description>ARM deprecates use of this bit. ARM strongly recommends that software is written to operate with this bit always set to 0. Controls whether a read of the GICV_IAR when the highest priority pending interrupt is a Group 1 interrupt causes the CPU interface to acknowledge the interrupt</spirit:description>
              <spirit:bitOffset>2</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>FIQEn</spirit:name>
              <spirit:displayName>FIQEn</spirit:displayName>
              <spirit:description>Controls whether interrupts marked as Group 0 are presented as virtual FIQs</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>CBPR</spirit:name>
              <spirit:displayName>CBPR</spirit:displayName>
              <spirit:description>Controls whether the GICV_BPR controls both Group 0 and Group 1 virtual interrupts</spirit:description>
              <spirit:bitOffset>4</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_CTLR_8_5</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>5</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>EOImode</spirit:name>
              <spirit:displayName>EOImode</spirit:displayName>
              <spirit:description>Controls the behavior associated with the GICV_EOIR GICV_AEOIR and GICV_DIR registers</spirit:description>
              <spirit:bitOffset>9</spirit:bitOffset>
              <spirit:bitWidth>1</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_CTLR_31_10</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>22</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_DIR</spirit:name>
            <spirit:description>VM Deactivate Interrupt Register</spirit:description>
            <spirit:addressOffset>0x1000</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICV_DIR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>10</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>CPUID</spirit:name>
              <spirit:displayName>CPUID</spirit:displayName>
              <spirit:description>For an SGI in a multiprocessor implementation this field identifies the processor that requested the interrupt. For all other interrupts this field is RAZ.</spirit:description>
              <spirit:bitOffset>10</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_DIR_31_13</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved SBZ</spirit:description>
              <spirit:bitOffset>13</spirit:bitOffset>
              <spirit:bitWidth>19</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_EOIR</spirit:name>
            <spirit:description>VM End Of Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0010</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>write-only</spirit:access>
            <!--  Adding Fields for register: GICV_EOIR -->
            <spirit:field>
              <spirit:name>EOIINTID</spirit:name>
              <spirit:displayName>EOIINTID</spirit:displayName>
              <spirit:description>The Interrupt ID value from the corresponding GICC_IAR access.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_EOIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_HPPIR</spirit:name>
            <spirit:description>VM Highest Priority Pending Interrupt Register</spirit:description>
            <spirit:addressOffset>0x0018</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000003FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_HPPIR -->
            <spirit:field>
              <spirit:name>PENDINTID</spirit:name>
              <spirit:displayName>PENDINTID</spirit:displayName>
              <spirit:description>The interrupt ID of the highest priority pending interrupt.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_HPPIR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_IAR</spirit:name>
            <spirit:description>VM Interrupt Acknowledge Register</spirit:description>
            <spirit:addressOffset>0x000C</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <!--  Adding Fields for register: GICV_IAR -->
            <spirit:field>
              <spirit:name>InterruptID</spirit:name>
              <spirit:displayName>Interrupt ID</spirit:displayName>
              <spirit:description>The interrupt ID.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_IAR_31_16</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>16</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_IIDR</spirit:name>
            <spirit:description>VM CPU Interface Identification Register</spirit:description>
            <spirit:addressOffset>0x00FC</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x0034443B</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_IIDR -->
            <spirit:field>
              <spirit:name>Implementer</spirit:name>
              <spirit:displayName>Implementer</spirit:displayName>
              <spirit:description>Contains the JEP106 code of the company that implements the CPU interface. For an ARM implementation these values are: Bits[11:8] = 0x4 The JEP106 continuation code of the implementer. Bit-7 Always 0. Bits 6:0 = 0x3B The JEP106 identity code of the implementer.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Revision</spirit:name>
              <spirit:displayName>Revision</spirit:displayName>
              <spirit:description>Identifies the revision number for the CPU interface: 0x0 Revision 0.</spirit:description>
              <spirit:bitOffset>12</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Architectureversion</spirit:name>
              <spirit:displayName>Architecture version</spirit:displayName>
              <spirit:description>Identifies the architecture version of the GIC: 0x4 Version 4.</spirit:description>
              <spirit:bitOffset>16</spirit:bitOffset>
              <spirit:bitWidth>4</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>ProductID</spirit:name>
              <spirit:displayName>ProductID</spirit:displayName>
              <spirit:description>Identifies the product: 0x003 Cortex-A53 MPCore processor.</spirit:description>
              <spirit:bitOffset>20</spirit:bitOffset>
              <spirit:bitWidth>12</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_PMR</spirit:name>
            <spirit:description>VM Priority Mask Register</spirit:description>
            <spirit:addressOffset>0x0004</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-write</spirit:access>
            <spirit:reset>
              <spirit:value>0x00000000</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_PMR -->
            <spirit:field>
              <spirit:name>RESERVED_GICV_PMR_2_0</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>3</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>GICV_PMR is similar to GICC_PMR the corresponding register in the GIC physical CPU interface except that bits [2:0] are reserved. This is because the virtual CPU interface supports fewer priority values than the maximum number of values that the physical CPU interface can support.</spirit:description>
              <spirit:bitOffset>3</spirit:bitOffset>
              <spirit:bitWidth>5</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_PMR_31_8</spirit:name>
              <spirit:displayName>Reserved</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
          <spirit:register>
            <spirit:name>GICV_RPR</spirit:name>
            <spirit:description>VM Running Priority Register</spirit:description>
            <spirit:addressOffset>0x0014</spirit:addressOffset>
            <spirit:size>32</spirit:size>
            <spirit:access>read-only</spirit:access>
            <spirit:reset>
              <spirit:value>0x000000FF</spirit:value>
              <spirit:mask>0xFFFFFFFF</spirit:mask>
            </spirit:reset>
            <!--  Adding Fields for register: GICV_RPR -->
            <spirit:field>
              <spirit:name>Priority</spirit:name>
              <spirit:displayName>Priority</spirit:displayName>
              <spirit:description>The current running priority on the CPU interface.</spirit:description>
              <spirit:bitOffset>0</spirit:bitOffset>
              <spirit:bitWidth>8</spirit:bitWidth>
            </spirit:field>
            <spirit:field>
              <spirit:name>RESERVED_GICV_RPR_31_8</spirit:name>
              <spirit:displayName>RESERVED</spirit:displayName>
              <spirit:description>Reserved</spirit:description>
              <spirit:bitOffset>8</spirit:bitOffset>
              <spirit:bitWidth>24</spirit:bitWidth>
            </spirit:field>
            
          </spirit:register>
        </spirit:addressBlock>
      </spirit:localMemoryMap>
      
    </spirit:addressSpace>
  </spirit:addressSpaces>
  <!--  memoryMaps section  -->
  <spirit:memoryMaps>
    <!--  Memory Map for APB_Memory_Map  -->
    <spirit:memoryMap>
      <spirit:name>APB_Memory_Map</spirit:name>
      <spirit:addressBlock>
        <spirit:name>APBADDR_DBG_CPU2</spirit:name>
        <spirit:displayName>APBADDR_DBG_2</spirit:displayName>
        <spirit:description>APBADDR_DBG_2</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">2162688</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_DBG_CPU2>  -->
        <spirit:register>
          <spirit:name>DBGAUTHSTATUS_EL1</spirit:name>
          <spirit:description>Debug Authentication Status register</spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000AA</spirit:value>
            <spirit:mask>0xFFFFFFAA</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: DBGAUTHSTATUS_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGAUTHSTATUS_EL1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNID</spirit:name>
            <spirit:displayName>SNID</spirit:displayName>
            <spirit:description>Secure non-invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Non-secure.
      
      
    
      10
      
      Implemented and disabled. ExternalSecureNoninvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalSecureNoninvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SID</spirit:name>
            <spirit:displayName>SID</spirit:displayName>
            <spirit:description>Secure invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Non-secure.
      
      
    
      10
      
      Implemented and disabled. ExternalSecureInvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalSecureInvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>Non-secure non-invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Secure.
      
      
    
      10
      
      Implemented and disabled. ExternalNoninvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalNoninvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSID</spirit:name>
            <spirit:displayName>NSID</spirit:displayName>
            <spirit:description>Non-secure invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Secure.
      
      
    
      10
      
      Implemented and disabled. ExternalInvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalInvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR0_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 0</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR0_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR0_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR0_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR0_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR1_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 1</spirit:description>
          <spirit:addressOffset>0x418</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR1_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR1_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR1_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR1_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR2_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 2</spirit:description>
          <spirit:addressOffset>0x428</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR2_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR2_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR2_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR2_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR3_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 3</spirit:description>
          <spirit:addressOffset>0x438</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR3_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR3_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR3_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR3_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR4_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 4</spirit:description>
          <spirit:addressOffset>0x448</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR4_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR4_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR4_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR4_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR5_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 5</spirit:description>
          <spirit:addressOffset>0x458</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR5_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR5_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR5_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR5_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR0_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR0_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR0_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR0_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR0_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR0_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR0_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR0_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR1_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR1_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR1_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR1_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR1_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR1_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR1_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR1_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR2_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR2_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x420</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR2_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR2_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR2_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR2_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR2_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x424</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR2_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR2_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR2_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR3_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR3_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x430</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR3_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR3_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR3_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR3_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR3_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x434</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR3_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR3_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR3_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR4_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR4_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x440</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR4_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR4_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR4_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR4_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR4_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x444</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR4_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR4_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR4_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR5_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR5_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x450</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR5_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR5_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR5_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR5_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR5_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x454</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR5_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR5_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR5_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGCLAIMCLR_EL1</spirit:name>
          <spirit:description>Debug Claim Tag Clear Register</spirit:description>
          <spirit:addressOffset>0xFA4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: DBGCLAIMCLR_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGCLAIMCLR_EL1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RAZ/SBZ. Software can rely on these bits reading as zero, and must use a should-be-zero policy on writes. Implementations must ignore writes.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIM</spirit:name>
            <spirit:displayName>CLAIM</spirit:displayName>
            <spirit:description>Claim clear bits. Reading this field returns the current value of the CLAIM bits.Writing a 1 to one of these bits clears the corresponding CLAIM bit to 0. This is an indirect write to the CLAIM bits.A single write operation can clear multiple bits to 0. Writing 0 to one of these bits has no effect.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGCLAIMSET_EL1</spirit:name>
          <spirit:description>Debug Claim Tag Set Register</spirit:description>
          <spirit:addressOffset>0xFA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000FF</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: DBGCLAIMSET_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGCLAIMSET_EL1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RAZ/SBZ. Software can rely on these bits reading as zero, and must use a should-be-zero policy on writes. Implementations must ignore writes.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIM</spirit:name>
            <spirit:displayName>CLAIM</spirit:displayName>
            <spirit:description>Claim set bits. RAO.Writing a 1 to one of these bits sets the corresponding CLAIM bit to 1. This is an indirect write to the CLAIM bits.A single write operation can set multiple bits to 1. Writing 0 to one of these bits has no effect.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGDTRRX_EL0</spirit:name>
          <spirit:description>Debug Data Transfer Register Receive</spirit:description>
          <spirit:addressOffset>0x080</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGDTRRX_EL0 -->
          <spirit:field>
            <spirit:name>DBGDTRRX_EL0</spirit:name>
            <spirit:displayName>DBGDTRRX_EL0</spirit:displayName>
            <spirit:description>Update DTRRX. Writes to this register update the value in DTRRX and set RXfull to 1.Reads of this register return the last value written to DTRRX and do not change RXfull.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGDTRTX_EL0</spirit:name>
          <spirit:description>Debug Data Transfer Register Transmit</spirit:description>
          <spirit:addressOffset>0x08C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGDTRTX_EL0 -->
          <spirit:field>
            <spirit:name>DBGDTRTX_EL0</spirit:name>
            <spirit:displayName>DBGDTRTX_EL0</spirit:displayName>
            <spirit:description>Return DTRTX. Reads of this register return the value in DTRTX and clear TXfull to 0.Writes of this register update the value in DTRTX and do not change TXfull.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR0_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 0</spirit:description>
          <spirit:addressOffset>0x808</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR0_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR0_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR0_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR1_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 1</spirit:description>
          <spirit:addressOffset>0x818</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR1_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR1_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR1_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR2_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 2</spirit:description>
          <spirit:addressOffset>0x828</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR2_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR2_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR2_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR3_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 3</spirit:description>
          <spirit:addressOffset>0x838</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR3_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR3_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR3_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR0_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 0</spirit:description>
          <spirit:addressOffset>0x800</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR0_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR0_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 0</spirit:description>
          <spirit:addressOffset>0x804</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR1_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 1</spirit:description>
          <spirit:addressOffset>0x810</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR1_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR1_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 1</spirit:description>
          <spirit:addressOffset>0x814</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR2_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 2</spirit:description>
          <spirit:addressOffset>0x820</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR2_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR2_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR2_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 2</spirit:description>
          <spirit:addressOffset>0x824</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR2_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR3_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 3</spirit:description>
          <spirit:addressOffset>0x830</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR3_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR3_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR3_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 3</spirit:description>
          <spirit:addressOffset>0x834</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR3_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDACR</spirit:name>
          <spirit:description>External Debug Auxiliary Control Register</spirit:description>
          <spirit:addressOffset>0x094</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: EDACR -->
          <spirit:field>
            <spirit:name>RES0_EDACR_31_0</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR0</spirit:name>
          <spirit:description>External Debug Component Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR1</spirit:name>
          <spirit:description>External Debug Component Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR1 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, debug component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR2</spirit:name>
          <spirit:description>External Debug Component Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR3</spirit:name>
          <spirit:description>External Debug Component Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR3 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDSR</spirit:name>
          <spirit:description>External Debug Context ID Sample Register</spirit:description>
          <spirit:addressOffset>0x0A4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDCIDSR -->
          <spirit:field>
            <spirit:name>CONTEXTIDR</spirit:name>
            <spirit:displayName>CONTEXTIDR</spirit:displayName>
            <spirit:description>The sampled value of CONTEXTIDR_EL1, captured on reading the low half of EDPCSR.If EL3 is implemented and using AArch32 then CONTEXTIDR is a Banked register, and EDCIDSR samples the current Banked copy of CONTEXTIDR.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVAFF0</spirit:name>
          <spirit:description>External Debug Device Affinity Register 0</spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000002</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVAFF0 -->
          <spirit:field>
            <spirit:name>EDDEVAFF0</spirit:name>
            <spirit:displayName>EDDEVAFF0</spirit:displayName>
            <spirit:description>MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVAFF1</spirit:name>
          <spirit:description>External Debug Device Affinity Register 1</spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVAFF1 -->
          <spirit:field>
            <spirit:name>EDDEVAFF1</spirit:name>
            <spirit:displayName>EDDEVAFF1</spirit:displayName>
            <spirit:description>MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVARCH</spirit:name>
          <spirit:description>External Debug Device Architecture Register</spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47706A15</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For debug, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For debug, the revision defined by v8-A is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For debug:Bits [15:12] are the architecture version, 0x6.Bits [11:0] are the architecture part number, 0xA15.This corresponds to debug architecture version v8-A.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVID</spirit:name>
          <spirit:description>External Debug Device ID Register 0</spirit:description>
          <spirit:addressOffset>0xFC8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVID -->
          <spirit:field>
            <spirit:name>RES0_EDDEVID_31_28</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AuxRegs</spirit:name>
            <spirit:displayName>AuxRegs</spirit:displayName>
            <spirit:description>Indicates support for Auxiliary registers. Permitted values for this field are:
      0000
      
      None supported.
      
      
    
      0001
      
      Support for External Debug Auxiliary Control Register, EDACR.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDDEVID_23_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PCSample</spirit:name>
            <spirit:displayName>PCSample</spirit:displayName>
            <spirit:description>Indicates the level of Sample-based profiling support using external debug registers 40 through 43. Permitted values of this field in v8-A are:
      0000
      
      Architecture-defined form of Sample-based profiling not implemented.
      
      
    
      0010
      
      EDPCSR and EDCIDSR are implemented (only permitted if EL3 and EL2 are not implemented).
      
      
    
      0011
      
      EDPCSR, EDCIDSR, and EDVIDSR are implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVID1</spirit:name>
          <spirit:description>External Debug Device ID Register 1</spirit:description>
          <spirit:addressOffset>0xFC4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000002</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVID1 -->
          <spirit:field>
            <spirit:name>RES0_EDDEVID1_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PCSROffset</spirit:name>
            <spirit:displayName>PCSROffset</spirit:displayName>
            <spirit:description>This field indicates the offset applied to PC samples returned by reads of EDPCSR. Permitted values of this field in v8-A are:
      0000
      
      EDPCSR not implemented.
      
      
    
      0010
      
      EDPCSR implemented, and samples have no offset applied and do not sample the instruction set state in AArch32 state.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVID2</spirit:name>
          <spirit:description>External Debug Device ID Register 2</spirit:description>
          <spirit:addressOffset>0xFC0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVID2 -->
          <spirit:field>
            <spirit:name>RES0_EDDEVID2_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVTYPE</spirit:name>
          <spirit:description>External Debug Device Type Register</spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000015</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_EDDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Subtype. Must read as 0x1 to indicate this is a processor component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAJOR</spirit:name>
            <spirit:displayName>MAJOR</spirit:displayName>
            <spirit:description>Major type. Must read as 0x5 to indicate this is a debug logic component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDECCR</spirit:name>
          <spirit:description>External Debug Exception Catch Control Register</spirit:description>
          <spirit:addressOffset>0x098</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDECCR -->
          <spirit:field>
            <spirit:name>RES0_EDECCR_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSE</spirit:name>
            <spirit:displayName>NSE</spirit:displayName>
            <spirit:description>Coarse-grained Non-secure exception catch. Possible values of this field are:
      0000
      
      Exception catch debug event disabled for Non-secure exception levels.
      
      
    
      0010
      
      Exception catch debug event enabled for Non-secure EL1.
      
      
    
      0100
      
      Exception catch debug event enabled for Non-secure EL2.
      
      
    
      0110
      
      Exception catch debug event enabled for Non-secure EL1 and EL2.
      
      
    All other values are reserved. Bits [7,4] are reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SE</spirit:name>
            <spirit:displayName>SE</spirit:displayName>
            <spirit:description>Coarse-grained Secure exception catch. Possible values of this field are:
      0000
      
      Exception catch debug event disabled for Secure exception levels.
      
      
    
      0010
      
      Exception catch debug event enabled for Secure EL1.
      
      
    
      1000
      
      Exception catch debug event enabled for Secure EL3.
      
      
    
      1010
      
      Exception catch debug event enabled for Secure EL1 and EL3.
      
      
    All other values are reserved. Bits [2,0] are reserved. RES0. Ignored if ExternalSecureInvasiveDebugEnabled() == FALSE.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDECR</spirit:name>
          <spirit:description>External Debug Execution Control Register</spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDECR -->
          <spirit:field>
            <spirit:name>RES0_EDECR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SS</spirit:name>
            <spirit:displayName>SS</spirit:displayName>
            <spirit:description>Halting step enable. Possible values of this field are:
      0
      
      Halting step debug event disabled.
      
      
    
      1
      
      Halting step debug event enabled.
      
      
    If the value of EDECR.SS is changed when the processor is in Non-debug state, the resulting value of EDECR.SS is UNKNOWN.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RCE</spirit:name>
            <spirit:displayName>RCE</spirit:displayName>
            <spirit:description>Reset catch enable. Possible values of this field are:
      0
      
      Reset catch debug event disabled.
      
      
    
      1
      
      Reset catch debug event enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSUCE</spirit:name>
            <spirit:displayName>OSUCE</spirit:displayName>
            <spirit:description>OS unlock catch enabled. Possible values of this field are:
      0
      
      OS unlock catch debug event disabled.
      
      
    
      1
      
      OS unlock catch debug event enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDESR</spirit:name>
          <spirit:description>External Debug Event Status Register</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF9</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDESR -->
          <spirit:field>
            <spirit:name>RES0_EDESR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SS</spirit:name>
            <spirit:displayName>SS</spirit:displayName>
            <spirit:description>Halting step debug event pending. Possible values of this field are:
      0
      
      Reading this means that a Halting step debug event is not pending. Writing this means no action.
      
      
    
      1
      
      Reading this means that a Halting step debug event is pending. Writing this clears the pending Halting step debug event.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RC</spirit:name>
            <spirit:displayName>RC</spirit:displayName>
            <spirit:description>Reset catch debug event pending. Possible values of this field are:
      0
      
      Reading this means that a Reset catch debug event is not pending. Writing this means no action.
      
      
    
      1
      
      Reading this means that a Reset catch debug event is pending. Writing this clears the pending Reset catch debug event.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSUC</spirit:name>
            <spirit:displayName>OSUC</spirit:displayName>
            <spirit:description>OS unlock debug event pending. Possible values of this field are:
      0
      
      Reading this means that an OS unlock catch debug event is not pending. Writing this means no action.
      
      
    
      1
      
      Reading this means that an OS unlock catch debug event is pending. Writing this clears the pending OS unlock catch debug event.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDITCTRL</spirit:name>
          <spirit:description>External Debug Integration mode Control Register</spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDITCTRL -->
          <spirit:field>
            <spirit:name>RES0_EDITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IME</spirit:name>
            <spirit:displayName>IME</spirit:displayName>
            <spirit:description>Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.
      0
      
      Normal operation.
      
      
    
      1
      
      Integration mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDITR</spirit:name>
          <spirit:description>External Debug Instruction Transfer Register</spirit:description>
          <spirit:addressOffset>0x084</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: EDITR -->
          <spirit:field>
            <spirit:name>EDITR</spirit:name>
            <spirit:displayName>EDITR</spirit:displayName>
            <spirit:description>Used in Debug state for passing instructions to the processor for execution</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDLAR</spirit:name>
          <spirit:description>External Debug Lock Access Register</spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: EDLAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDLSR</spirit:name>
          <spirit:description>External Debug Lock Status Register</spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF8</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDLSR -->
          <spirit:field>
            <spirit:name>RES0_EDLSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:
      0
      
      Software lock not implemented or not memory-mapped access.
      
      
    
      1
      
      Software lock implemented and memory-mapped access.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPCSR_31:0</spirit:name>
          <spirit:description>External Debug Program Counter Sample Register (low word)</spirit:description>
          <spirit:addressOffset>0x0A0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDPCSR_31:0 -->
          <spirit:field>
            <spirit:name>EDPCSR_31:0</spirit:name>
            <spirit:displayName>EDPCSR_31:0</spirit:displayName>
            <spirit:description>PC Sample low word, EDPCSRlo. Bits [31:0] of the sampled instruction address value. Reading EDPCSRlo has the side-effect of updating EDCIDSR, EDVIDSR, and EDPCSRhi. However:If the processor is in Debug state, or Sample-based profiling is prohibited, EDPCSRlo reads as 0xFFFFFFFF and EDCIDSR, EDVIDSR, and EDPCSRhi become UNKNOWN.If the processor is in Reset state, the sampled value is unknown and EDCIDSR, EDVIDSR and EDPCSRhi become UNKNOWN.If no instruction has been retired since the processor left Reset state, Debug state, or a state where Non-invasive debug is not permitted, the sampled value is UNKNOWN and EDCIDSR, EDVIDSR, and EDPCSRhi become UNKNOWN.For a read of EDPCSRlo from the memory-mapped interface, if EDLSR.SLK == 1, meaning the Software Lock is locked, then the access has no side-effects. That is, EDCIDSR, EDVIDSR, and EDPCSRhi are unchanged.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPCSR_63:32</spirit:name>
          <spirit:description>External Debug Program Counter Sample Register (high word)</spirit:description>
          <spirit:addressOffset>0x0AC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDPCSR_63:32 -->
          <spirit:field>
            <spirit:name>EDPCSR_63:32</spirit:name>
            <spirit:displayName>EDPCSR_63:32</spirit:displayName>
            <spirit:description>PC Sample high word, EDPCSRhi. If EDVIDSR.HV == 0 then this field is RAZ, otherwise bits [63:32] of the sampled PC.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR0</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, least significant byte.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR1</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000BD</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, most significant nibble.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR2</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Part major revision. Parts can also use this field to extend Part number to 16-bits.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR3</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>Part minor revision. Parts using EDPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR4</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 4</spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPRCR</spirit:name>
          <spirit:description>External Debug Power/Reset Control Register</spirit:description>
          <spirit:addressOffset>0x310</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF6</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPRCR -->
          <spirit:field>
            <spirit:name>RES0_EDPRCR_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COREPURQ</spirit:name>
            <spirit:displayName>COREPURQ</spirit:displayName>
            <spirit:description>Core powerup request. Allows a debugger to request that the power controller power up the core, enabling access to the debug register in the Core power domain. The actions on writing to this bit are:
      0
      
      No effect.
      
      
    
      1
      
      Request the power controller to powerup the core.
      
      
    In an implementation that includes the recommended external debug interface, this bit drives the DBGPWRUPREQ signal.This bit can be read and written when the Core power domain is powered off.The power controller must not allow the Core power domain to switch off while this bit is one.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDPRCR_2_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CWRR</spirit:name>
            <spirit:displayName>CWRR</spirit:displayName>
            <spirit:description>Warm reset request. Write only bit that reads as zero. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Request Warm reset.
      
      
    The processor ignores writes to this bit if any of the following are the case:ExternalInvasiveDebugEnabled() == FALSE, EL3 is not implemented, and the processor is Non-secure.ExternalSecureInvasiveDebugEnabled() == FALSE and one of the following is true:EL3 is implemented.The processor is Secure.The Core power domain is either completely off or in a low-power state where the Core power domain registers cannot be accessed.DoubleLockStatus() == TRUE (OS Double Lock is set).OSLSR.OSLK == 1 (OS lock is locked).In an implementation that includes the recommended external debug interface, this bit drives the DBGRSTREQ signal.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CORENPDRQ</spirit:name>
            <spirit:displayName>CORENPDRQ</spirit:displayName>
            <spirit:description>Core no powerdown request. Requests emulation of powerdown. Possible values of this bit are:
      0
      
      On a powerdown request, the system powers down the Core power domain.
      
      
    
      1
      
      On a powerdown request, the system emulates powerdown of the Core power domain. In this emulation mode the Core power domain is not actually powered down.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPRSR</spirit:name>
          <spirit:description>External Debug Processor Status Register</spirit:description>
          <spirit:addressOffset>0x314</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFF543</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPRSR -->
          <spirit:field>
            <spirit:name>RES0_EDPRSR_31_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SDR</spirit:name>
            <spirit:displayName>SDR</spirit:displayName>
            <spirit:description>Sticky debug restart. Set to 1 when the processor exits Debug state and cleared to 0 following reads of EDPRSR.
      0
      
      The processor has not restarted since EDPRSR was last read.
      
      
    
      1
      
      The processor has restarted since EDPRSR was last read.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 when following a read of EDPRSR.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SPMAD</spirit:name>
            <spirit:displayName>SPMAD</spirit:displayName>
            <spirit:description>Sticky EPMAD error. Set to 1 if an access returns an error because AllowExternalPMUAccess() == FALSE.
      0
      
      No accesses to the external performance monitors registers have failed since EDPRSR was last read.
      
      
    
      1
      
      At least one access to the external performance monitors registers has failed since EDPRSR was last read.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 when following a read of EDPRSR.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EPMAD</spirit:name>
            <spirit:displayName>EPMAD</spirit:displayName>
            <spirit:description>External performance monitors access disable status.
      0
      
      External performance monitors access enabled.
      
      
    
      1
      
      External performance monitors access disabled.
      
      
    If external performance monitors access is not implemented, EPMAD is RAO. This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SDAD</spirit:name>
            <spirit:displayName>SDAD</spirit:displayName>
            <spirit:description>Sticky EDAD error. Set to 1 if an access returns an error because AllowExternalDebugAccess() == FALSE.
      0
      
      No accesses to the external debug registers have failed since EDPRSR was last read.
      
      
    
      1
      
      At least one access to the external debug registers has failed since EDPRSR was last read.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 following a read of EDPRSR.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EDAD</spirit:name>
            <spirit:displayName>EDAD</spirit:displayName>
            <spirit:description>External debug access disable status.
      0
      
      External debug access enabled.
      
      
    
      1
      
      External debug access disabled.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DLK</spirit:name>
            <spirit:displayName>DLK</spirit:displayName>
            <spirit:description>OS Double Lock status bit.
      0
      
      OSDLR_EL1.DLK == 0 or EDPRCR.CORENPDRQ == 1 or the processor is in Debug state.
      
      
    
      1
      
      OSDLR_EL1.DLK == 1 and EDPRCR.CORENPDRQ == 0 and the processor is in Non-debug state.
      
      
    This bit is UNKNOWN on reads if EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSLK</spirit:name>
            <spirit:displayName>OSLK</spirit:displayName>
            <spirit:description>OS lock status bit. A read of this bit returns the value of OSLSR_EL1.OSLK.This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1 or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HALTED</spirit:name>
            <spirit:displayName>HALTED</spirit:displayName>
            <spirit:description>Halted status bit. Possible values are:
      0
      
      EDSCR.STATUS is 0b000010 (processor in Non-debug state).
      
      
    
      1
      
      EDSCR.STATUS is not 0b000010.
      
      
    This bit is UNKNOWN on reads if EDPRSR.PU is 0. </spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SR</spirit:name>
            <spirit:displayName>SR</spirit:displayName>
            <spirit:description>Sticky core reset status bit. Possible values are:
      0
      
      The non-debug logic of the processor is not in reset state and has not been reset since the last time EDPRSR was read.
      
      
    
      1
      
      The non-debug logic of the processor is in reset state or has been reset since the last time EDPRSR was read.
      
      
    This bit is UNKNOWN on reads if EDPRSR.DLK is 1 or EDPRSR.PU is 0.This bit clears to 0 following a read of EDPRSR if the non-debug logic of the processor is not in reset state.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>R</spirit:name>
            <spirit:displayName>R</spirit:displayName>
            <spirit:description>Core reset status bit. Possible values are:
      0
      
      The non-debug logic of the processor is not in reset state.
      
      
    
      1
      
      The non-debug logic of the processor is in reset state.
      
      
    This bit is UNKNOWN on reads if either EDPRSR.DLK is 1 or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SPD</spirit:name>
            <spirit:displayName>SPD</spirit:displayName>
            <spirit:description>Sticky core power-down status bit.This bit is set to 1 on Cold reset to indicate the state of the debug registers has been lost. Since a Cold reset is required on powering up the processor, this usually indicates the Core power domain has been completely powered off.Possible values are:
      0
      
      If the Core power domain is off (EDPRSR.PU is 0), it is not known whether the state of the debug registers in the Core power domain is lost. Otherwise, the Core power domain is on, and the state of the debug registers in the Core power domain has not been lost.
      
      
    
      1
      
      The state of the debug registers in the Core power domain is lost.
      
      
    This bit is UNKNOWN on reads if both EDPRSR.DLK and EDPRSR.PU are 1.This bit clears to 0 following a read of EDPRSR if the processor is not in the powered down state. There are two logical power off states for the Core power domain:RetentionThe states of the debug registers, including EDPRSR.SPD, in the Core power domain is preserved, and restored on leaving retention state.Power-downThe states of the debug registers in the Core power domain is lost, and a Cold reset is asserted on leaving power-down state.In these states, it is IMPLEMENTATION DEFINED whether:EDPRSR.SPD shows whether the state of the debug registers in the Core power domain has been lost since the last time EDPRSR was read when the Core power domain was on.EDPRSR.SPD reads-as-zero.EDPRSR.SPD is not cleared following a read of EDPRSR in these states.This means it is IMPLEMENTATION DEFINED whether a processor implements EDPRSR.SPD as:Fixed RAZ when in one or both of the retention and power-down states.Retaining its previous value when in the retention state.Fixed RAO in the power-down state.Note that this definition does not allow EDPRSR.SPD to be fixed RAO in the low-power retention state, as the state of the debug registers in the Core power domain is not lost by entering this state. However, the bit can be read as 1 in this state if the state of the registers was lost before entering this state (i.e. EDPRSR has not been read since the last Cold reset).ARM recommends that an implementation make EDPRSR.SPD fixed RAO when in the power-down state, particularly if it does not support a low-power retention state.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PU</spirit:name>
            <spirit:displayName>PU</spirit:displayName>
            <spirit:description>Core power-up status bit. Indicates whether the Core power domain debug registers can be accessed:
      0
      
      Core is in a low-power or power-down state where the debug registers cannot be accessed.
      
      
    
      1
      
      Core is in a power-up state where the debug registers can be accessed.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDRCR</spirit:name>
          <spirit:description>External Debug Reserve Control Register</spirit:description>
          <spirit:addressOffset>0x090</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDRCR -->
          <spirit:field>
            <spirit:name>RES0_EDRCR_31_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>27</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CBRRQ</spirit:name>
            <spirit:displayName>CBRRQ</spirit:displayName>
            <spirit:description>Allow imprecise entry to Debug state. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Allow imprecise entry to Debug state, for example by canceling pending bus accesses.
      
      
    Setting this bit to 1 allows a debugger to request imprecise entry to Debug state. An External Debug Request debug event must be pending before the debugger sets this bit to 1.This feature is optional. If this feature is not implemented, writes to this bit are ignored.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSPA</spirit:name>
            <spirit:displayName>CSPA</spirit:displayName>
            <spirit:description>Clear Sticky Pipeline Advance. This bit is used to clear the EDSCR.PipeAdv bit to 0. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Clear the EDSCR.PipeAdv bit to 0.
      
      
    </spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSE</spirit:name>
            <spirit:displayName>CSE</spirit:displayName>
            <spirit:description>Clear Sticky Error. Used to clear the EDSCR cumulative error bits to 0. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Clear the EDSCR.{TXU, RXO, ERR} bits, and, if the processor is in Debug state, the EDSCR.ITO bit, to 0.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDRCR_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDSCR</spirit:name>
          <spirit:description>External Debug Status and Control Register</spirit:description>
          <spirit:addressOffset>0x088</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xECFAC040</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDSCR -->
          <spirit:field>
            <spirit:name>RES0_EDSCR_31_31</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXfull</spirit:name>
            <spirit:displayName>RXfull</spirit:displayName>
            <spirit:description>DTRRX full. This bit is RO.</spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXfull</spirit:name>
            <spirit:displayName>TXfull</spirit:displayName>
            <spirit:description>DTRTX full. This bit is RO.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ITO</spirit:name>
            <spirit:displayName>ITO</spirit:displayName>
            <spirit:description>EDITR overrun. This bit is RO.If the processor is not in Debug state, this bit is UNKNOWN. ITO is set to 0 on entry to Debug state.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXO</spirit:name>
            <spirit:displayName>RXO</spirit:displayName>
            <spirit:description>DTRRX overrun. This bit is RO.</spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXU</spirit:name>
            <spirit:displayName>TXU</spirit:displayName>
            <spirit:description>DTRTX underrun. This bit is RO.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PipeAdv</spirit:name>
            <spirit:displayName>PipeAdv</spirit:displayName>
            <spirit:description>Pipeline advance. Read-only. Set to 1 every time the processor pipeline retires one or more instructions. Cleared to 0 by a write to EDRCR.CSPA.The architecture does not define precisely when this bit is set to 1. It requires only that this happen periodically in Non-debug state to indicate that software execution is progressing.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ITE</spirit:name>
            <spirit:displayName>ITE</spirit:displayName>
            <spirit:description>ITR empty. This bit is RO.If the processor is not in Debug state, this bit is UNKNOWN. It is always valid in Debug state.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INTdis</spirit:name>
            <spirit:displayName>INTdis</spirit:displayName>
            <spirit:description>Interrupt disable. Disables taking interrupts (including virtual interrupts and System Error interrupts) in Non-Debug state.If external invasive debug is disabled, the value of this field is ignored.If external invasive debug is enabled, the possible values of this field are:
      00
      
      Do not disable interrupts
      
      
    
      01
      
      Disable interrupts targeting Non-secure EL1.
      
      
    
      10
      
      Disable interrupts targeting only Non-secure EL1 and Non-secure EL2. If external secure invasive debug is enabled, also disable interrupts targeting Secure EL1.
      
      
    
      11
      
      Disable interrupts targeting only Non-secure EL1 and Non-secure EL2. If external secure invasive debug is enabled, also disable all other interrupts.
      
      
    The value of INTdis does not affect whether an interrupt is a WFI wake-up event, but can mask an interrupt as a WFE wake-up event.If EL3 and EL2 are not implemented, INTdis[0] is RO and reads the same value as INTdis[1], meaning only the values 0b00 and 0b11 can be selected.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TDA</spirit:name>
            <spirit:displayName>TDA</spirit:displayName>
            <spirit:description>Trap debug registers accesses.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MA</spirit:name>
            <spirit:displayName>MA</spirit:displayName>
            <spirit:description>Memory access mode. Controls use of memory-access mode for accessing EDITR and the DCC. This bit is ignored if in Non-debug state and set to zero on entry to Debug state.Possible values of this field are:
      0
      
      Normal access mode
      
      
    
      1
      
      Memory access mode.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDSCR_19_19</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>19</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NS</spirit:name>
            <spirit:displayName>NS</spirit:displayName>
            <spirit:description>Non-secure status. Read-only. When in Debug state, gives the current security state:
      0
      
      Secure state, IsSecure() == TRUE
      
      
    
      1
      
      Non-secure state, IsSecure() == FALSE.
      
      
    In Non-debug state, this bit is UNKNOWN.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDSCR_17_17</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SDD</spirit:name>
            <spirit:displayName>SDD</spirit:displayName>
            <spirit:description>Secure debug disabled. This bit is RO.On entry to Debug state:If entering in Secure state, SDD is set to 0.If entering in Non-secure state, SDD is set to the inverse of ExternalSecureInvasiveDebugEnabled().In Debug state, the value of the SDD bit does not change, even if ExternalSecureInvasiveDebugEnabled() changes.In Non-debug state:SDD returns the inverse of ExternalSecureInvasiveDebugEnabled(). If the authentication signals that control ExternalSecureInvasiveDebugEnabled() change, a context synchronization operation is required to guarantee their effect.This bit is unaffected by the Security state of the processor.If EL3 is not implemented and the implementation is Non-secure, this bit is RES1.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDSCR_15_15</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HDE</spirit:name>
            <spirit:displayName>HDE</spirit:displayName>
            <spirit:description>Halting debug mode enable. Possible values of this bit are:
      0
      
      Halting debug mode disabled.
      
      
    
      1
      
      Halting debug mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RW</spirit:name>
            <spirit:displayName>RW</spirit:displayName>
            <spirit:description>Exception level register-width status. Read-only. In Debug state, each bit gives the current register width status of each EL:
      1111
      
      All exception levels are AArch64 state.
      
      
    
      1110
      
      EL0 is AArch32 state. All other exception levels are AArch64 state.
      
      
    
      1100
      
      EL0 and EL1 are AArch32 state. All other exception levels are AArch64 state. Never seen if EL2 is not implemented in the current security state.
      
      
    
      1000
      
      EL0, EL1, and, if implemented in the current security state, EL2 are AArch32 state. All other exception levels are AArch64 state.
      
      
    
      0000
      
      All exception levels are set to AArch32 state (32-bit configuration).
      
      
    However:If not at EL0: RW[0] == RW[1].If EL2 is not implemented in the current security state: RW[2] == RW[1].If EL3 is not implemented: RW[3] == RW[2].In Non-debug state, this field is RAO.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL</spirit:name>
            <spirit:displayName>EL</spirit:displayName>
            <spirit:description>Exception level. Read-only. In Debug state, this gives the current EL of the processor.In Non-debug state, this field is RAZ.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>A</spirit:name>
            <spirit:displayName>A</spirit:displayName>
            <spirit:description>System Error interrupt pending. Read-only. In Debug state, indicates whether a SError interrupt is pending:If HCR_EL2.{AMO, TGE} = {1, 0} and in Non-secure EL0 or EL1, a virtual SError interrupt.Otherwise, a physical SError interrupt.
      0
      
      No SError interrupt pending.
      
      
    
      1
      
      SError interrupt pending.
      
      
    A debugger can read EDSCR to check whether a SError interrupt is pending without having to execute further instructions. A pending SError might indicate data from target memory is corrupted.UNKNOWN in Non-debug state.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERR</spirit:name>
            <spirit:displayName>ERR</spirit:displayName>
            <spirit:description>Cumulative error flag. This field is RO. It is set to 1 following exceptions in Debug state and on any signaled overrun or underrun on the DTR or EDITR.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STATUS</spirit:name>
            <spirit:displayName>STATUS</spirit:displayName>
            <spirit:description>Debug status flags. This field is RO.The possible values of this field are:
      000010
      
      Processor is in Non-debug state.
      
      
    
      000001
      
      Processor is restarting (exiting Debug state).
      
      
    
      000111
      
      Breakpoint.
      
      
    
      010011
      
      External debug request.
      
      
    
      011011
      
      Halting step, normal.
      
      
    
      011111
      
      Halting step, exclusive.
      
      
    
      100011
      
      OS unlock catch.
      
      
    
      100111
      
      Reset catch.
      
      
    
      101011
      
      Watchpoint.
      
      
    
      101111
      
      HLT instruction.
      
      
    
      110011
      
      Software access to debug register.
      
      
    
      110111
      
      Exception catch.
      
      
    
      111011
      
      Halting step, no syndrome.
      
      
    All other values of STATUS are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDVIDSR</spirit:name>
          <spirit:description>External Debug Virtual Context Sample Register</spirit:description>
          <spirit:addressOffset>0x0A8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0x0FFFFF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDVIDSR -->
          <spirit:field>
            <spirit:name>NS</spirit:name>
            <spirit:displayName>NS</spirit:displayName>
            <spirit:description>Non-secure state sample. Indicates the security state associated with the most recent EDPCSR sample.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E2</spirit:name>
            <spirit:displayName>E2</spirit:displayName>
            <spirit:description>Exception level 2 status sample. Indicates whether the most recent EDPCSR sample was associated with EL2. If EDVIDSR.NS == 0, this bit is 0.</spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E3</spirit:name>
            <spirit:displayName>E3</spirit:displayName>
            <spirit:description>Exception level 3 status sample. Indicates whether the most recent EDPCSR sample was associated with AArch64 EL3. If EDVIDSR.NS == 1 or the processor was in AArch32 state when EDPCSR was read, this bit is 0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HV</spirit:name>
            <spirit:displayName>HV</spirit:displayName>
            <spirit:description>EDPCSR high half valid. Indicates whether bits [63:32] of the most recent EDPCSR sample are valid. If EDVIDSR.HV == 0, the value of EDPCSR[63:32] is RAZ.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDVIDSR_27_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VMID</spirit:name>
            <spirit:displayName>VMID</spirit:displayName>
            <spirit:description>VMID sample. The value of VTTBR_EL2.VMID associated with the most recent EDPCSR sample. If EDVIDSR.NS == 0 or EDVIDSR.E2 == 1, this field is RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDWAR_31:0</spirit:name>
          <spirit:description>External Debug Watchpoint Address Register (low word)</spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDWAR_31:0 -->
          <spirit:field>
            <spirit:name>EDWAR_31:0</spirit:name>
            <spirit:displayName>EDWAR_31:0</spirit:displayName>
            <spirit:description>Watchpoint address. The virtual data address being accessed when a watchpoint debug event was triggered and caused entry to Debug state.UNKNOWN if the processor is not in Debug state, or if Debug state was entered other than for a watchpoint debug event.The address must be within a naturally-aligned block of memory of power-of-two size no larger than the DC ZVA block size.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDWAR_63:32</spirit:name>
          <spirit:description>External Debug Watchpoint Address Register (high word)</spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDWAR_63:32 -->
          <spirit:field>
            <spirit:name>EDWAR_63:32</spirit:name>
            <spirit:displayName>EDWAR_63:32</spirit:displayName>
            <spirit:description>Watchpoint address. The virtual data address being accessed when a watchpoint debug event was triggered and caused entry to Debug state.UNKNOWN if the processor is not in Debug state, or if Debug state was entered other than for a watchpoint debug event.The address must be within a naturally-aligned block of memory of power-of-two size no larger than the DC ZVA block size.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR0_EL1_31:0</spirit:name>
          <spirit:description>Debug Feature Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD28</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x10305106</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>CTX_CMPs</spirit:name>
            <spirit:displayName>CTX_CMPs</spirit:displayName>
            <spirit:description>Number of breakpoints that are context-aware, minus 1. These are the highest numbered breakpoints.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR0_EL1_31:0_27_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WRPs</spirit:name>
            <spirit:displayName>WRPs</spirit:displayName>
            <spirit:description>Number of watchpoints, minus 1. The value of 0b0000 is reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR0_EL1_31:0_19_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BRPs</spirit:name>
            <spirit:displayName>BRPs</spirit:displayName>
            <spirit:description>Number of breakpoints, minus 1. The value of 0b0000 is reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMUVer</spirit:name>
            <spirit:displayName>PMUVer</spirit:displayName>
            <spirit:description>Performance Monitors extension version. Indicates whether system register interface to Performance Monitors extension is implemented. Permitted values are:
      0000
      
      Performance Monitors extension system registers not implemented.
      
      
    
      0001
      
      Performance Monitors extension system registers implemented, PMUv3.
      
      
    
      1111
      
      IMPLEMENTATION DEFINED form of performance monitors supported, PMUv3 not supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TraceVer</spirit:name>
            <spirit:displayName>TraceVer</spirit:displayName>
            <spirit:description>Trace extension. Indicates whether system register interface to Trace extension is implemented. Permitted values are:
      0000
      
      Trace extension system registers not implemented.
      
      
    
      0001
      
      Trace extension system registers implemented.
      
      
    All other values are reserved.A value of 0b0000 only indicates that no system register interface to the trace extension is implemented. A trace extension may nevertheless be implemented without a system register interface.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DebugVer</spirit:name>
            <spirit:displayName>DebugVer</spirit:displayName>
            <spirit:description>Debug architecture version. Indicates presence of v8-A debug architecture.
      0110
      
      v8-A debug architecture.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR0_EL1_63:32</spirit:name>
          <spirit:description>Debug Feature Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD2C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR1_EL1_31:0</spirit:name>
          <spirit:description>Auxiliary Feature Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD48</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR1_EL1_63:32</spirit:name>
          <spirit:description>Auxiliary Feature Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD4C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR0_EL1_31:0</spirit:name>
          <spirit:description>Instruction Set Attribute Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD30</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="immediate">65536</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR0_EL1_31:0_31_20</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRC32</spirit:name>
            <spirit:displayName>CRC32</spirit:displayName>
            <spirit:description>CRC32 instructions in AArch64. Possible values of this field are:
      0000
      
      No CRC32 instructions implemented.
      
      
    
      0001
      
      CRC32B, CRC32H, CRC32W, CRC32X, CRC32CB, CRC32CH, CRC32CW, and CRC32CX instructions implemented.
      
      
    All other values are reserved.This field must have the same value as ID_ISAR5.CRC32. The architecture requires that if CRC32 is supported in one Execution state, it must be supported in both Execution states.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SHA2</spirit:name>
            <spirit:displayName>SHA2</spirit:displayName>
            <spirit:description>SHA2 instructions in AArch64. Possible values of this field are:
      0000
      
      No SHA2 instructions implemented.
      
      
    
      0001
      
      SHA256H, SHA256H2, SHA256SU0, and SHA256SU1 instructions implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SHA1</spirit:name>
            <spirit:displayName>SHA1</spirit:displayName>
            <spirit:description>SHA1 instructions in AArch64. Possible values of this field are:
      0000
      
      No SHA1 instructions implemented.
      
      
    
      0001
      
      SHA1C, SHA1P, SHA1M, SHA1H, SHA1SU0, and SHA1SU1 instructions implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AES</spirit:name>
            <spirit:displayName>AES</spirit:displayName>
            <spirit:description>AES instructions in AArch64. Possible values of this field are:
      0000
      
      No AES instructions implemented.
      
      
    
      0001
      
      AESE, AESD, AESMC, and AESIMC instructions implemented.
      
      
    
      0010
      
      As for 0b0001, plus PMULL/PMULL2 instructions operating on 64-bit data quantities.
      
      
    </spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR0_EL1_31:0_3_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR0_EL1_63:32</spirit:name>
          <spirit:description>Instruction Set Attribute Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD34</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR1_EL1_31:0</spirit:name>
          <spirit:description>Instruction Set Attribute Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD50</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR1_EL1_63:32</spirit:name>
          <spirit:description>Instruction Set Attribute Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD54</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR0_EL1_31:0</spirit:name>
          <spirit:description>Memory Model Feature Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD38</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00001122</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>TGran4</spirit:name>
            <spirit:displayName>TGran4</spirit:displayName>
            <spirit:description>Support for 4 Kbyte memory translation granule size. Permitted values are:
      0000
      
      4 KB granule supported.
      
      
    
      1111
      
      4 KB granule not supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGran64</spirit:name>
            <spirit:displayName>TGran64</spirit:displayName>
            <spirit:description>Support for 64 Kbyte memory translation granule size. Permitted values are:
      0000
      
      64 KB granule supported.
      
      
    
      1111
      
      64 KB granule not supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGran16</spirit:name>
            <spirit:displayName>TGran16</spirit:displayName>
            <spirit:description>Support for 16 Kbyte memory translation granule size. Permitted values are:
      0000
      
      16 KB granule not supported.
      
      
    
      0001
      
      16 KB granule supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BigEndEL0</spirit:name>
            <spirit:displayName>BigEndEL0</spirit:displayName>
            <spirit:description>Mixed-endian support at EL0 only. Permitted values are:
      0000
      
      No mixed-endian support at EL0. The SCTLR_EL1.E0E bit has a fixed value.
      
      
    
      0001
      
      Mixed-endian support at EL0. The SCTLR_EL1.E0E bit can be configured.
      
      
    All other values are reserved.This field is invalid and is RES0 if the BigEnd field, bits [11:8], is not 0b0000.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNSMem</spirit:name>
            <spirit:displayName>SNSMem</spirit:displayName>
            <spirit:description>Secure versus Non-secure Memory distinction. Permitted values are:
      0000
      
      Does not support a distinction between Secure and Non-secure Memory.
      
      
    
      0001
      
      Does support a distinction between Secure and Non-secure Memory.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BigEnd</spirit:name>
            <spirit:displayName>BigEnd</spirit:displayName>
            <spirit:description>Mixed-endian configuration support. Permitted values are:
      0000
      
      No mixed-endian support. The SCTLR_ELx.EE bits have a fixed value. See the BigEndEL0 field, bits[19:16], for whether EL0 supports mixed-endian.
      
      
    
      0001
      
      Mixed-endian support. The SCTLR_ELx.EE and SCTLR_EL1.E0E bits can be configured.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ASIDBits</spirit:name>
            <spirit:displayName>ASIDBits</spirit:displayName>
            <spirit:description>Number of ASID bits. Permitted values are:
      0000
      
      8 bits.
      
      
    
      0010
      
      16 bits.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PARange</spirit:name>
            <spirit:displayName>PARange</spirit:displayName>
            <spirit:description>Physical Address range supported. Permitted values are:
      0000
      
      32 bits, 4 GB.
      
      
    
      0001
      
      36 bits, 64 GB.
      
      
    
      0010
      
      40 bits, 1 TB.
      
      
    
      0011
      
      42 bits, 4 TB.
      
      
    
      0100
      
      44 bits, 16 TB.
      
      
    
      0101
      
      48 bits, 256 TB.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR0_EL1_63:32</spirit:name>
          <spirit:description>Memory Model Feature Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD3C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64MMFR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR1_EL1_31:0</spirit:name>
          <spirit:description>Memory Model Feature Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD58</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64MMFR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR1_EL1_63:32</spirit:name>
          <spirit:description>Memory Model Feature Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD5C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64MMFR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR0_EL1_31:0</spirit:name>
          <spirit:description>Processor Feature Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD20</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="immediate">16785954</spirit:value>
            <spirit:mask>0xF0FFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR0_EL1_31:0_31_28</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GIC</spirit:name>
            <spirit:displayName>GIC</spirit:displayName>
            <spirit:description>GIC system register interface. Permitted values are:
      0000
      
      No GIC system registers are supported.
      
      
    
      0001
      
      GICv3 system registers are supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AdvSIMD</spirit:name>
            <spirit:displayName>AdvSIMD</spirit:displayName>
            <spirit:description>Advanced SIMD. Permitted values are:
      0000
      
      Advanced SIMD is implemented.
      
      
    
      1111
      
      Advanced SIMD is not implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>FP</spirit:name>
            <spirit:displayName>FP</spirit:displayName>
            <spirit:description>Floating-point. Permitted values are:
      0000
      
      Floating-point is implemented.
      
      
    
      1111
      
      Floating-point is not implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL3</spirit:name>
            <spirit:displayName>EL3</spirit:displayName>
            <spirit:description>EL3 exception level handling. Permitted values are:
      0000
      
      EL3 is not implemented.
      
      
    
      0001
      
      EL3 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL3 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL2</spirit:name>
            <spirit:displayName>EL2</spirit:displayName>
            <spirit:description>EL2 exception level handling. Permitted values are:
      0000
      
      EL2 is not implemented.
      
      
    
      0001
      
      EL2 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL2 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL1</spirit:name>
            <spirit:displayName>EL1</spirit:displayName>
            <spirit:description>EL1 exception level handling. Permitted values are:
      0000
      
      EL1 is not implemented.
      
      
    
      0001
      
      EL1 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL1 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL0</spirit:name>
            <spirit:displayName>EL0</spirit:displayName>
            <spirit:description>EL0 exception level handling. Permitted values are:
      0000
      
      EL0 is not implemented.
      
      
    
      0001
      
      EL0 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL0 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR0_EL1_63:32</spirit:name>
          <spirit:description>Processor Feature Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD24</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR1_EL1_31:0</spirit:name>
          <spirit:description>Processor Feature Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD40</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR1_EL1_63:32</spirit:name>
          <spirit:description>Processor Feature Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD44</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>MIDR_EL1</spirit:name>
          <spirit:description>Main ID Register</spirit:description>
          <spirit:addressOffset>0xD00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x410FD034</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: MIDR_EL1 -->
          <spirit:field>
            <spirit:name>Implementer</spirit:name>
            <spirit:displayName>Implementer</spirit:displayName>
            <spirit:description>The Implementer code. This field must hold an implementer code that has been assigned by ARM.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>Variant</spirit:name>
            <spirit:displayName>Variant</spirit:displayName>
            <spirit:description>An IMPLEMENTATION DEFINED variant number. Typically this field is used to distinguish between different product variants or major revisions of a product.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>Architecture</spirit:name>
            <spirit:displayName>Architecture</spirit:displayName>
            <spirit:description> </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PartNum</spirit:name>
            <spirit:displayName>PartNum</spirit:displayName>
            <spirit:description>An IMPLEMENTATION DEFINED primary part number for the device. On processors implemented by ARM if the top four bits of the primary part number are 0x0 or 0x7 the variant and architecture are encoded differently</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>Revision</spirit:name>
            <spirit:displayName>Revision</spirit:displayName>
            <spirit:description>An IMPLEMENTATION DEFINED revision number for the device</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>OSLAR_EL1</spirit:name>
          <spirit:description>OS Lock Access Register</spirit:description>
          <spirit:addressOffset>0x300</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFE</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: OSLAR_EL1 -->
          <spirit:field>
            <spirit:name>RES0_OSLAR_EL1_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSLK</spirit:name>
            <spirit:displayName>OSLK</spirit:displayName>
            <spirit:description>On writes to OSLAR_EL1, bit[0] is copied to the OS lock.Use EDPRSR.OSLK to check the current status of the lock.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_PMU_CPU0</spirit:name>
        <spirit:displayName>APBADDR_PMU_0</spirit:displayName>
        <spirit:description>APBADDR_PMU_0</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">196608</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_PMU_CPU0>  -->
        <spirit:register>
          <spirit:name>PMAUTHSTATUS</spirit:name>
          <spirit:description>Performance Monitors Authentication Status Register</spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000088</spirit:value>
            <spirit:mask>0xFFFFFFBB</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMAUTHSTATUS -->
          <spirit:field>
            <spirit:name>RES0_PMAUTHSTATUS_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNID</spirit:name>
            <spirit:displayName>SNID</spirit:displayName>
            <spirit:description>Holds the same value as DBGAUTHSTATUS_EL1.SNID.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMAUTHSTATUS_5_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>Holds the same value as DBGAUTHSTATUS_EL1.NSNID.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMAUTHSTATUS_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCCFILTR_EL0</spirit:name>
          <spirit:description>Performance Monitors Cycle Counter Filter Register</spirit:description>
          <spirit:addressOffset>0x47C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCCFILTR_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count cycles in EL1.
      
      
    
      1
      
      Do not count cycles in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count cycles in EL0.
      
      
    
      1
      
      Do not count cycles in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, cycles in Non-secure EL1 are counted.Otherwise, cycles in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, cycles in Non-secure EL0 are counted.Otherwise, cycles in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count cycles in EL2.
      
      
    
      1
      
      Count cycles in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, cycles in Secure EL3 are counted.Otherwise, cycles in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMCCFILTR_EL0_25_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>26</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCCNTR_EL0_31:0</spirit:name>
          <spirit:description>Performance Monitors Cycle Counter (low word)</spirit:description>
          <spirit:addressOffset>0x0F8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCCNTR_EL0_31:0 -->
          <spirit:field>
            <spirit:name>CCNT</spirit:name>
            <spirit:displayName>CCNT</spirit:displayName>
            <spirit:description>Cycle count. Depending on the values of PMCR_EL0.{LC,D}, the cycle count increments in one of the following ways:Every processor clock cycle.Every 64th processor clock cycle.The cycle count can be reset to zero by writing 1 to PMCR_EL0.C.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCCNTR_EL0_63:32</spirit:name>
          <spirit:description>Performance Monitors Cycle Counter (high word)</spirit:description>
          <spirit:addressOffset>0x0FC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCCNTR_EL0_63:32 -->
          <spirit:field>
            <spirit:name>CCNT</spirit:name>
            <spirit:displayName>CCNT</spirit:displayName>
            <spirit:description>Cycle count. Depending on the values of PMCR_EL0.{LC,D}, the cycle count increments in one of the following ways:Every processor clock cycle.Every 64th processor clock cycle.The cycle count can be reset to zero by writing 1 to PMCR_EL0.C.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCEID0_EL0</spirit:name>
          <spirit:description>Performance Monitors Common Event Identification Register 0</spirit:description>
          <spirit:addressOffset>0xE20</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="immediate">1744814079</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCEID0_EL0 -->
          <spirit:field>
            <spirit:name>CE_31:0</spirit:name>
            <spirit:displayName>CE[31:0]</spirit:displayName>
            <spirit:description>Common architectural and microarchitectural feature events that can be counted by the PMU event counters.For each bit described in the following table, the event is implemented if the bit is set to 1, or not implemented if the bit is set to 0.BitEvent numberEvent mnemonic310x01FL1D_CACHE_ALLOCATE300x01ECHAIN290x01DBUS_CYCLES280x01CTTBR_WRITE_RETIRED270x01BINST_SPEC260x01AMEMORY_ERROR250x019BUS_ACCESS240x018L2D_CACHE_WB230x017L2D_CACHE_REFILL220x016L2D_CACHE210x015L1D_CACHE_WB200x014L1I_CACHE190x013MEM_ACCESS180x012BR_PRED170x011CPU_CYCLES160x010BR_MIS_PRED150x00FUNALIGNED_LDST_RETIRED140x00EBR_RETURN_RETIRED130x00DBR_IMMED_RETIRED120x00CPC_WRITE_RETIRED110x00BCID_WRITE_RETIRED100x00AEXC_RETURN90x009EXC_TAKEN80x008INST_RETIRED70x007ST_RETIRED60x006LD_RETIRED50x005L1D_TLB_REFILL40x004L1D_CACHE30x003L1D_CACHE_REFILL20x002L1I_TLB_REFILL10x001L1I_CACHE_REFILL00x000SW_INCR</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCEID1_EL0</spirit:name>
          <spirit:description>Performance Monitors Common Event Identification Register 1</spirit:description>
          <spirit:addressOffset>0xE24</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCEID1_EL0 -->
          <spirit:field>
            <spirit:name>RES0_PMCEID1_EL0_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CE_32</spirit:name>
            <spirit:displayName>CE[32]</spirit:displayName>
            <spirit:description>Common architectural and microarchitectural feature events that can be counted by the PMU event counters.For the bit described in the following table, the event is implemented if the bit is set to 1, or not implemented if the bit is set to 0.BitEvent numberEvent mnemonic00x020L2D_CACHE_ALLOCATE</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCFGR</spirit:name>
          <spirit:description>Performance Monitors Configuration Register</spirit:description>
          <spirit:addressOffset>0xE00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0001FF06</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCFGR -->
          <spirit:field>
            <spirit:name>RES0_PMCFGR_31_20</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>UEN</spirit:name>
            <spirit:displayName>UEN</spirit:displayName>
            <spirit:description>User-mode Enable Register supported. PMUSERENR_EL0 is not visible in the external debug interface, so this bit is RES0.</spirit:description>
            <spirit:bitOffset>19</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>This feature is not supported, so this bit is RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NA</spirit:name>
            <spirit:displayName>NA</spirit:displayName>
            <spirit:description>This feature is not supported, so this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EX</spirit:name>
            <spirit:displayName>EX</spirit:displayName>
            <spirit:description>Export supported. Value is IMPLEMENTATION DEFINED.
      0
      
      PMCR_EL0.X is RES0.
      
      
    
      1
      
      PMCR_EL0.X is read/write.
      
      
    </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCD</spirit:name>
            <spirit:displayName>CCD</spirit:displayName>
            <spirit:description>Cycle counter has prescale. This is RES1 if AArch32 is supported at any EL, and RES0 otherwise.
      0
      
      PMCR_EL0.D is RES0.
      
      
    
      1
      
      PMCR_EL0.D is read/write.
      
      
    </spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CC</spirit:name>
            <spirit:displayName>CC</spirit:displayName>
            <spirit:description>Dedicated cycle counter (counter 31) supported. This bit is RES1.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of counters. This field determines the spacing of counters in the memory-map.In v8-A the counters are at doubleword-aligned addresses, and the largest counter is 64-bits, so this field is 0b111111.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>N</spirit:name>
            <spirit:displayName>N</spirit:displayName>
            <spirit:description>Number of counters implemented in addition to the cycle counter, PMCCNTR_EL0. The maximum number of event counters is 31, so bits[7:5] are always RES0.
      00000000
      
      Only PMCCNTR_EL0 implemented.
      
      
    
      00000001
      
      PMCCNTR_EL0 plus one event counter implemented.
      
      
    and so on up to 0b00011111, which indicates PMCCNTR_EL0 and 31 event counters implemented.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR0</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR1</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR1 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, debug component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR2</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR3</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR3 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCNTENCLR_EL0</spirit:name>
          <spirit:description>Performance Monitors Count Enable Clear Register</spirit:description>
          <spirit:addressOffset>0xC20</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCNTENCLR_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 disable bit. Disables the cycle counter register. Possible values are:
      0
      
      When read, means the cycle counter is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter is enabled. When written, disables the cycle counter.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter disable bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values of each bit are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; is enabled. When written, disables PMEVCNTR&lt;x&gt;.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCNTENSET_EL0</spirit:name>
          <spirit:description>Performance Monitors Count Enable Set Register</spirit:description>
          <spirit:addressOffset>0xC00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCNTENSET_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 enable bit. Enables the cycle counter register. Possible values are:
      0
      
      When read, means the cycle counter is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter is enabled. When written, enables the cycle counter.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter enable bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values of each bit are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; event counter is enabled. When written, enables PMEVCNTR&lt;x&gt;.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCR_EL0</spirit:name>
          <spirit:description>Performance Monitors Control Register</spirit:description>
          <spirit:addressOffset>0xE04</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCR_EL0 -->
          <spirit:field>
            <spirit:name>RES0_PMCR_EL0_31_11</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RAZ/WI.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>21</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMCR_EL0_10_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LC</spirit:name>
            <spirit:displayName>LC</spirit:displayName>
            <spirit:description>Long cycle counter enable. Determines which PMCCNTR_EL0 bit generates an overflow recorded by PMOVSR[31].
      0
      
      Cycle counter overflow on increment that changes PMCCNTR_EL0[31] from 1 to 0.
      
      
    
      1
      
      Cycle counter overflow on increment that changes PMCCNTR_EL0[63] from 1 to 0.
      
      
    ARM deprecates use of PMCR_EL0.LC = 0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DP</spirit:name>
            <spirit:displayName>DP</spirit:displayName>
            <spirit:description>Disable cycle counter when event counting is prohibited. The possible values of this bit are:
      0
      
      PMCCNTR_EL0, if enabled, counts when event counting is prohibited.
      
      
    
      1
      
      PMCCNTR_EL0 does not count when event counting is prohibited.
      
      
    Event counting is prohibited when ProfilingProhibited(IsSecure(),PSTATE.EL) == TRUE.This bit is RW.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>X</spirit:name>
            <spirit:displayName>X</spirit:displayName>
            <spirit:description>Enable export of events in an IMPLEMENTATION DEFINED event stream. The possible values of this bit are:
      0
      
      Do not export events.
      
      
    
      1
      
      Export events where not prohibited.
      
      
    This bit is used to permit events to be exported to another debug device, such as an OPTIONAL trace extension, over an event bus. If the implementation does not include such an event bus, this bit is RAZ/WI.This bit does not affect the generation of Performance Monitors overflow interrupt requests or signaling to a cross-trigger interface (CTI) that can be implemented as signals exported from the processor.If the implementation does not include an exported event stream, this bit is RAZ/WI. Otherwise this bit is RW.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>D</spirit:name>
            <spirit:displayName>D</spirit:displayName>
            <spirit:description>Clock divider. The possible values of this bit are:
      0
      
      When enabled, PMCCNTR_EL0 counts every clock cycle.
      
      
    
      1
      
      When enabled, PMCCNTR_EL0 counts once every 64 clock cycles.
      
      
    This bit is RW.If PMCR_EL0.LC == 1, this bit is ignored and the cycle counter counts every clock cycle.ARM deprecates use of PMCR.D = 1.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>Cycle counter reset. This bit is WO. The effects of writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Reset PMCCNTR_EL0 to zero.
      
      
    This bit is always RAZ.Resetting PMCCNTR_EL0 does not clear the PMCCNTR_EL0 overflow bit to 0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>Event counter reset. This bit is WO. The effects of writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Reset all event counters, not including PMCCNTR_EL0, to zero.
      
      
    This bit is always RAZ.Resetting the event counters does not clear any overflow bits to 0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable. The possible values of this bit are:
      0
      
      All counters, including PMCCNTR_EL0, are disabled.
      
      
    
      1
      
      All counters are enabled by PMCNTENSET_EL0.
      
      
    This bit is RW.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVAFF0</spirit:name>
          <spirit:description>Performance Monitors Device Affinity Register 0</spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000000</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMDEVAFF0 -->
          <spirit:field>
            <spirit:name>PMDEVAFF0</spirit:name>
            <spirit:displayName>PMDEVAFF0</spirit:displayName>
            <spirit:description>MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVAFF1</spirit:name>
          <spirit:description>Performance Monitors Device Affinity Register 1</spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: PMDEVAFF1 -->
          <spirit:field>
            <spirit:name>PMDEVAFF1</spirit:name>
            <spirit:displayName>PMDEVAFF1</spirit:displayName>
            <spirit:description>MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVARCH</spirit:name>
          <spirit:description>Performance Monitors Device Architecture Register</spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47702a16</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For Performance Monitors, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For Performance Monitors, the revision defined by v8-A is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For Performance Monitors:Bits [15:12] are the architecture version, 0x2.Bits [11:0] are the architecture part number, 0xA16.This corresponds to Performance Monitors architecture version PMUv3.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVTYPE</spirit:name>
          <spirit:description>Performance Monitors Device Type Register</spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000016</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_PMDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Subtype. Must read as 0x1 to indicate this is a processor component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAJOR</spirit:name>
            <spirit:displayName>MAJOR</spirit:displayName>
            <spirit:description>Major type. Must read as 0x6 to indicate this is a performance monitor component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR0_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 0</spirit:description>
          <spirit:addressOffset>0x000</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR0_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR0_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR0_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR1_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 1</spirit:description>
          <spirit:addressOffset>0x008</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR1_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR1_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR1_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR2_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 2</spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR2_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR2_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR2_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR3_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 3</spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR3_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR3_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR3_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR4_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 4</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR4_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR4_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR4_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR5_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 5</spirit:description>
          <spirit:addressOffset>0x028</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR5_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR5_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR5_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER0_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 0</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER0_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER0_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER1_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 1</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER1_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER1_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER2_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 2</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER2_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER2_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER3_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 3</spirit:description>
          <spirit:addressOffset>0x40c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER3_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER3_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER4_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 4</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER4_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER4_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER5_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 5</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER5_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER5_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMINTENCLR_EL1</spirit:name>
          <spirit:description>Performance Monitors Interrupt Enable Clear Register</spirit:description>
          <spirit:addressOffset>0xC60</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMINTENCLR_EL1 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow interrupt request disable bit. Possible values are:
      0
      
      When read, means the cycle counter overflow interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter overflow interrupt request is enabled. When written, disables the cycle count overflow interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow interrupt request disable bit for PMEVCNTR&lt;x&gt;_EL0.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values are:
      0
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is enabled. When written, disables the PMEVCNTR&lt;x&gt;_EL0 interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMINTENSET_EL1</spirit:name>
          <spirit:description>Performance Monitors Interrupt Enable Set Register</spirit:description>
          <spirit:addressOffset>0xC40</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMINTENSET_EL1 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow interrupt request enable bit. Possible values are:
      0
      
      When read, means the cycle counter overflow interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter overflow interrupt request is enabled. When written, enables the cycle count overflow interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow interrupt request enable bit for PMEVCNTR&lt;x&gt;_EL0.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values are:
      0
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is enabled. When written, enables the PMEVCNTR&lt;x&gt;_EL0 interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMITCTRL</spirit:name>
          <spirit:description>Performance Monitors Integration mode Control Register</spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMITCTRL -->
          <spirit:field>
            <spirit:name>RES0_PMITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IME</spirit:name>
            <spirit:displayName>IME</spirit:displayName>
            <spirit:description>Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.
      0
      
      Normal operation.
      
      
    
      1
      
      Integration mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMLAR</spirit:name>
          <spirit:description>Performance Monitors Lock Access Register</spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: PMLAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMLSR</spirit:name>
          <spirit:description>Performance Monitors Lock Status Register</spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMLSR -->
          <spirit:field>
            <spirit:name>RES0_PMLSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:
      0
      
      Software lock not implemented or not memory-mapped access.
      
      
    
      1
      
      Software lock implemented and memory-mapped access.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMOVSCLR_EL0</spirit:name>
          <spirit:description>Performance Monitors Overflow Flag Status Clear Register</spirit:description>
          <spirit:addressOffset>0xC80</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMOVSCLR_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow bit. Possible values are:
      0
      
      When read, means the cycle counter has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter has overflowed. When written, clears the overflow bit to 0.
      
      
    PMCR_EL0.LC is used to control from which bit of PMCCNTR_EL0 (bit 31 or bit 63) an overflow is detected.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow clear bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values of each bit are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; has overflowed. When written, clears the PMEVCNTR&lt;x&gt; overflow bit to 0.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMOVSSET_EL0</spirit:name>
          <spirit:description>Performance Monitors Overflow Flag Status Set Register</spirit:description>
          <spirit:addressOffset>0xCC0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMOVSSET_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow bit. Possible values are:
      0
      
      When read, means the cycle counter has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter has overflowed. When written, sets the overflow bit to 1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow set bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; has overflowed. When written, sets the PMEVCNTR&lt;x&gt; overflow bit to 1.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR0</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000D3</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, least significant byte.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR1</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B9</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, most significant nibble.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR2</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Part major revision. Parts can also use this field to extend Part number to 16-bits.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR3</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>Part minor revision. Parts using PMPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR4</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 4</spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR5</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 5</spirit:description>
          <spirit:addressOffset>0xFD4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR5 -->
          <spirit:field>
            <spirit:name>RESERVED_PMPIDR5_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR6</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 6</spirit:description>
          <spirit:addressOffset>0xFD8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR6 -->
          <spirit:field>
            <spirit:name>RESERVED_PMPIDR6_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR7</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 7</spirit:description>
          <spirit:addressOffset>0xFDC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR7 -->
          <spirit:field>
            <spirit:name>RESERVED_PMPIDR7_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMSWINC_EL0</spirit:name>
          <spirit:description>Performance Monitors Software Increment Register</spirit:description>
          <spirit:addressOffset>0xCA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: PMSWINC_EL0 -->
          <spirit:field>
            <spirit:name>RESERVED_PMSWINC_EL0_31_6</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>26</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P_x</spirit:displayName>
            <spirit:description>Event counter software increment bit for PMEVCNTR&lt;x&gt;</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_DBG_CPU1</spirit:name>
        <spirit:displayName>APBADDR_DBG_1</spirit:displayName>
        <spirit:description>APBADDR_DBG_1</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">1114112</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_DBG_CPU1>  -->
        <spirit:register>
          <spirit:name>DBGAUTHSTATUS_EL1</spirit:name>
          <spirit:description>Debug Authentication Status register</spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000AA</spirit:value>
            <spirit:mask>0xFFFFFFAA</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: DBGAUTHSTATUS_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGAUTHSTATUS_EL1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNID</spirit:name>
            <spirit:displayName>SNID</spirit:displayName>
            <spirit:description>Secure non-invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Non-secure.
      
      
    
      10
      
      Implemented and disabled. ExternalSecureNoninvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalSecureNoninvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SID</spirit:name>
            <spirit:displayName>SID</spirit:displayName>
            <spirit:description>Secure invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Non-secure.
      
      
    
      10
      
      Implemented and disabled. ExternalSecureInvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalSecureInvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>Non-secure non-invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Secure.
      
      
    
      10
      
      Implemented and disabled. ExternalNoninvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalNoninvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSID</spirit:name>
            <spirit:displayName>NSID</spirit:displayName>
            <spirit:description>Non-secure invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Secure.
      
      
    
      10
      
      Implemented and disabled. ExternalInvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalInvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR0_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 0</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR0_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR0_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR0_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR0_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR1_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 1</spirit:description>
          <spirit:addressOffset>0x418</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR1_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR1_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR1_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR1_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR2_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 2</spirit:description>
          <spirit:addressOffset>0x428</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR2_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR2_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR2_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR2_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR3_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 3</spirit:description>
          <spirit:addressOffset>0x438</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR3_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR3_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR3_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR3_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR4_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 4</spirit:description>
          <spirit:addressOffset>0x448</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR4_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR4_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR4_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR4_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR5_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 5</spirit:description>
          <spirit:addressOffset>0x458</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR5_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR5_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR5_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR5_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR0_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR0_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR0_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR0_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR0_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR0_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR0_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR0_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR1_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR1_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR1_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR1_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR1_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR1_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR1_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR1_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR2_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR2_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x420</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR2_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR2_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR2_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR2_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR2_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x424</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR2_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR2_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR2_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR3_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR3_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x430</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR3_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR3_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR3_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR3_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR3_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x434</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR3_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR3_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR3_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR4_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR4_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x440</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR4_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR4_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR4_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR4_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR4_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x444</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR4_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR4_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR4_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR5_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR5_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x450</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR5_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR5_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR5_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR5_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR5_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x454</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR5_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR5_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR5_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGCLAIMCLR_EL1</spirit:name>
          <spirit:description>Debug Claim Tag Clear Register</spirit:description>
          <spirit:addressOffset>0xFA4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: DBGCLAIMCLR_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGCLAIMCLR_EL1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RAZ/SBZ. Software can rely on these bits reading as zero, and must use a should-be-zero policy on writes. Implementations must ignore writes.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIM</spirit:name>
            <spirit:displayName>CLAIM</spirit:displayName>
            <spirit:description>Claim clear bits. Reading this field returns the current value of the CLAIM bits.Writing a 1 to one of these bits clears the corresponding CLAIM bit to 0. This is an indirect write to the CLAIM bits.A single write operation can clear multiple bits to 0. Writing 0 to one of these bits has no effect.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGCLAIMSET_EL1</spirit:name>
          <spirit:description>Debug Claim Tag Set Register</spirit:description>
          <spirit:addressOffset>0xFA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000FF</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: DBGCLAIMSET_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGCLAIMSET_EL1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RAZ/SBZ. Software can rely on these bits reading as zero, and must use a should-be-zero policy on writes. Implementations must ignore writes.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIM</spirit:name>
            <spirit:displayName>CLAIM</spirit:displayName>
            <spirit:description>Claim set bits. RAO.Writing a 1 to one of these bits sets the corresponding CLAIM bit to 1. This is an indirect write to the CLAIM bits.A single write operation can set multiple bits to 1. Writing 0 to one of these bits has no effect.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGDTRRX_EL0</spirit:name>
          <spirit:description>Debug Data Transfer Register Receive</spirit:description>
          <spirit:addressOffset>0x080</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGDTRRX_EL0 -->
          <spirit:field>
            <spirit:name>DBGDTRRX_EL0</spirit:name>
            <spirit:displayName>DBGDTRRX_EL0</spirit:displayName>
            <spirit:description>Update DTRRX. Writes to this register update the value in DTRRX and set RXfull to 1.Reads of this register return the last value written to DTRRX and do not change RXfull.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGDTRTX_EL0</spirit:name>
          <spirit:description>Debug Data Transfer Register Transmit</spirit:description>
          <spirit:addressOffset>0x08C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGDTRTX_EL0 -->
          <spirit:field>
            <spirit:name>DBGDTRTX_EL0</spirit:name>
            <spirit:displayName>DBGDTRTX_EL0</spirit:displayName>
            <spirit:description>Return DTRTX. Reads of this register return the value in DTRTX and clear TXfull to 0.Writes of this register update the value in DTRTX and do not change TXfull.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR0_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 0</spirit:description>
          <spirit:addressOffset>0x808</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR0_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR0_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR0_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR1_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 1</spirit:description>
          <spirit:addressOffset>0x818</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR1_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR1_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR1_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR2_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 2</spirit:description>
          <spirit:addressOffset>0x828</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR2_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR2_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR2_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR3_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 3</spirit:description>
          <spirit:addressOffset>0x838</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR3_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR3_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR3_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR0_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 0</spirit:description>
          <spirit:addressOffset>0x800</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR0_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR0_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 0</spirit:description>
          <spirit:addressOffset>0x804</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR1_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 1</spirit:description>
          <spirit:addressOffset>0x810</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR1_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR1_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 1</spirit:description>
          <spirit:addressOffset>0x814</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR2_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 2</spirit:description>
          <spirit:addressOffset>0x820</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR2_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR2_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR2_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 2</spirit:description>
          <spirit:addressOffset>0x824</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR2_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR3_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 3</spirit:description>
          <spirit:addressOffset>0x830</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR3_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR3_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR3_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 3</spirit:description>
          <spirit:addressOffset>0x834</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR3_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDACR</spirit:name>
          <spirit:description>External Debug Auxiliary Control Register</spirit:description>
          <spirit:addressOffset>0x094</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: EDACR -->
          <spirit:field>
            <spirit:name>RES0_EDACR_31_0</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR0</spirit:name>
          <spirit:description>External Debug Component Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR1</spirit:name>
          <spirit:description>External Debug Component Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR1 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, debug component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR2</spirit:name>
          <spirit:description>External Debug Component Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR3</spirit:name>
          <spirit:description>External Debug Component Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR3 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDSR</spirit:name>
          <spirit:description>External Debug Context ID Sample Register</spirit:description>
          <spirit:addressOffset>0x0A4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDCIDSR -->
          <spirit:field>
            <spirit:name>CONTEXTIDR</spirit:name>
            <spirit:displayName>CONTEXTIDR</spirit:displayName>
            <spirit:description>The sampled value of CONTEXTIDR_EL1, captured on reading the low half of EDPCSR.If EL3 is implemented and using AArch32 then CONTEXTIDR is a Banked register, and EDCIDSR samples the current Banked copy of CONTEXTIDR.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVAFF0</spirit:name>
          <spirit:description>External Debug Device Affinity Register 0</spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000001</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVAFF0 -->
          <spirit:field>
            <spirit:name>EDDEVAFF0</spirit:name>
            <spirit:displayName>EDDEVAFF0</spirit:displayName>
            <spirit:description>MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVAFF1</spirit:name>
          <spirit:description>External Debug Device Affinity Register 1</spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVAFF1 -->
          <spirit:field>
            <spirit:name>EDDEVAFF1</spirit:name>
            <spirit:displayName>EDDEVAFF1</spirit:displayName>
            <spirit:description>MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVARCH</spirit:name>
          <spirit:description>External Debug Device Architecture Register</spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47706A15</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For debug, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For debug, the revision defined by v8-A is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For debug:Bits [15:12] are the architecture version, 0x6.Bits [11:0] are the architecture part number, 0xA15.This corresponds to debug architecture version v8-A.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVID</spirit:name>
          <spirit:description>External Debug Device ID Register 0</spirit:description>
          <spirit:addressOffset>0xFC8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVID -->
          <spirit:field>
            <spirit:name>RES0_EDDEVID_31_28</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AuxRegs</spirit:name>
            <spirit:displayName>AuxRegs</spirit:displayName>
            <spirit:description>Indicates support for Auxiliary registers. Permitted values for this field are:
      0000
      
      None supported.
      
      
    
      0001
      
      Support for External Debug Auxiliary Control Register, EDACR.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDDEVID_23_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PCSample</spirit:name>
            <spirit:displayName>PCSample</spirit:displayName>
            <spirit:description>Indicates the level of Sample-based profiling support using external debug registers 40 through 43. Permitted values of this field in v8-A are:
      0000
      
      Architecture-defined form of Sample-based profiling not implemented.
      
      
    
      0010
      
      EDPCSR and EDCIDSR are implemented (only permitted if EL3 and EL2 are not implemented).
      
      
    
      0011
      
      EDPCSR, EDCIDSR, and EDVIDSR are implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVID1</spirit:name>
          <spirit:description>External Debug Device ID Register 1</spirit:description>
          <spirit:addressOffset>0xFC4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000002</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVID1 -->
          <spirit:field>
            <spirit:name>RES0_EDDEVID1_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PCSROffset</spirit:name>
            <spirit:displayName>PCSROffset</spirit:displayName>
            <spirit:description>This field indicates the offset applied to PC samples returned by reads of EDPCSR. Permitted values of this field in v8-A are:
      0000
      
      EDPCSR not implemented.
      
      
    
      0010
      
      EDPCSR implemented, and samples have no offset applied and do not sample the instruction set state in AArch32 state.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVID2</spirit:name>
          <spirit:description>External Debug Device ID Register 2</spirit:description>
          <spirit:addressOffset>0xFC0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVID2 -->
          <spirit:field>
            <spirit:name>RES0_EDDEVID2_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVTYPE</spirit:name>
          <spirit:description>External Debug Device Type Register</spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000015</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_EDDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Subtype. Must read as 0x1 to indicate this is a processor component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAJOR</spirit:name>
            <spirit:displayName>MAJOR</spirit:displayName>
            <spirit:description>Major type. Must read as 0x5 to indicate this is a debug logic component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDECCR</spirit:name>
          <spirit:description>External Debug Exception Catch Control Register</spirit:description>
          <spirit:addressOffset>0x098</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDECCR -->
          <spirit:field>
            <spirit:name>RES0_EDECCR_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSE</spirit:name>
            <spirit:displayName>NSE</spirit:displayName>
            <spirit:description>Coarse-grained Non-secure exception catch. Possible values of this field are:
      0000
      
      Exception catch debug event disabled for Non-secure exception levels.
      
      
    
      0010
      
      Exception catch debug event enabled for Non-secure EL1.
      
      
    
      0100
      
      Exception catch debug event enabled for Non-secure EL2.
      
      
    
      0110
      
      Exception catch debug event enabled for Non-secure EL1 and EL2.
      
      
    All other values are reserved. Bits [7,4] are reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SE</spirit:name>
            <spirit:displayName>SE</spirit:displayName>
            <spirit:description>Coarse-grained Secure exception catch. Possible values of this field are:
      0000
      
      Exception catch debug event disabled for Secure exception levels.
      
      
    
      0010
      
      Exception catch debug event enabled for Secure EL1.
      
      
    
      1000
      
      Exception catch debug event enabled for Secure EL3.
      
      
    
      1010
      
      Exception catch debug event enabled for Secure EL1 and EL3.
      
      
    All other values are reserved. Bits [2,0] are reserved. RES0. Ignored if ExternalSecureInvasiveDebugEnabled() == FALSE.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDECR</spirit:name>
          <spirit:description>External Debug Execution Control Register</spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDECR -->
          <spirit:field>
            <spirit:name>RES0_EDECR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SS</spirit:name>
            <spirit:displayName>SS</spirit:displayName>
            <spirit:description>Halting step enable. Possible values of this field are:
      0
      
      Halting step debug event disabled.
      
      
    
      1
      
      Halting step debug event enabled.
      
      
    If the value of EDECR.SS is changed when the processor is in Non-debug state, the resulting value of EDECR.SS is UNKNOWN.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RCE</spirit:name>
            <spirit:displayName>RCE</spirit:displayName>
            <spirit:description>Reset catch enable. Possible values of this field are:
      0
      
      Reset catch debug event disabled.
      
      
    
      1
      
      Reset catch debug event enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSUCE</spirit:name>
            <spirit:displayName>OSUCE</spirit:displayName>
            <spirit:description>OS unlock catch enabled. Possible values of this field are:
      0
      
      OS unlock catch debug event disabled.
      
      
    
      1
      
      OS unlock catch debug event enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDESR</spirit:name>
          <spirit:description>External Debug Event Status Register</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF9</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDESR -->
          <spirit:field>
            <spirit:name>RES0_EDESR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SS</spirit:name>
            <spirit:displayName>SS</spirit:displayName>
            <spirit:description>Halting step debug event pending. Possible values of this field are:
      0
      
      Reading this means that a Halting step debug event is not pending. Writing this means no action.
      
      
    
      1
      
      Reading this means that a Halting step debug event is pending. Writing this clears the pending Halting step debug event.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RC</spirit:name>
            <spirit:displayName>RC</spirit:displayName>
            <spirit:description>Reset catch debug event pending. Possible values of this field are:
      0
      
      Reading this means that a Reset catch debug event is not pending. Writing this means no action.
      
      
    
      1
      
      Reading this means that a Reset catch debug event is pending. Writing this clears the pending Reset catch debug event.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSUC</spirit:name>
            <spirit:displayName>OSUC</spirit:displayName>
            <spirit:description>OS unlock debug event pending. Possible values of this field are:
      0
      
      Reading this means that an OS unlock catch debug event is not pending. Writing this means no action.
      
      
    
      1
      
      Reading this means that an OS unlock catch debug event is pending. Writing this clears the pending OS unlock catch debug event.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDITCTRL</spirit:name>
          <spirit:description>External Debug Integration mode Control Register</spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDITCTRL -->
          <spirit:field>
            <spirit:name>RES0_EDITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IME</spirit:name>
            <spirit:displayName>IME</spirit:displayName>
            <spirit:description>Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.
      0
      
      Normal operation.
      
      
    
      1
      
      Integration mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDITR</spirit:name>
          <spirit:description>External Debug Instruction Transfer Register</spirit:description>
          <spirit:addressOffset>0x084</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: EDITR -->
          <spirit:field>
            <spirit:name>EDITR</spirit:name>
            <spirit:displayName>EDITR</spirit:displayName>
            <spirit:description>Used in Debug state for passing instructions to the processor for execution</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDLAR</spirit:name>
          <spirit:description>External Debug Lock Access Register</spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: EDLAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDLSR</spirit:name>
          <spirit:description>External Debug Lock Status Register</spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF8</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDLSR -->
          <spirit:field>
            <spirit:name>RES0_EDLSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:
      0
      
      Software lock not implemented or not memory-mapped access.
      
      
    
      1
      
      Software lock implemented and memory-mapped access.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPCSR_31:0</spirit:name>
          <spirit:description>External Debug Program Counter Sample Register (low word)</spirit:description>
          <spirit:addressOffset>0x0A0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDPCSR_31:0 -->
          <spirit:field>
            <spirit:name>EDPCSR_31:0</spirit:name>
            <spirit:displayName>EDPCSR_31:0</spirit:displayName>
            <spirit:description>PC Sample low word, EDPCSRlo. Bits [31:0] of the sampled instruction address value. Reading EDPCSRlo has the side-effect of updating EDCIDSR, EDVIDSR, and EDPCSRhi. However:If the processor is in Debug state, or Sample-based profiling is prohibited, EDPCSRlo reads as 0xFFFFFFFF and EDCIDSR, EDVIDSR, and EDPCSRhi become UNKNOWN.If the processor is in Reset state, the sampled value is unknown and EDCIDSR, EDVIDSR and EDPCSRhi become UNKNOWN.If no instruction has been retired since the processor left Reset state, Debug state, or a state where Non-invasive debug is not permitted, the sampled value is UNKNOWN and EDCIDSR, EDVIDSR, and EDPCSRhi become UNKNOWN.For a read of EDPCSRlo from the memory-mapped interface, if EDLSR.SLK == 1, meaning the Software Lock is locked, then the access has no side-effects. That is, EDCIDSR, EDVIDSR, and EDPCSRhi are unchanged.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPCSR_63:32</spirit:name>
          <spirit:description>External Debug Program Counter Sample Register (high word)</spirit:description>
          <spirit:addressOffset>0x0AC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDPCSR_63:32 -->
          <spirit:field>
            <spirit:name>EDPCSR_63:32</spirit:name>
            <spirit:displayName>EDPCSR_63:32</spirit:displayName>
            <spirit:description>PC Sample high word, EDPCSRhi. If EDVIDSR.HV == 0 then this field is RAZ, otherwise bits [63:32] of the sampled PC.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR0</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, least significant byte.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR1</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000BD</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, most significant nibble.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR2</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Part major revision. Parts can also use this field to extend Part number to 16-bits.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR3</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>Part minor revision. Parts using EDPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR4</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 4</spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPRCR</spirit:name>
          <spirit:description>External Debug Power/Reset Control Register</spirit:description>
          <spirit:addressOffset>0x310</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF6</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPRCR -->
          <spirit:field>
            <spirit:name>RES0_EDPRCR_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COREPURQ</spirit:name>
            <spirit:displayName>COREPURQ</spirit:displayName>
            <spirit:description>Core powerup request. Allows a debugger to request that the power controller power up the core, enabling access to the debug register in the Core power domain. The actions on writing to this bit are:
      0
      
      No effect.
      
      
    
      1
      
      Request the power controller to powerup the core.
      
      
    In an implementation that includes the recommended external debug interface, this bit drives the DBGPWRUPREQ signal.This bit can be read and written when the Core power domain is powered off.The power controller must not allow the Core power domain to switch off while this bit is one.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDPRCR_2_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CWRR</spirit:name>
            <spirit:displayName>CWRR</spirit:displayName>
            <spirit:description>Warm reset request. Write only bit that reads as zero. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Request Warm reset.
      
      
    The processor ignores writes to this bit if any of the following are the case:ExternalInvasiveDebugEnabled() == FALSE, EL3 is not implemented, and the processor is Non-secure.ExternalSecureInvasiveDebugEnabled() == FALSE and one of the following is true:EL3 is implemented.The processor is Secure.The Core power domain is either completely off or in a low-power state where the Core power domain registers cannot be accessed.DoubleLockStatus() == TRUE (OS Double Lock is set).OSLSR.OSLK == 1 (OS lock is locked).In an implementation that includes the recommended external debug interface, this bit drives the DBGRSTREQ signal.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CORENPDRQ</spirit:name>
            <spirit:displayName>CORENPDRQ</spirit:displayName>
            <spirit:description>Core no powerdown request. Requests emulation of powerdown. Possible values of this bit are:
      0
      
      On a powerdown request, the system powers down the Core power domain.
      
      
    
      1
      
      On a powerdown request, the system emulates powerdown of the Core power domain. In this emulation mode the Core power domain is not actually powered down.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPRSR</spirit:name>
          <spirit:description>External Debug Processor Status Register</spirit:description>
          <spirit:addressOffset>0x314</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFF543</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPRSR -->
          <spirit:field>
            <spirit:name>RES0_EDPRSR_31_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SDR</spirit:name>
            <spirit:displayName>SDR</spirit:displayName>
            <spirit:description>Sticky debug restart. Set to 1 when the processor exits Debug state and cleared to 0 following reads of EDPRSR.
      0
      
      The processor has not restarted since EDPRSR was last read.
      
      
    
      1
      
      The processor has restarted since EDPRSR was last read.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 when following a read of EDPRSR.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SPMAD</spirit:name>
            <spirit:displayName>SPMAD</spirit:displayName>
            <spirit:description>Sticky EPMAD error. Set to 1 if an access returns an error because AllowExternalPMUAccess() == FALSE.
      0
      
      No accesses to the external performance monitors registers have failed since EDPRSR was last read.
      
      
    
      1
      
      At least one access to the external performance monitors registers has failed since EDPRSR was last read.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 when following a read of EDPRSR.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EPMAD</spirit:name>
            <spirit:displayName>EPMAD</spirit:displayName>
            <spirit:description>External performance monitors access disable status.
      0
      
      External performance monitors access enabled.
      
      
    
      1
      
      External performance monitors access disabled.
      
      
    If external performance monitors access is not implemented, EPMAD is RAO. This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SDAD</spirit:name>
            <spirit:displayName>SDAD</spirit:displayName>
            <spirit:description>Sticky EDAD error. Set to 1 if an access returns an error because AllowExternalDebugAccess() == FALSE.
      0
      
      No accesses to the external debug registers have failed since EDPRSR was last read.
      
      
    
      1
      
      At least one access to the external debug registers has failed since EDPRSR was last read.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 following a read of EDPRSR.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EDAD</spirit:name>
            <spirit:displayName>EDAD</spirit:displayName>
            <spirit:description>External debug access disable status.
      0
      
      External debug access enabled.
      
      
    
      1
      
      External debug access disabled.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DLK</spirit:name>
            <spirit:displayName>DLK</spirit:displayName>
            <spirit:description>OS Double Lock status bit.
      0
      
      OSDLR_EL1.DLK == 0 or EDPRCR.CORENPDRQ == 1 or the processor is in Debug state.
      
      
    
      1
      
      OSDLR_EL1.DLK == 1 and EDPRCR.CORENPDRQ == 0 and the processor is in Non-debug state.
      
      
    This bit is UNKNOWN on reads if EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSLK</spirit:name>
            <spirit:displayName>OSLK</spirit:displayName>
            <spirit:description>OS lock status bit. A read of this bit returns the value of OSLSR_EL1.OSLK.This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1 or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HALTED</spirit:name>
            <spirit:displayName>HALTED</spirit:displayName>
            <spirit:description>Halted status bit. Possible values are:
      0
      
      EDSCR.STATUS is 0b000010 (processor in Non-debug state).
      
      
    
      1
      
      EDSCR.STATUS is not 0b000010.
      
      
    This bit is UNKNOWN on reads if EDPRSR.PU is 0. </spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SR</spirit:name>
            <spirit:displayName>SR</spirit:displayName>
            <spirit:description>Sticky core reset status bit. Possible values are:
      0
      
      The non-debug logic of the processor is not in reset state and has not been reset since the last time EDPRSR was read.
      
      
    
      1
      
      The non-debug logic of the processor is in reset state or has been reset since the last time EDPRSR was read.
      
      
    This bit is UNKNOWN on reads if EDPRSR.DLK is 1 or EDPRSR.PU is 0.This bit clears to 0 following a read of EDPRSR if the non-debug logic of the processor is not in reset state.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>R</spirit:name>
            <spirit:displayName>R</spirit:displayName>
            <spirit:description>Core reset status bit. Possible values are:
      0
      
      The non-debug logic of the processor is not in reset state.
      
      
    
      1
      
      The non-debug logic of the processor is in reset state.
      
      
    This bit is UNKNOWN on reads if either EDPRSR.DLK is 1 or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SPD</spirit:name>
            <spirit:displayName>SPD</spirit:displayName>
            <spirit:description>Sticky core power-down status bit.This bit is set to 1 on Cold reset to indicate the state of the debug registers has been lost. Since a Cold reset is required on powering up the processor, this usually indicates the Core power domain has been completely powered off.Possible values are:
      0
      
      If the Core power domain is off (EDPRSR.PU is 0), it is not known whether the state of the debug registers in the Core power domain is lost. Otherwise, the Core power domain is on, and the state of the debug registers in the Core power domain has not been lost.
      
      
    
      1
      
      The state of the debug registers in the Core power domain is lost.
      
      
    This bit is UNKNOWN on reads if both EDPRSR.DLK and EDPRSR.PU are 1.This bit clears to 0 following a read of EDPRSR if the processor is not in the powered down state. There are two logical power off states for the Core power domain:RetentionThe states of the debug registers, including EDPRSR.SPD, in the Core power domain is preserved, and restored on leaving retention state.Power-downThe states of the debug registers in the Core power domain is lost, and a Cold reset is asserted on leaving power-down state.In these states, it is IMPLEMENTATION DEFINED whether:EDPRSR.SPD shows whether the state of the debug registers in the Core power domain has been lost since the last time EDPRSR was read when the Core power domain was on.EDPRSR.SPD reads-as-zero.EDPRSR.SPD is not cleared following a read of EDPRSR in these states.This means it is IMPLEMENTATION DEFINED whether a processor implements EDPRSR.SPD as:Fixed RAZ when in one or both of the retention and power-down states.Retaining its previous value when in the retention state.Fixed RAO in the power-down state.Note that this definition does not allow EDPRSR.SPD to be fixed RAO in the low-power retention state, as the state of the debug registers in the Core power domain is not lost by entering this state. However, the bit can be read as 1 in this state if the state of the registers was lost before entering this state (i.e. EDPRSR has not been read since the last Cold reset).ARM recommends that an implementation make EDPRSR.SPD fixed RAO when in the power-down state, particularly if it does not support a low-power retention state.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PU</spirit:name>
            <spirit:displayName>PU</spirit:displayName>
            <spirit:description>Core power-up status bit. Indicates whether the Core power domain debug registers can be accessed:
      0
      
      Core is in a low-power or power-down state where the debug registers cannot be accessed.
      
      
    
      1
      
      Core is in a power-up state where the debug registers can be accessed.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDRCR</spirit:name>
          <spirit:description>External Debug Reserve Control Register</spirit:description>
          <spirit:addressOffset>0x090</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDRCR -->
          <spirit:field>
            <spirit:name>RES0_EDRCR_31_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>27</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CBRRQ</spirit:name>
            <spirit:displayName>CBRRQ</spirit:displayName>
            <spirit:description>Allow imprecise entry to Debug state. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Allow imprecise entry to Debug state, for example by canceling pending bus accesses.
      
      
    Setting this bit to 1 allows a debugger to request imprecise entry to Debug state. An External Debug Request debug event must be pending before the debugger sets this bit to 1.This feature is optional. If this feature is not implemented, writes to this bit are ignored.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSPA</spirit:name>
            <spirit:displayName>CSPA</spirit:displayName>
            <spirit:description>Clear Sticky Pipeline Advance. This bit is used to clear the EDSCR.PipeAdv bit to 0. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Clear the EDSCR.PipeAdv bit to 0.
      
      
    </spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSE</spirit:name>
            <spirit:displayName>CSE</spirit:displayName>
            <spirit:description>Clear Sticky Error. Used to clear the EDSCR cumulative error bits to 0. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Clear the EDSCR.{TXU, RXO, ERR} bits, and, if the processor is in Debug state, the EDSCR.ITO bit, to 0.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDRCR_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDSCR</spirit:name>
          <spirit:description>External Debug Status and Control Register</spirit:description>
          <spirit:addressOffset>0x088</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xECFAC040</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDSCR -->
          <spirit:field>
            <spirit:name>RES0_EDSCR_31_31</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXfull</spirit:name>
            <spirit:displayName>RXfull</spirit:displayName>
            <spirit:description>DTRRX full. This bit is RO.</spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXfull</spirit:name>
            <spirit:displayName>TXfull</spirit:displayName>
            <spirit:description>DTRTX full. This bit is RO.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ITO</spirit:name>
            <spirit:displayName>ITO</spirit:displayName>
            <spirit:description>EDITR overrun. This bit is RO.If the processor is not in Debug state, this bit is UNKNOWN. ITO is set to 0 on entry to Debug state.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXO</spirit:name>
            <spirit:displayName>RXO</spirit:displayName>
            <spirit:description>DTRRX overrun. This bit is RO.</spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXU</spirit:name>
            <spirit:displayName>TXU</spirit:displayName>
            <spirit:description>DTRTX underrun. This bit is RO.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PipeAdv</spirit:name>
            <spirit:displayName>PipeAdv</spirit:displayName>
            <spirit:description>Pipeline advance. Read-only. Set to 1 every time the processor pipeline retires one or more instructions. Cleared to 0 by a write to EDRCR.CSPA.The architecture does not define precisely when this bit is set to 1. It requires only that this happen periodically in Non-debug state to indicate that software execution is progressing.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ITE</spirit:name>
            <spirit:displayName>ITE</spirit:displayName>
            <spirit:description>ITR empty. This bit is RO.If the processor is not in Debug state, this bit is UNKNOWN. It is always valid in Debug state.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INTdis</spirit:name>
            <spirit:displayName>INTdis</spirit:displayName>
            <spirit:description>Interrupt disable. Disables taking interrupts (including virtual interrupts and System Error interrupts) in Non-Debug state.If external invasive debug is disabled, the value of this field is ignored.If external invasive debug is enabled, the possible values of this field are:
      00
      
      Do not disable interrupts
      
      
    
      01
      
      Disable interrupts targeting Non-secure EL1.
      
      
    
      10
      
      Disable interrupts targeting only Non-secure EL1 and Non-secure EL2. If external secure invasive debug is enabled, also disable interrupts targeting Secure EL1.
      
      
    
      11
      
      Disable interrupts targeting only Non-secure EL1 and Non-secure EL2. If external secure invasive debug is enabled, also disable all other interrupts.
      
      
    The value of INTdis does not affect whether an interrupt is a WFI wake-up event, but can mask an interrupt as a WFE wake-up event.If EL3 and EL2 are not implemented, INTdis[0] is RO and reads the same value as INTdis[1], meaning only the values 0b00 and 0b11 can be selected.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TDA</spirit:name>
            <spirit:displayName>TDA</spirit:displayName>
            <spirit:description>Trap debug registers accesses.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MA</spirit:name>
            <spirit:displayName>MA</spirit:displayName>
            <spirit:description>Memory access mode. Controls use of memory-access mode for accessing EDITR and the DCC. This bit is ignored if in Non-debug state and set to zero on entry to Debug state.Possible values of this field are:
      0
      
      Normal access mode
      
      
    
      1
      
      Memory access mode.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDSCR_19_19</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>19</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NS</spirit:name>
            <spirit:displayName>NS</spirit:displayName>
            <spirit:description>Non-secure status. Read-only. When in Debug state, gives the current security state:
      0
      
      Secure state, IsSecure() == TRUE
      
      
    
      1
      
      Non-secure state, IsSecure() == FALSE.
      
      
    In Non-debug state, this bit is UNKNOWN.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDSCR_17_17</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SDD</spirit:name>
            <spirit:displayName>SDD</spirit:displayName>
            <spirit:description>Secure debug disabled. This bit is RO.On entry to Debug state:If entering in Secure state, SDD is set to 0.If entering in Non-secure state, SDD is set to the inverse of ExternalSecureInvasiveDebugEnabled().In Debug state, the value of the SDD bit does not change, even if ExternalSecureInvasiveDebugEnabled() changes.In Non-debug state:SDD returns the inverse of ExternalSecureInvasiveDebugEnabled(). If the authentication signals that control ExternalSecureInvasiveDebugEnabled() change, a context synchronization operation is required to guarantee their effect.This bit is unaffected by the Security state of the processor.If EL3 is not implemented and the implementation is Non-secure, this bit is RES1.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDSCR_15_15</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HDE</spirit:name>
            <spirit:displayName>HDE</spirit:displayName>
            <spirit:description>Halting debug mode enable. Possible values of this bit are:
      0
      
      Halting debug mode disabled.
      
      
    
      1
      
      Halting debug mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RW</spirit:name>
            <spirit:displayName>RW</spirit:displayName>
            <spirit:description>Exception level register-width status. Read-only. In Debug state, each bit gives the current register width status of each EL:
      1111
      
      All exception levels are AArch64 state.
      
      
    
      1110
      
      EL0 is AArch32 state. All other exception levels are AArch64 state.
      
      
    
      1100
      
      EL0 and EL1 are AArch32 state. All other exception levels are AArch64 state. Never seen if EL2 is not implemented in the current security state.
      
      
    
      1000
      
      EL0, EL1, and, if implemented in the current security state, EL2 are AArch32 state. All other exception levels are AArch64 state.
      
      
    
      0000
      
      All exception levels are set to AArch32 state (32-bit configuration).
      
      
    However:If not at EL0: RW[0] == RW[1].If EL2 is not implemented in the current security state: RW[2] == RW[1].If EL3 is not implemented: RW[3] == RW[2].In Non-debug state, this field is RAO.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL</spirit:name>
            <spirit:displayName>EL</spirit:displayName>
            <spirit:description>Exception level. Read-only. In Debug state, this gives the current EL of the processor.In Non-debug state, this field is RAZ.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>A</spirit:name>
            <spirit:displayName>A</spirit:displayName>
            <spirit:description>System Error interrupt pending. Read-only. In Debug state, indicates whether a SError interrupt is pending:If HCR_EL2.{AMO, TGE} = {1, 0} and in Non-secure EL0 or EL1, a virtual SError interrupt.Otherwise, a physical SError interrupt.
      0
      
      No SError interrupt pending.
      
      
    
      1
      
      SError interrupt pending.
      
      
    A debugger can read EDSCR to check whether a SError interrupt is pending without having to execute further instructions. A pending SError might indicate data from target memory is corrupted.UNKNOWN in Non-debug state.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERR</spirit:name>
            <spirit:displayName>ERR</spirit:displayName>
            <spirit:description>Cumulative error flag. This field is RO. It is set to 1 following exceptions in Debug state and on any signaled overrun or underrun on the DTR or EDITR.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STATUS</spirit:name>
            <spirit:displayName>STATUS</spirit:displayName>
            <spirit:description>Debug status flags. This field is RO.The possible values of this field are:
      000010
      
      Processor is in Non-debug state.
      
      
    
      000001
      
      Processor is restarting (exiting Debug state).
      
      
    
      000111
      
      Breakpoint.
      
      
    
      010011
      
      External debug request.
      
      
    
      011011
      
      Halting step, normal.
      
      
    
      011111
      
      Halting step, exclusive.
      
      
    
      100011
      
      OS unlock catch.
      
      
    
      100111
      
      Reset catch.
      
      
    
      101011
      
      Watchpoint.
      
      
    
      101111
      
      HLT instruction.
      
      
    
      110011
      
      Software access to debug register.
      
      
    
      110111
      
      Exception catch.
      
      
    
      111011
      
      Halting step, no syndrome.
      
      
    All other values of STATUS are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDVIDSR</spirit:name>
          <spirit:description>External Debug Virtual Context Sample Register</spirit:description>
          <spirit:addressOffset>0x0A8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0x0FFFFF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDVIDSR -->
          <spirit:field>
            <spirit:name>NS</spirit:name>
            <spirit:displayName>NS</spirit:displayName>
            <spirit:description>Non-secure state sample. Indicates the security state associated with the most recent EDPCSR sample.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E2</spirit:name>
            <spirit:displayName>E2</spirit:displayName>
            <spirit:description>Exception level 2 status sample. Indicates whether the most recent EDPCSR sample was associated with EL2. If EDVIDSR.NS == 0, this bit is 0.</spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E3</spirit:name>
            <spirit:displayName>E3</spirit:displayName>
            <spirit:description>Exception level 3 status sample. Indicates whether the most recent EDPCSR sample was associated with AArch64 EL3. If EDVIDSR.NS == 1 or the processor was in AArch32 state when EDPCSR was read, this bit is 0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HV</spirit:name>
            <spirit:displayName>HV</spirit:displayName>
            <spirit:description>EDPCSR high half valid. Indicates whether bits [63:32] of the most recent EDPCSR sample are valid. If EDVIDSR.HV == 0, the value of EDPCSR[63:32] is RAZ.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDVIDSR_27_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VMID</spirit:name>
            <spirit:displayName>VMID</spirit:displayName>
            <spirit:description>VMID sample. The value of VTTBR_EL2.VMID associated with the most recent EDPCSR sample. If EDVIDSR.NS == 0 or EDVIDSR.E2 == 1, this field is RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDWAR_31:0</spirit:name>
          <spirit:description>External Debug Watchpoint Address Register (low word)</spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDWAR_31:0 -->
          <spirit:field>
            <spirit:name>EDWAR_31:0</spirit:name>
            <spirit:displayName>EDWAR_31:0</spirit:displayName>
            <spirit:description>Watchpoint address. The virtual data address being accessed when a watchpoint debug event was triggered and caused entry to Debug state.UNKNOWN if the processor is not in Debug state, or if Debug state was entered other than for a watchpoint debug event.The address must be within a naturally-aligned block of memory of power-of-two size no larger than the DC ZVA block size.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDWAR_63:32</spirit:name>
          <spirit:description>External Debug Watchpoint Address Register (high word)</spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDWAR_63:32 -->
          <spirit:field>
            <spirit:name>EDWAR_63:32</spirit:name>
            <spirit:displayName>EDWAR_63:32</spirit:displayName>
            <spirit:description>Watchpoint address. The virtual data address being accessed when a watchpoint debug event was triggered and caused entry to Debug state.UNKNOWN if the processor is not in Debug state, or if Debug state was entered other than for a watchpoint debug event.The address must be within a naturally-aligned block of memory of power-of-two size no larger than the DC ZVA block size.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR0_EL1_31:0</spirit:name>
          <spirit:description>Debug Feature Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD28</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x10305106</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>CTX_CMPs</spirit:name>
            <spirit:displayName>CTX_CMPs</spirit:displayName>
            <spirit:description>Number of breakpoints that are context-aware, minus 1. These are the highest numbered breakpoints.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR0_EL1_31:0_27_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WRPs</spirit:name>
            <spirit:displayName>WRPs</spirit:displayName>
            <spirit:description>Number of watchpoints, minus 1. The value of 0b0000 is reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR0_EL1_31:0_19_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BRPs</spirit:name>
            <spirit:displayName>BRPs</spirit:displayName>
            <spirit:description>Number of breakpoints, minus 1. The value of 0b0000 is reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMUVer</spirit:name>
            <spirit:displayName>PMUVer</spirit:displayName>
            <spirit:description>Performance Monitors extension version. Indicates whether system register interface to Performance Monitors extension is implemented. Permitted values are:
      0000
      
      Performance Monitors extension system registers not implemented.
      
      
    
      0001
      
      Performance Monitors extension system registers implemented, PMUv3.
      
      
    
      1111
      
      IMPLEMENTATION DEFINED form of performance monitors supported, PMUv3 not supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TraceVer</spirit:name>
            <spirit:displayName>TraceVer</spirit:displayName>
            <spirit:description>Trace extension. Indicates whether system register interface to Trace extension is implemented. Permitted values are:
      0000
      
      Trace extension system registers not implemented.
      
      
    
      0001
      
      Trace extension system registers implemented.
      
      
    All other values are reserved.A value of 0b0000 only indicates that no system register interface to the trace extension is implemented. A trace extension may nevertheless be implemented without a system register interface.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DebugVer</spirit:name>
            <spirit:displayName>DebugVer</spirit:displayName>
            <spirit:description>Debug architecture version. Indicates presence of v8-A debug architecture.
      0110
      
      v8-A debug architecture.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR0_EL1_63:32</spirit:name>
          <spirit:description>Debug Feature Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD2C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR1_EL1_31:0</spirit:name>
          <spirit:description>Auxiliary Feature Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD48</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR1_EL1_63:32</spirit:name>
          <spirit:description>Auxiliary Feature Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD4C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR0_EL1_31:0</spirit:name>
          <spirit:description>Instruction Set Attribute Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD30</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="immediate">65536</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR0_EL1_31:0_31_20</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRC32</spirit:name>
            <spirit:displayName>CRC32</spirit:displayName>
            <spirit:description>CRC32 instructions in AArch64. Possible values of this field are:
      0000
      
      No CRC32 instructions implemented.
      
      
    
      0001
      
      CRC32B, CRC32H, CRC32W, CRC32X, CRC32CB, CRC32CH, CRC32CW, and CRC32CX instructions implemented.
      
      
    All other values are reserved.This field must have the same value as ID_ISAR5.CRC32. The architecture requires that if CRC32 is supported in one Execution state, it must be supported in both Execution states.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SHA2</spirit:name>
            <spirit:displayName>SHA2</spirit:displayName>
            <spirit:description>SHA2 instructions in AArch64. Possible values of this field are:
      0000
      
      No SHA2 instructions implemented.
      
      
    
      0001
      
      SHA256H, SHA256H2, SHA256SU0, and SHA256SU1 instructions implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SHA1</spirit:name>
            <spirit:displayName>SHA1</spirit:displayName>
            <spirit:description>SHA1 instructions in AArch64. Possible values of this field are:
      0000
      
      No SHA1 instructions implemented.
      
      
    
      0001
      
      SHA1C, SHA1P, SHA1M, SHA1H, SHA1SU0, and SHA1SU1 instructions implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AES</spirit:name>
            <spirit:displayName>AES</spirit:displayName>
            <spirit:description>AES instructions in AArch64. Possible values of this field are:
      0000
      
      No AES instructions implemented.
      
      
    
      0001
      
      AESE, AESD, AESMC, and AESIMC instructions implemented.
      
      
    
      0010
      
      As for 0b0001, plus PMULL/PMULL2 instructions operating on 64-bit data quantities.
      
      
    </spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR0_EL1_31:0_3_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR0_EL1_63:32</spirit:name>
          <spirit:description>Instruction Set Attribute Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD34</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR1_EL1_31:0</spirit:name>
          <spirit:description>Instruction Set Attribute Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD50</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR1_EL1_63:32</spirit:name>
          <spirit:description>Instruction Set Attribute Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD54</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR0_EL1_31:0</spirit:name>
          <spirit:description>Memory Model Feature Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD38</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00001122</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>TGran4</spirit:name>
            <spirit:displayName>TGran4</spirit:displayName>
            <spirit:description>Support for 4 Kbyte memory translation granule size. Permitted values are:
      0000
      
      4 KB granule supported.
      
      
    
      1111
      
      4 KB granule not supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGran64</spirit:name>
            <spirit:displayName>TGran64</spirit:displayName>
            <spirit:description>Support for 64 Kbyte memory translation granule size. Permitted values are:
      0000
      
      64 KB granule supported.
      
      
    
      1111
      
      64 KB granule not supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGran16</spirit:name>
            <spirit:displayName>TGran16</spirit:displayName>
            <spirit:description>Support for 16 Kbyte memory translation granule size. Permitted values are:
      0000
      
      16 KB granule not supported.
      
      
    
      0001
      
      16 KB granule supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BigEndEL0</spirit:name>
            <spirit:displayName>BigEndEL0</spirit:displayName>
            <spirit:description>Mixed-endian support at EL0 only. Permitted values are:
      0000
      
      No mixed-endian support at EL0. The SCTLR_EL1.E0E bit has a fixed value.
      
      
    
      0001
      
      Mixed-endian support at EL0. The SCTLR_EL1.E0E bit can be configured.
      
      
    All other values are reserved.This field is invalid and is RES0 if the BigEnd field, bits [11:8], is not 0b0000.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNSMem</spirit:name>
            <spirit:displayName>SNSMem</spirit:displayName>
            <spirit:description>Secure versus Non-secure Memory distinction. Permitted values are:
      0000
      
      Does not support a distinction between Secure and Non-secure Memory.
      
      
    
      0001
      
      Does support a distinction between Secure and Non-secure Memory.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BigEnd</spirit:name>
            <spirit:displayName>BigEnd</spirit:displayName>
            <spirit:description>Mixed-endian configuration support. Permitted values are:
      0000
      
      No mixed-endian support. The SCTLR_ELx.EE bits have a fixed value. See the BigEndEL0 field, bits[19:16], for whether EL0 supports mixed-endian.
      
      
    
      0001
      
      Mixed-endian support. The SCTLR_ELx.EE and SCTLR_EL1.E0E bits can be configured.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ASIDBits</spirit:name>
            <spirit:displayName>ASIDBits</spirit:displayName>
            <spirit:description>Number of ASID bits. Permitted values are:
      0000
      
      8 bits.
      
      
    
      0010
      
      16 bits.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PARange</spirit:name>
            <spirit:displayName>PARange</spirit:displayName>
            <spirit:description>Physical Address range supported. Permitted values are:
      0000
      
      32 bits, 4 GB.
      
      
    
      0001
      
      36 bits, 64 GB.
      
      
    
      0010
      
      40 bits, 1 TB.
      
      
    
      0011
      
      42 bits, 4 TB.
      
      
    
      0100
      
      44 bits, 16 TB.
      
      
    
      0101
      
      48 bits, 256 TB.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR0_EL1_63:32</spirit:name>
          <spirit:description>Memory Model Feature Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD3C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64MMFR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR1_EL1_31:0</spirit:name>
          <spirit:description>Memory Model Feature Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD58</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64MMFR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR1_EL1_63:32</spirit:name>
          <spirit:description>Memory Model Feature Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD5C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64MMFR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR0_EL1_31:0</spirit:name>
          <spirit:description>Processor Feature Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD20</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="immediate">16785954</spirit:value>
            <spirit:mask>0xF0FFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR0_EL1_31:0_31_28</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GIC</spirit:name>
            <spirit:displayName>GIC</spirit:displayName>
            <spirit:description>GIC system register interface. Permitted values are:
      0000
      
      No GIC system registers are supported.
      
      
    
      0001
      
      GICv3 system registers are supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AdvSIMD</spirit:name>
            <spirit:displayName>AdvSIMD</spirit:displayName>
            <spirit:description>Advanced SIMD. Permitted values are:
      0000
      
      Advanced SIMD is implemented.
      
      
    
      1111
      
      Advanced SIMD is not implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>FP</spirit:name>
            <spirit:displayName>FP</spirit:displayName>
            <spirit:description>Floating-point. Permitted values are:
      0000
      
      Floating-point is implemented.
      
      
    
      1111
      
      Floating-point is not implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL3</spirit:name>
            <spirit:displayName>EL3</spirit:displayName>
            <spirit:description>EL3 exception level handling. Permitted values are:
      0000
      
      EL3 is not implemented.
      
      
    
      0001
      
      EL3 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL3 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL2</spirit:name>
            <spirit:displayName>EL2</spirit:displayName>
            <spirit:description>EL2 exception level handling. Permitted values are:
      0000
      
      EL2 is not implemented.
      
      
    
      0001
      
      EL2 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL2 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL1</spirit:name>
            <spirit:displayName>EL1</spirit:displayName>
            <spirit:description>EL1 exception level handling. Permitted values are:
      0000
      
      EL1 is not implemented.
      
      
    
      0001
      
      EL1 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL1 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL0</spirit:name>
            <spirit:displayName>EL0</spirit:displayName>
            <spirit:description>EL0 exception level handling. Permitted values are:
      0000
      
      EL0 is not implemented.
      
      
    
      0001
      
      EL0 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL0 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR0_EL1_63:32</spirit:name>
          <spirit:description>Processor Feature Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD24</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR1_EL1_31:0</spirit:name>
          <spirit:description>Processor Feature Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD40</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR1_EL1_63:32</spirit:name>
          <spirit:description>Processor Feature Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD44</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>MIDR_EL1</spirit:name>
          <spirit:description>Main ID Register</spirit:description>
          <spirit:addressOffset>0xD00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x410FD034</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: MIDR_EL1 -->
          <spirit:field>
            <spirit:name>Implementer</spirit:name>
            <spirit:displayName>Implementer</spirit:displayName>
            <spirit:description>The Implementer code. This field must hold an implementer code that has been assigned by ARM.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>Variant</spirit:name>
            <spirit:displayName>Variant</spirit:displayName>
            <spirit:description>An IMPLEMENTATION DEFINED variant number. Typically this field is used to distinguish between different product variants or major revisions of a product.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>Architecture</spirit:name>
            <spirit:displayName>Architecture</spirit:displayName>
            <spirit:description> </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PartNum</spirit:name>
            <spirit:displayName>PartNum</spirit:displayName>
            <spirit:description>An IMPLEMENTATION DEFINED primary part number for the device. On processors implemented by ARM if the top four bits of the primary part number are 0x0 or 0x7 the variant and architecture are encoded differently</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>Revision</spirit:name>
            <spirit:displayName>Revision</spirit:displayName>
            <spirit:description>An IMPLEMENTATION DEFINED revision number for the device</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>OSLAR_EL1</spirit:name>
          <spirit:description>OS Lock Access Register</spirit:description>
          <spirit:addressOffset>0x300</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFE</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: OSLAR_EL1 -->
          <spirit:field>
            <spirit:name>RES0_OSLAR_EL1_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSLK</spirit:name>
            <spirit:displayName>OSLK</spirit:displayName>
            <spirit:description>On writes to OSLAR_EL1, bit[0] is copied to the OS lock.Use EDPRSR.OSLK to check the current status of the lock.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_CTI_CPU0</spirit:name>
        <spirit:displayName>APBADDR_CTI_0</spirit:displayName>
        <spirit:description>APBADDR_CTI_0</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">131072</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_CTI_CPU0>  -->
        <spirit:register>
          <spirit:name>ASICCTL</spirit:name>
          <spirit:description>CTI External Multiplexor Control register</spirit:description>
          <spirit:addressOffset>0x144</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ASICCTL -->
          <spirit:field>
            <spirit:name>RES0_ASICCTL_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ASICCTL</spirit:name>
            <spirit:displayName>ASICCTL</spirit:displayName>
            <spirit:description>IMPLEMENTATION DEFINED ASIC control. Provides a control for external multiplexing of additional triggers into the CTI.If external multiplexing of trigger signals is implemented then the number of multiplexed signals on each trigger must be reflected in CTIDEVID.EXTMUXNUM.If CTIDEVID.EXTMUXNUM is zero, this field is RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAPPCLEAR</spirit:name>
          <spirit:description>CTI Application Trigger Clear Register</spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTIAPPCLEAR -->
          <spirit:field>
            <spirit:name>RESERVED_CTIAPPCLEAR_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTIAPPCLEARx</spirit:name>
            <spirit:displayName>CTIAPPCLEARx</spirit:displayName>
            <spirit:description>Application trigger &lt;x&gt; disable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAPPPULSE</spirit:name>
          <spirit:description>CTI Application Pulse Register</spirit:description>
          <spirit:addressOffset>0x01C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTIAPPPULSE -->
          <spirit:field>
            <spirit:name>RESERVED_CTIAPPPULSE_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTIAPPPULSEx</spirit:name>
            <spirit:displayName>CTIAPPPULSEx</spirit:displayName>
            <spirit:description>Generate event pulse on ECT channel &lt;x&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAPPSET</spirit:name>
          <spirit:description>CTI Application Trigger Set Register</spirit:description>
          <spirit:addressOffset>0x014</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIAPPSET -->
          <spirit:field>
            <spirit:name>RESERVED_CTIAPPSET_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTIAPPSETx</spirit:name>
            <spirit:displayName>CTIAPPSETx</spirit:displayName>
            <spirit:description>Application trigger &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAUTHSTATUS</spirit:name>
          <spirit:description>CTI Authentication Status Register</spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000A</spirit:value>
            <spirit:mask>0xFFFFFFAA</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIAUTHSTATUS -->
          <spirit:field>
            <spirit:name>RES0_CTIAUTHSTATUS_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>If EL3 is not implemented and the processor is Secure, holds the same value as DBGAUTHSTATUS_EL1.SNID.Otherwise, holds the same value as DBGAUTHSTATUS_EL1.NSNID.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSID</spirit:name>
            <spirit:displayName>NSID</spirit:displayName>
            <spirit:description>If EL3 is not implemented and the processor is Secure, holds the same value as DBGAUTHSTATUS_EL1.SID.Otherwise, holds the same value as DBGAUTHSTATUS_EL1.NSID.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICHINSTATUS</spirit:name>
          <spirit:description>CTI Channel In Status Register</spirit:description>
          <spirit:addressOffset>0x138</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICHINSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTICHINSTATUS_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CHINn</spirit:name>
            <spirit:displayName>CHINn</spirit:displayName>
            <spirit:description>Provides the raw status of the ECT channel inputs to the CTI</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICHOUTSTATUS</spirit:name>
          <spirit:description>CTI Channel Out Status Register</spirit:description>
          <spirit:addressOffset>0x13C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICHOUTSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTICHOUTSTATUS_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CHOUTn</spirit:name>
            <spirit:displayName>CHOUTn</spirit:displayName>
            <spirit:description>Provides the status of the ECT channel outputs from the CTI</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR0</spirit:name>
          <spirit:description>CTI Component Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR0 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR1</spirit:name>
          <spirit:description>CTI Component Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR1 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, debug component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR2</spirit:name>
          <spirit:description>CTI Component Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR2 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR3</spirit:name>
          <spirit:description>CTI Component Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR3 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICLAIMCLR</spirit:name>
          <spirit:description>CTI Claim Clear</spirit:description>
          <spirit:addressOffset>0xFA4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICLAIMCLR -->
          <spirit:field>
            <spirit:name>RESERVED_CTICLAIMCLR_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIMx</spirit:name>
            <spirit:displayName>CLAIMx</spirit:displayName>
            <spirit:description>Clear CLAIM tag</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICLAIMSET</spirit:name>
          <spirit:description>CTI Claim Set</spirit:description>
          <spirit:addressOffset>0xFA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000f</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICLAIMSET -->
          <spirit:field>
            <spirit:name>RESERVED_CTICLAIMSET_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIMx</spirit:name>
            <spirit:displayName>CLAIMx</spirit:displayName>
            <spirit:description>CLAIM tag set bit</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICONTROL</spirit:name>
          <spirit:description>CTI Control Register</spirit:description>
          <spirit:addressOffset>0x000</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICONTROL -->
          <spirit:field>
            <spirit:name>RES0_CTICONTROL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GLBEN</spirit:name>
            <spirit:displayName>GLBEN</spirit:displayName>
            <spirit:description>Enables or disables the CTI mapping functions. Possible values of this field are:
      0
      
      CTI mapping functions disabled.
      
      
    
      1
      
      CTI mapping functions enabled.
      
      
    When the mapping functions are disabled, no new events are signaled on either output triggers or output channels. If a previously asserted output trigger has not been acknowledged, it remains asserted after the mapping functions are disabled. All output triggers are disabled by CTI reset.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVAFF0</spirit:name>
          <spirit:description>CTI Device Affinity Register 0</spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000000</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVAFF0 -->
          <spirit:field>
            <spirit:name>CTIDEVAFF0</spirit:name>
            <spirit:displayName>CTIDEVAFF0</spirit:displayName>
            <spirit:description>MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVAFF1</spirit:name>
          <spirit:description>CTI Device Affinity Register 1</spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVAFF1 -->
          <spirit:field>
            <spirit:name>CTIDEVAFF1</spirit:name>
            <spirit:displayName>CTIDEVAFF1</spirit:displayName>
            <spirit:description>MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVARCH</spirit:name>
          <spirit:description>CTI Device Architecture Register</spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47701A14</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For CTI, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For CTI, the revision defined by v8-A is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For CTI:Bits [15:12] are the architecture version, 0x1.Bits [11:0] are the architecture part number, 0xA14.This corresponds to CTI architecture version CTIv2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVID</spirit:name>
          <spirit:description>CTI Device ID Register 0</spirit:description>
          <spirit:addressOffset>0xFC8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x01040800</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVID -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_31_26</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INOUT</spirit:name>
            <spirit:displayName>INOUT</spirit:displayName>
            <spirit:description>Input/output options. Indicates presence of the input gate. If the CTM is not implemented, this field is RAZ.
      00
      
      CTIGATE does not mask propagation of input events from external channels.
      
      
    
      01
      
      CTIGATE masks propagation of input events from external channels.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_23_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMCHAN</spirit:name>
            <spirit:displayName>NUMCHAN</spirit:displayName>
            <spirit:description>Number of ECT channels implemented. IMPLEMENTATION DEFINED. For v8-A, valid values are:
      000011
      
      3 channels (0..2) implemented.
      
      
    
      000100
      
      4 channels (0..3) implemented.
      
      
    
      000101
      
      5 channels (0..4) implemented.
      
      
    
      000110
      
      6 channels (0..5) implemented.
      
      
    and so on up to 0b100000, 32 channels (0..31) implemented.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_15_14</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMTRIG</spirit:name>
            <spirit:displayName>NUMTRIG</spirit:displayName>
            <spirit:description>Number of triggers implemented. IMPLEMENTATION DEFINED. This is one more than the index of the largest trigger, rather than the actual number of triggers.For v8-A, valid values are:
      000011
      
      Up to 3 triggers (0..2) implemented.
      
      
    
      001000
      
      Up to 8 triggers (0..7) implemented.
      
      
    
      001001
      
      Up to 9 triggers (0..8) implemented.
      
      
    
      001010
      
      Up to 10 triggers (0..9) implemented.
      
      
    and so on up to 0b100000, 32 triggers (0..31) implemented.All other values are reserved. If the Trace Extension is implemented, this field must be at least 001000. There is no guarantee that any of the implemented triggers, including the highest numbered, are connected to any components.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_7_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXTMUXNUM</spirit:name>
            <spirit:displayName>EXTMUXNUM</spirit:displayName>
            <spirit:description>Maximum number of external triggers available for multiplexing into the CTI. This relates only to additional external triggers outside those defined for v8-A.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVID1</spirit:name>
          <spirit:description>CTI Device ID Register 1</spirit:description>
          <spirit:addressOffset>0xFC4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVID1 -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVID1_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVID2</spirit:name>
          <spirit:description>CTI Device ID Register 2</spirit:description>
          <spirit:addressOffset>0xFC0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVID2 -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVID2_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVTYPE</spirit:name>
          <spirit:description>CTI Device Type Register</spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000014</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Subtype. Must read as 0x1 to indicate this is a processor component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAJOR</spirit:name>
            <spirit:displayName>MAJOR</spirit:displayName>
            <spirit:description>Major type. Must read as 0x4 to indicate this is a cross-trigger component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIGATE</spirit:name>
          <spirit:description>CTI Channel Gate Enable Register</spirit:description>
          <spirit:addressOffset>0x140</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000F</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIGATE -->
          <spirit:field>
            <spirit:name>RESERVED_CTIGATE_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GATEx</spirit:name>
            <spirit:displayName>GATEx</spirit:displayName>
            <spirit:description>Determines whether events on channels propagate through the CTM to other ECT components or from the CTM into the CTI</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN0</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 0</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN0 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN0_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 0 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN1</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 1</spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN1 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN1_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 1 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN2</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 2</spirit:description>
          <spirit:addressOffset>0x028</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN2 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN2_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 2 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN3</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 3</spirit:description>
          <spirit:addressOffset>0x02c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN3 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN3_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 3 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN4</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 4</spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN4 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN4_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 4 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN5</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 5</spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN5 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN5_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 5 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN6</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 6</spirit:description>
          <spirit:addressOffset>0x038</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN6 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN6_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 6 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN7</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 7</spirit:description>
          <spirit:addressOffset>0x03c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN7 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN7_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 7 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINTACK</spirit:name>
          <spirit:description>CTI Output Trigger Acknowledge Register</spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTIINTACK -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINTACK_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ACK_n</spirit:name>
            <spirit:displayName>ACK_n</spirit:displayName>
            <spirit:description>Can be used to create soft acknowledges for output triggers</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIITCTRL</spirit:name>
          <spirit:description>CTI Integration mode Control Register</spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIITCTRL -->
          <spirit:field>
            <spirit:name>RES0_CTIITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IME</spirit:name>
            <spirit:displayName>IME</spirit:displayName>
            <spirit:description>Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.
      0
      
      Normal operation.
      
      
    
      1
      
      Integration mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTILAR</spirit:name>
          <spirit:description>CTI Lock Access Register</spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTILAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTILSR</spirit:name>
          <spirit:description>CTI Lock Status Register</spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFC</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTILSR -->
          <spirit:field>
            <spirit:name>RES0_CTILSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:
      0
      
      Software lock not implemented or not memory-mapped access.
      
      
    
      1
      
      Software lock implemented and memory-mapped access.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN0</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 0</spirit:description>
          <spirit:addressOffset>0x0A0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN0 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN0_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 0 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN1</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 1</spirit:description>
          <spirit:addressOffset>0x0A4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN1 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN1_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 1 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN2</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 2</spirit:description>
          <spirit:addressOffset>0x0A8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN2 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN2_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 2 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN3</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 3</spirit:description>
          <spirit:addressOffset>0x0AC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN3 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN3_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 3 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN4</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 4</spirit:description>
          <spirit:addressOffset>0x0B0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN4 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN4_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 4 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN5</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 5</spirit:description>
          <spirit:addressOffset>0x0B4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN5 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN5_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 5 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN6</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 6</spirit:description>
          <spirit:addressOffset>0x0B8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN6 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN6_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 6 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN7</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 7</spirit:description>
          <spirit:addressOffset>0x0BC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN7 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN7_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 7 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR0</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000A8</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, least significant byte.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR1</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B9</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, most significant nibble.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR2</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Part major revision. Parts can also use this field to extend Part number to 16-bits.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR3</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>Part minor revision. Parts using CTIPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR4</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 4</spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR5</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 5</spirit:description>
          <spirit:addressOffset>0xFD4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR5 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIPIDR5_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR6</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 6</spirit:description>
          <spirit:addressOffset>0xFD8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR6 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIPIDR6_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR7</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 7</spirit:description>
          <spirit:addressOffset>0xFDC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR7 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIPIDR7_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTITRIGINSTATUS</spirit:name>
          <spirit:description>CTI Trigger In Status Register</spirit:description>
          <spirit:addressOffset>0x130</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTITRIGINSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTITRIGINSTATUS_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRINn</spirit:name>
            <spirit:displayName>TRINn</spirit:displayName>
            <spirit:description>Provides the status of the trigger inputs</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTITRIGOUTSTATUS</spirit:name>
          <spirit:description>CTI Trigger Out Status Register</spirit:description>
          <spirit:addressOffset>0x134</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTITRIGOUTSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTITRIGOUTSTATUS_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TROUTn</spirit:name>
            <spirit:displayName>TROUTn</spirit:displayName>
            <spirit:description>Provides the status of the trigger outputs</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_PMU_CPU1</spirit:name>
        <spirit:displayName>APBADDR_PMU_1</spirit:displayName>
        <spirit:description>APBADDR_PMU_1</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">1245184</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_PMU_CPU1>  -->
        <spirit:register>
          <spirit:name>PMAUTHSTATUS</spirit:name>
          <spirit:description>Performance Monitors Authentication Status Register</spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000088</spirit:value>
            <spirit:mask>0xFFFFFFBB</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMAUTHSTATUS -->
          <spirit:field>
            <spirit:name>RES0_PMAUTHSTATUS_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNID</spirit:name>
            <spirit:displayName>SNID</spirit:displayName>
            <spirit:description>Holds the same value as DBGAUTHSTATUS_EL1.SNID.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMAUTHSTATUS_5_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>Holds the same value as DBGAUTHSTATUS_EL1.NSNID.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMAUTHSTATUS_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCCFILTR_EL0</spirit:name>
          <spirit:description>Performance Monitors Cycle Counter Filter Register</spirit:description>
          <spirit:addressOffset>0x47C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCCFILTR_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count cycles in EL1.
      
      
    
      1
      
      Do not count cycles in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count cycles in EL0.
      
      
    
      1
      
      Do not count cycles in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, cycles in Non-secure EL1 are counted.Otherwise, cycles in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, cycles in Non-secure EL0 are counted.Otherwise, cycles in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count cycles in EL2.
      
      
    
      1
      
      Count cycles in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, cycles in Secure EL3 are counted.Otherwise, cycles in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMCCFILTR_EL0_25_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>26</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCCNTR_EL0_31:0</spirit:name>
          <spirit:description>Performance Monitors Cycle Counter (low word)</spirit:description>
          <spirit:addressOffset>0x0F8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCCNTR_EL0_31:0 -->
          <spirit:field>
            <spirit:name>CCNT</spirit:name>
            <spirit:displayName>CCNT</spirit:displayName>
            <spirit:description>Cycle count. Depending on the values of PMCR_EL0.{LC,D}, the cycle count increments in one of the following ways:Every processor clock cycle.Every 64th processor clock cycle.The cycle count can be reset to zero by writing 1 to PMCR_EL0.C.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCCNTR_EL0_63:32</spirit:name>
          <spirit:description>Performance Monitors Cycle Counter (high word)</spirit:description>
          <spirit:addressOffset>0x0FC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCCNTR_EL0_63:32 -->
          <spirit:field>
            <spirit:name>CCNT</spirit:name>
            <spirit:displayName>CCNT</spirit:displayName>
            <spirit:description>Cycle count. Depending on the values of PMCR_EL0.{LC,D}, the cycle count increments in one of the following ways:Every processor clock cycle.Every 64th processor clock cycle.The cycle count can be reset to zero by writing 1 to PMCR_EL0.C.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCEID0_EL0</spirit:name>
          <spirit:description>Performance Monitors Common Event Identification Register 0</spirit:description>
          <spirit:addressOffset>0xE20</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="immediate">1744814079</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCEID0_EL0 -->
          <spirit:field>
            <spirit:name>CE_31:0</spirit:name>
            <spirit:displayName>CE[31:0]</spirit:displayName>
            <spirit:description>Common architectural and microarchitectural feature events that can be counted by the PMU event counters.For each bit described in the following table, the event is implemented if the bit is set to 1, or not implemented if the bit is set to 0.BitEvent numberEvent mnemonic310x01FL1D_CACHE_ALLOCATE300x01ECHAIN290x01DBUS_CYCLES280x01CTTBR_WRITE_RETIRED270x01BINST_SPEC260x01AMEMORY_ERROR250x019BUS_ACCESS240x018L2D_CACHE_WB230x017L2D_CACHE_REFILL220x016L2D_CACHE210x015L1D_CACHE_WB200x014L1I_CACHE190x013MEM_ACCESS180x012BR_PRED170x011CPU_CYCLES160x010BR_MIS_PRED150x00FUNALIGNED_LDST_RETIRED140x00EBR_RETURN_RETIRED130x00DBR_IMMED_RETIRED120x00CPC_WRITE_RETIRED110x00BCID_WRITE_RETIRED100x00AEXC_RETURN90x009EXC_TAKEN80x008INST_RETIRED70x007ST_RETIRED60x006LD_RETIRED50x005L1D_TLB_REFILL40x004L1D_CACHE30x003L1D_CACHE_REFILL20x002L1I_TLB_REFILL10x001L1I_CACHE_REFILL00x000SW_INCR</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCEID1_EL0</spirit:name>
          <spirit:description>Performance Monitors Common Event Identification Register 1</spirit:description>
          <spirit:addressOffset>0xE24</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCEID1_EL0 -->
          <spirit:field>
            <spirit:name>RES0_PMCEID1_EL0_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CE_32</spirit:name>
            <spirit:displayName>CE[32]</spirit:displayName>
            <spirit:description>Common architectural and microarchitectural feature events that can be counted by the PMU event counters.For the bit described in the following table, the event is implemented if the bit is set to 1, or not implemented if the bit is set to 0.BitEvent numberEvent mnemonic00x020L2D_CACHE_ALLOCATE</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCFGR</spirit:name>
          <spirit:description>Performance Monitors Configuration Register</spirit:description>
          <spirit:addressOffset>0xE00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0001FF06</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCFGR -->
          <spirit:field>
            <spirit:name>RES0_PMCFGR_31_20</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>UEN</spirit:name>
            <spirit:displayName>UEN</spirit:displayName>
            <spirit:description>User-mode Enable Register supported. PMUSERENR_EL0 is not visible in the external debug interface, so this bit is RES0.</spirit:description>
            <spirit:bitOffset>19</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>This feature is not supported, so this bit is RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NA</spirit:name>
            <spirit:displayName>NA</spirit:displayName>
            <spirit:description>This feature is not supported, so this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EX</spirit:name>
            <spirit:displayName>EX</spirit:displayName>
            <spirit:description>Export supported. Value is IMPLEMENTATION DEFINED.
      0
      
      PMCR_EL0.X is RES0.
      
      
    
      1
      
      PMCR_EL0.X is read/write.
      
      
    </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCD</spirit:name>
            <spirit:displayName>CCD</spirit:displayName>
            <spirit:description>Cycle counter has prescale. This is RES1 if AArch32 is supported at any EL, and RES0 otherwise.
      0
      
      PMCR_EL0.D is RES0.
      
      
    
      1
      
      PMCR_EL0.D is read/write.
      
      
    </spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CC</spirit:name>
            <spirit:displayName>CC</spirit:displayName>
            <spirit:description>Dedicated cycle counter (counter 31) supported. This bit is RES1.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of counters. This field determines the spacing of counters in the memory-map.In v8-A the counters are at doubleword-aligned addresses, and the largest counter is 64-bits, so this field is 0b111111.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>N</spirit:name>
            <spirit:displayName>N</spirit:displayName>
            <spirit:description>Number of counters implemented in addition to the cycle counter, PMCCNTR_EL0. The maximum number of event counters is 31, so bits[7:5] are always RES0.
      00000000
      
      Only PMCCNTR_EL0 implemented.
      
      
    
      00000001
      
      PMCCNTR_EL0 plus one event counter implemented.
      
      
    and so on up to 0b00011111, which indicates PMCCNTR_EL0 and 31 event counters implemented.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR0</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR1</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR1 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, debug component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR2</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR3</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR3 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCNTENCLR_EL0</spirit:name>
          <spirit:description>Performance Monitors Count Enable Clear Register</spirit:description>
          <spirit:addressOffset>0xC20</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCNTENCLR_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 disable bit. Disables the cycle counter register. Possible values are:
      0
      
      When read, means the cycle counter is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter is enabled. When written, disables the cycle counter.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter disable bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values of each bit are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; is enabled. When written, disables PMEVCNTR&lt;x&gt;.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCNTENSET_EL0</spirit:name>
          <spirit:description>Performance Monitors Count Enable Set Register</spirit:description>
          <spirit:addressOffset>0xC00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCNTENSET_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 enable bit. Enables the cycle counter register. Possible values are:
      0
      
      When read, means the cycle counter is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter is enabled. When written, enables the cycle counter.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter enable bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values of each bit are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; event counter is enabled. When written, enables PMEVCNTR&lt;x&gt;.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCR_EL0</spirit:name>
          <spirit:description>Performance Monitors Control Register</spirit:description>
          <spirit:addressOffset>0xE04</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCR_EL0 -->
          <spirit:field>
            <spirit:name>RES0_PMCR_EL0_31_11</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RAZ/WI.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>21</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMCR_EL0_10_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LC</spirit:name>
            <spirit:displayName>LC</spirit:displayName>
            <spirit:description>Long cycle counter enable. Determines which PMCCNTR_EL0 bit generates an overflow recorded by PMOVSR[31].
      0
      
      Cycle counter overflow on increment that changes PMCCNTR_EL0[31] from 1 to 0.
      
      
    
      1
      
      Cycle counter overflow on increment that changes PMCCNTR_EL0[63] from 1 to 0.
      
      
    ARM deprecates use of PMCR_EL0.LC = 0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DP</spirit:name>
            <spirit:displayName>DP</spirit:displayName>
            <spirit:description>Disable cycle counter when event counting is prohibited. The possible values of this bit are:
      0
      
      PMCCNTR_EL0, if enabled, counts when event counting is prohibited.
      
      
    
      1
      
      PMCCNTR_EL0 does not count when event counting is prohibited.
      
      
    Event counting is prohibited when ProfilingProhibited(IsSecure(),PSTATE.EL) == TRUE.This bit is RW.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>X</spirit:name>
            <spirit:displayName>X</spirit:displayName>
            <spirit:description>Enable export of events in an IMPLEMENTATION DEFINED event stream. The possible values of this bit are:
      0
      
      Do not export events.
      
      
    
      1
      
      Export events where not prohibited.
      
      
    This bit is used to permit events to be exported to another debug device, such as an OPTIONAL trace extension, over an event bus. If the implementation does not include such an event bus, this bit is RAZ/WI.This bit does not affect the generation of Performance Monitors overflow interrupt requests or signaling to a cross-trigger interface (CTI) that can be implemented as signals exported from the processor.If the implementation does not include an exported event stream, this bit is RAZ/WI. Otherwise this bit is RW.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>D</spirit:name>
            <spirit:displayName>D</spirit:displayName>
            <spirit:description>Clock divider. The possible values of this bit are:
      0
      
      When enabled, PMCCNTR_EL0 counts every clock cycle.
      
      
    
      1
      
      When enabled, PMCCNTR_EL0 counts once every 64 clock cycles.
      
      
    This bit is RW.If PMCR_EL0.LC == 1, this bit is ignored and the cycle counter counts every clock cycle.ARM deprecates use of PMCR.D = 1.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>Cycle counter reset. This bit is WO. The effects of writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Reset PMCCNTR_EL0 to zero.
      
      
    This bit is always RAZ.Resetting PMCCNTR_EL0 does not clear the PMCCNTR_EL0 overflow bit to 0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>Event counter reset. This bit is WO. The effects of writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Reset all event counters, not including PMCCNTR_EL0, to zero.
      
      
    This bit is always RAZ.Resetting the event counters does not clear any overflow bits to 0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable. The possible values of this bit are:
      0
      
      All counters, including PMCCNTR_EL0, are disabled.
      
      
    
      1
      
      All counters are enabled by PMCNTENSET_EL0.
      
      
    This bit is RW.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVAFF0</spirit:name>
          <spirit:description>Performance Monitors Device Affinity Register 0</spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000001</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMDEVAFF0 -->
          <spirit:field>
            <spirit:name>PMDEVAFF0</spirit:name>
            <spirit:displayName>PMDEVAFF0</spirit:displayName>
            <spirit:description>MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVAFF1</spirit:name>
          <spirit:description>Performance Monitors Device Affinity Register 1</spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: PMDEVAFF1 -->
          <spirit:field>
            <spirit:name>PMDEVAFF1</spirit:name>
            <spirit:displayName>PMDEVAFF1</spirit:displayName>
            <spirit:description>MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVARCH</spirit:name>
          <spirit:description>Performance Monitors Device Architecture Register</spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47702a16</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For Performance Monitors, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For Performance Monitors, the revision defined by v8-A is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For Performance Monitors:Bits [15:12] are the architecture version, 0x2.Bits [11:0] are the architecture part number, 0xA16.This corresponds to Performance Monitors architecture version PMUv3.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVTYPE</spirit:name>
          <spirit:description>Performance Monitors Device Type Register</spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000016</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_PMDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Subtype. Must read as 0x1 to indicate this is a processor component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAJOR</spirit:name>
            <spirit:displayName>MAJOR</spirit:displayName>
            <spirit:description>Major type. Must read as 0x6 to indicate this is a performance monitor component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR0_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 0</spirit:description>
          <spirit:addressOffset>0x000</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR0_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR0_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR0_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR1_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 1</spirit:description>
          <spirit:addressOffset>0x008</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR1_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR1_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR1_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR2_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 2</spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR2_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR2_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR2_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR3_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 3</spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR3_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR3_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR3_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR4_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 4</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR4_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR4_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR4_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR5_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 5</spirit:description>
          <spirit:addressOffset>0x028</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR5_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR5_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR5_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER0_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 0</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER0_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER0_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER1_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 1</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER1_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER1_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER2_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 2</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER2_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER2_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER3_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 3</spirit:description>
          <spirit:addressOffset>0x40c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER3_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER3_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER4_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 4</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER4_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER4_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER5_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 5</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER5_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER5_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMINTENCLR_EL1</spirit:name>
          <spirit:description>Performance Monitors Interrupt Enable Clear Register</spirit:description>
          <spirit:addressOffset>0xC60</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMINTENCLR_EL1 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow interrupt request disable bit. Possible values are:
      0
      
      When read, means the cycle counter overflow interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter overflow interrupt request is enabled. When written, disables the cycle count overflow interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow interrupt request disable bit for PMEVCNTR&lt;x&gt;_EL0.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values are:
      0
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is enabled. When written, disables the PMEVCNTR&lt;x&gt;_EL0 interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMINTENSET_EL1</spirit:name>
          <spirit:description>Performance Monitors Interrupt Enable Set Register</spirit:description>
          <spirit:addressOffset>0xC40</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMINTENSET_EL1 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow interrupt request enable bit. Possible values are:
      0
      
      When read, means the cycle counter overflow interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter overflow interrupt request is enabled. When written, enables the cycle count overflow interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow interrupt request enable bit for PMEVCNTR&lt;x&gt;_EL0.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values are:
      0
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is enabled. When written, enables the PMEVCNTR&lt;x&gt;_EL0 interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMITCTRL</spirit:name>
          <spirit:description>Performance Monitors Integration mode Control Register</spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMITCTRL -->
          <spirit:field>
            <spirit:name>RES0_PMITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IME</spirit:name>
            <spirit:displayName>IME</spirit:displayName>
            <spirit:description>Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.
      0
      
      Normal operation.
      
      
    
      1
      
      Integration mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMLAR</spirit:name>
          <spirit:description>Performance Monitors Lock Access Register</spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: PMLAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMLSR</spirit:name>
          <spirit:description>Performance Monitors Lock Status Register</spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMLSR -->
          <spirit:field>
            <spirit:name>RES0_PMLSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:
      0
      
      Software lock not implemented or not memory-mapped access.
      
      
    
      1
      
      Software lock implemented and memory-mapped access.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMOVSCLR_EL0</spirit:name>
          <spirit:description>Performance Monitors Overflow Flag Status Clear Register</spirit:description>
          <spirit:addressOffset>0xC80</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMOVSCLR_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow bit. Possible values are:
      0
      
      When read, means the cycle counter has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter has overflowed. When written, clears the overflow bit to 0.
      
      
    PMCR_EL0.LC is used to control from which bit of PMCCNTR_EL0 (bit 31 or bit 63) an overflow is detected.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow clear bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values of each bit are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; has overflowed. When written, clears the PMEVCNTR&lt;x&gt; overflow bit to 0.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMOVSSET_EL0</spirit:name>
          <spirit:description>Performance Monitors Overflow Flag Status Set Register</spirit:description>
          <spirit:addressOffset>0xCC0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMOVSSET_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow bit. Possible values are:
      0
      
      When read, means the cycle counter has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter has overflowed. When written, sets the overflow bit to 1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow set bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; has overflowed. When written, sets the PMEVCNTR&lt;x&gt; overflow bit to 1.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR0</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000D3</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, least significant byte.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR1</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B9</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, most significant nibble.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR2</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Part major revision. Parts can also use this field to extend Part number to 16-bits.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR3</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>Part minor revision. Parts using PMPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR4</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 4</spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR5</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 5</spirit:description>
          <spirit:addressOffset>0xFD4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR5 -->
          <spirit:field>
            <spirit:name>RESERVED_PMPIDR5_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR6</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 6</spirit:description>
          <spirit:addressOffset>0xFD8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR6 -->
          <spirit:field>
            <spirit:name>RESERVED_PMPIDR6_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR7</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 7</spirit:description>
          <spirit:addressOffset>0xFDC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR7 -->
          <spirit:field>
            <spirit:name>RESERVED_PMPIDR7_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMSWINC_EL0</spirit:name>
          <spirit:description>Performance Monitors Software Increment Register</spirit:description>
          <spirit:addressOffset>0xCA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: PMSWINC_EL0 -->
          <spirit:field>
            <spirit:name>RESERVED_PMSWINC_EL0_31_6</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>26</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P_x</spirit:displayName>
            <spirit:description>Event counter software increment bit for PMEVCNTR&lt;x&gt;</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_CTI_CPU2</spirit:name>
        <spirit:displayName>APBADDR_CTI_2</spirit:displayName>
        <spirit:description>APBADDR_CTI_2</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">2228224</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_CTI_CPU2>  -->
        <spirit:register>
          <spirit:name>ASICCTL</spirit:name>
          <spirit:description>CTI External Multiplexor Control register</spirit:description>
          <spirit:addressOffset>0x144</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ASICCTL -->
          <spirit:field>
            <spirit:name>RES0_ASICCTL_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ASICCTL</spirit:name>
            <spirit:displayName>ASICCTL</spirit:displayName>
            <spirit:description>IMPLEMENTATION DEFINED ASIC control. Provides a control for external multiplexing of additional triggers into the CTI.If external multiplexing of trigger signals is implemented then the number of multiplexed signals on each trigger must be reflected in CTIDEVID.EXTMUXNUM.If CTIDEVID.EXTMUXNUM is zero, this field is RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAPPCLEAR</spirit:name>
          <spirit:description>CTI Application Trigger Clear Register</spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTIAPPCLEAR -->
          <spirit:field>
            <spirit:name>RESERVED_CTIAPPCLEAR_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTIAPPCLEARx</spirit:name>
            <spirit:displayName>CTIAPPCLEARx</spirit:displayName>
            <spirit:description>Application trigger &lt;x&gt; disable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAPPPULSE</spirit:name>
          <spirit:description>CTI Application Pulse Register</spirit:description>
          <spirit:addressOffset>0x01C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTIAPPPULSE -->
          <spirit:field>
            <spirit:name>RESERVED_CTIAPPPULSE_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTIAPPPULSEx</spirit:name>
            <spirit:displayName>CTIAPPPULSEx</spirit:displayName>
            <spirit:description>Generate event pulse on ECT channel &lt;x&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAPPSET</spirit:name>
          <spirit:description>CTI Application Trigger Set Register</spirit:description>
          <spirit:addressOffset>0x014</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIAPPSET -->
          <spirit:field>
            <spirit:name>RESERVED_CTIAPPSET_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTIAPPSETx</spirit:name>
            <spirit:displayName>CTIAPPSETx</spirit:displayName>
            <spirit:description>Application trigger &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAUTHSTATUS</spirit:name>
          <spirit:description>CTI Authentication Status Register</spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000A</spirit:value>
            <spirit:mask>0xFFFFFFAA</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIAUTHSTATUS -->
          <spirit:field>
            <spirit:name>RES0_CTIAUTHSTATUS_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>If EL3 is not implemented and the processor is Secure, holds the same value as DBGAUTHSTATUS_EL1.SNID.Otherwise, holds the same value as DBGAUTHSTATUS_EL1.NSNID.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSID</spirit:name>
            <spirit:displayName>NSID</spirit:displayName>
            <spirit:description>If EL3 is not implemented and the processor is Secure, holds the same value as DBGAUTHSTATUS_EL1.SID.Otherwise, holds the same value as DBGAUTHSTATUS_EL1.NSID.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICHINSTATUS</spirit:name>
          <spirit:description>CTI Channel In Status Register</spirit:description>
          <spirit:addressOffset>0x138</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICHINSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTICHINSTATUS_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CHINn</spirit:name>
            <spirit:displayName>CHINn</spirit:displayName>
            <spirit:description>Provides the raw status of the ECT channel inputs to the CTI</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICHOUTSTATUS</spirit:name>
          <spirit:description>CTI Channel Out Status Register</spirit:description>
          <spirit:addressOffset>0x13C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICHOUTSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTICHOUTSTATUS_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CHOUTn</spirit:name>
            <spirit:displayName>CHOUTn</spirit:displayName>
            <spirit:description>Provides the status of the ECT channel outputs from the CTI</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR0</spirit:name>
          <spirit:description>CTI Component Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR0 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR1</spirit:name>
          <spirit:description>CTI Component Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR1 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, debug component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR2</spirit:name>
          <spirit:description>CTI Component Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR2 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR3</spirit:name>
          <spirit:description>CTI Component Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR3 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICLAIMCLR</spirit:name>
          <spirit:description>CTI Claim Clear</spirit:description>
          <spirit:addressOffset>0xFA4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICLAIMCLR -->
          <spirit:field>
            <spirit:name>RESERVED_CTICLAIMCLR_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIMx</spirit:name>
            <spirit:displayName>CLAIMx</spirit:displayName>
            <spirit:description>Clear CLAIM tag</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICLAIMSET</spirit:name>
          <spirit:description>CTI Claim Set</spirit:description>
          <spirit:addressOffset>0xFA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000f</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICLAIMSET -->
          <spirit:field>
            <spirit:name>RESERVED_CTICLAIMSET_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIMx</spirit:name>
            <spirit:displayName>CLAIMx</spirit:displayName>
            <spirit:description>CLAIM tag set bit</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICONTROL</spirit:name>
          <spirit:description>CTI Control Register</spirit:description>
          <spirit:addressOffset>0x000</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICONTROL -->
          <spirit:field>
            <spirit:name>RES0_CTICONTROL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GLBEN</spirit:name>
            <spirit:displayName>GLBEN</spirit:displayName>
            <spirit:description>Enables or disables the CTI mapping functions. Possible values of this field are:
      0
      
      CTI mapping functions disabled.
      
      
    
      1
      
      CTI mapping functions enabled.
      
      
    When the mapping functions are disabled, no new events are signaled on either output triggers or output channels. If a previously asserted output trigger has not been acknowledged, it remains asserted after the mapping functions are disabled. All output triggers are disabled by CTI reset.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVAFF0</spirit:name>
          <spirit:description>CTI Device Affinity Register 0</spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000002</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVAFF0 -->
          <spirit:field>
            <spirit:name>CTIDEVAFF0</spirit:name>
            <spirit:displayName>CTIDEVAFF0</spirit:displayName>
            <spirit:description>MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVAFF1</spirit:name>
          <spirit:description>CTI Device Affinity Register 1</spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVAFF1 -->
          <spirit:field>
            <spirit:name>CTIDEVAFF1</spirit:name>
            <spirit:displayName>CTIDEVAFF1</spirit:displayName>
            <spirit:description>MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVARCH</spirit:name>
          <spirit:description>CTI Device Architecture Register</spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47701A14</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For CTI, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For CTI, the revision defined by v8-A is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For CTI:Bits [15:12] are the architecture version, 0x1.Bits [11:0] are the architecture part number, 0xA14.This corresponds to CTI architecture version CTIv2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVID</spirit:name>
          <spirit:description>CTI Device ID Register 0</spirit:description>
          <spirit:addressOffset>0xFC8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x01040800</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVID -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_31_26</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INOUT</spirit:name>
            <spirit:displayName>INOUT</spirit:displayName>
            <spirit:description>Input/output options. Indicates presence of the input gate. If the CTM is not implemented, this field is RAZ.
      00
      
      CTIGATE does not mask propagation of input events from external channels.
      
      
    
      01
      
      CTIGATE masks propagation of input events from external channels.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_23_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMCHAN</spirit:name>
            <spirit:displayName>NUMCHAN</spirit:displayName>
            <spirit:description>Number of ECT channels implemented. IMPLEMENTATION DEFINED. For v8-A, valid values are:
      000011
      
      3 channels (0..2) implemented.
      
      
    
      000100
      
      4 channels (0..3) implemented.
      
      
    
      000101
      
      5 channels (0..4) implemented.
      
      
    
      000110
      
      6 channels (0..5) implemented.
      
      
    and so on up to 0b100000, 32 channels (0..31) implemented.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_15_14</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMTRIG</spirit:name>
            <spirit:displayName>NUMTRIG</spirit:displayName>
            <spirit:description>Number of triggers implemented. IMPLEMENTATION DEFINED. This is one more than the index of the largest trigger, rather than the actual number of triggers.For v8-A, valid values are:
      000011
      
      Up to 3 triggers (0..2) implemented.
      
      
    
      001000
      
      Up to 8 triggers (0..7) implemented.
      
      
    
      001001
      
      Up to 9 triggers (0..8) implemented.
      
      
    
      001010
      
      Up to 10 triggers (0..9) implemented.
      
      
    and so on up to 0b100000, 32 triggers (0..31) implemented.All other values are reserved. If the Trace Extension is implemented, this field must be at least 001000. There is no guarantee that any of the implemented triggers, including the highest numbered, are connected to any components.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_7_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXTMUXNUM</spirit:name>
            <spirit:displayName>EXTMUXNUM</spirit:displayName>
            <spirit:description>Maximum number of external triggers available for multiplexing into the CTI. This relates only to additional external triggers outside those defined for v8-A.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVID1</spirit:name>
          <spirit:description>CTI Device ID Register 1</spirit:description>
          <spirit:addressOffset>0xFC4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVID1 -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVID1_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVID2</spirit:name>
          <spirit:description>CTI Device ID Register 2</spirit:description>
          <spirit:addressOffset>0xFC0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVID2 -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVID2_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVTYPE</spirit:name>
          <spirit:description>CTI Device Type Register</spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000014</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Subtype. Must read as 0x1 to indicate this is a processor component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAJOR</spirit:name>
            <spirit:displayName>MAJOR</spirit:displayName>
            <spirit:description>Major type. Must read as 0x4 to indicate this is a cross-trigger component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIGATE</spirit:name>
          <spirit:description>CTI Channel Gate Enable Register</spirit:description>
          <spirit:addressOffset>0x140</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000F</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIGATE -->
          <spirit:field>
            <spirit:name>RESERVED_CTIGATE_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GATEx</spirit:name>
            <spirit:displayName>GATEx</spirit:displayName>
            <spirit:description>Determines whether events on channels propagate through the CTM to other ECT components or from the CTM into the CTI</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN0</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 0</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN0 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN0_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 0 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN1</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 1</spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN1 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN1_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 1 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN2</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 2</spirit:description>
          <spirit:addressOffset>0x028</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN2 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN2_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 2 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN3</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 3</spirit:description>
          <spirit:addressOffset>0x02c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN3 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN3_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 3 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN4</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 4</spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN4 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN4_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 4 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN5</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 5</spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN5 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN5_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 5 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN6</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 6</spirit:description>
          <spirit:addressOffset>0x038</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN6 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN6_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 6 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN7</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 7</spirit:description>
          <spirit:addressOffset>0x03c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN7 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN7_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 7 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINTACK</spirit:name>
          <spirit:description>CTI Output Trigger Acknowledge Register</spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTIINTACK -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINTACK_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ACK_n</spirit:name>
            <spirit:displayName>ACK_n</spirit:displayName>
            <spirit:description>Can be used to create soft acknowledges for output triggers</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIITCTRL</spirit:name>
          <spirit:description>CTI Integration mode Control Register</spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIITCTRL -->
          <spirit:field>
            <spirit:name>RES0_CTIITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IME</spirit:name>
            <spirit:displayName>IME</spirit:displayName>
            <spirit:description>Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.
      0
      
      Normal operation.
      
      
    
      1
      
      Integration mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTILAR</spirit:name>
          <spirit:description>CTI Lock Access Register</spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTILAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTILSR</spirit:name>
          <spirit:description>CTI Lock Status Register</spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFC</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTILSR -->
          <spirit:field>
            <spirit:name>RES0_CTILSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:
      0
      
      Software lock not implemented or not memory-mapped access.
      
      
    
      1
      
      Software lock implemented and memory-mapped access.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN0</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 0</spirit:description>
          <spirit:addressOffset>0x0A0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN0 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN0_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 0 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN1</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 1</spirit:description>
          <spirit:addressOffset>0x0A4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN1 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN1_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 1 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN2</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 2</spirit:description>
          <spirit:addressOffset>0x0A8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN2 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN2_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 2 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN3</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 3</spirit:description>
          <spirit:addressOffset>0x0AC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN3 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN3_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 3 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN4</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 4</spirit:description>
          <spirit:addressOffset>0x0B0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN4 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN4_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 4 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN5</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 5</spirit:description>
          <spirit:addressOffset>0x0B4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN5 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN5_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 5 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN6</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 6</spirit:description>
          <spirit:addressOffset>0x0B8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN6 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN6_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 6 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN7</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 7</spirit:description>
          <spirit:addressOffset>0x0BC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN7 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN7_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 7 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR0</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000A8</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, least significant byte.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR1</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B9</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, most significant nibble.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR2</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Part major revision. Parts can also use this field to extend Part number to 16-bits.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR3</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>Part minor revision. Parts using CTIPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR4</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 4</spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR5</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 5</spirit:description>
          <spirit:addressOffset>0xFD4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR5 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIPIDR5_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR6</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 6</spirit:description>
          <spirit:addressOffset>0xFD8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR6 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIPIDR6_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR7</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 7</spirit:description>
          <spirit:addressOffset>0xFDC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR7 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIPIDR7_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTITRIGINSTATUS</spirit:name>
          <spirit:description>CTI Trigger In Status Register</spirit:description>
          <spirit:addressOffset>0x130</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTITRIGINSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTITRIGINSTATUS_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRINn</spirit:name>
            <spirit:displayName>TRINn</spirit:displayName>
            <spirit:description>Provides the status of the trigger inputs</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTITRIGOUTSTATUS</spirit:name>
          <spirit:description>CTI Trigger Out Status Register</spirit:description>
          <spirit:addressOffset>0x134</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTITRIGOUTSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTITRIGOUTSTATUS_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TROUTn</spirit:name>
            <spirit:displayName>TROUTn</spirit:displayName>
            <spirit:description>Provides the status of the trigger outputs</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_ETM_CPU3</spirit:name>
        <spirit:displayName>APBADDR_ETM_3</spirit:displayName>
        <spirit:description>APBADDR_ETM_3</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">3407872</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_ETM_CPU3>  -->
        <spirit:register>
          <spirit:name>TRCACATR0</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 0</spirit:description>
          <spirit:addressOffset>0x480</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR0_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR0_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR1</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 1</spirit:description>
          <spirit:addressOffset>0x488</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR1_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR1_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR2</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 2</spirit:description>
          <spirit:addressOffset>0x490</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR2_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR2_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR3</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 3</spirit:description>
          <spirit:addressOffset>0x498</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR3_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR3_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR4</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 4</spirit:description>
          <spirit:addressOffset>0x4a0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR4 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR4_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR4_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR5</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 5</spirit:description>
          <spirit:addressOffset>0x4a8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR5 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR5_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR5_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR6</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 6</spirit:description>
          <spirit:addressOffset>0x4b0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR6 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR6_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR6_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR7</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 7</spirit:description>
          <spirit:addressOffset>0x4B8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR7 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR7_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR7_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR0_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 0 (low word)</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR0_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR0_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 0 (high word)</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR0_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR1_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 1 (low word)</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR1_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR1_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 1 (high word)</spirit:description>
          <spirit:addressOffset>0x40c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR1_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR2_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 2 (low word)</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR2_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR2_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 2 (high word)</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR2_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR3_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 3 (low word)</spirit:description>
          <spirit:addressOffset>0x418</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR3_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR3_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 3 (high word)</spirit:description>
          <spirit:addressOffset>0x41c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR3_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR4_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 4 (low word)</spirit:description>
          <spirit:addressOffset>0x420</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR4_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR4_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 4 (high word)</spirit:description>
          <spirit:addressOffset>0x424</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR4_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR5_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 5 (low word)</spirit:description>
          <spirit:addressOffset>0x428</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR5_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR5_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 5 (high word)</spirit:description>
          <spirit:addressOffset>0x42c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR5_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR6_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 6 (low word)</spirit:description>
          <spirit:addressOffset>0x430</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR6_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR6_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 6 (high word)</spirit:description>
          <spirit:addressOffset>0x434</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR6_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR7_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 7 (low word)</spirit:description>
          <spirit:addressOffset>0x438</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR7_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR7_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 7 (high word)</spirit:description>
          <spirit:addressOffset>0x43c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR7_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCAUTHSTATUS</spirit:name>
          <spirit:description>Authentication Status Register </spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000088</spirit:value>
            <spirit:mask>0xFFFFFFBB</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCAUTHSTATUS -->
          <spirit:field>
            <spirit:name>RES0_TRCAUTHSTATUS_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNID</spirit:name>
            <spirit:displayName>SNID</spirit:displayName>
            <spirit:description>Indicates whether the system enables the trace unit to support Secure non-invasive debug:
      00
      
      The trace unit does not implement support for Secure non-invasive debug.
      
      
    
      01
      
      Reserved.
      
      
    
      10
      
      Secure non-invasive debug is disabled.
      
      
    
      11
      
      Secure non-invasive debug is enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SID</spirit:name>
            <spirit:displayName>SID</spirit:displayName>
            <spirit:description>Indicates whether the trace unit supports Secure invasive debug:
      00
      
      The trace unit does not support Secure invasive debug.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>Indicates whether the system enables the trace unit to support Non-secure non-invasive debug:
      00
      
      The trace unit does not implement support for Non-secure non-invasive debug.
      
      
    
      01
      
      Reserved.
      
      
    
      10
      
      Non-secure non-invasive debug is disabled.
      
      
    
      11
      
      Non-secure non-invasive debug is enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSID</spirit:name>
            <spirit:displayName>NSID</spirit:displayName>
            <spirit:description>Indicates whether the trace unit supports Non-secure invasive debug:
      00
      
      The trace unit does not support Non-secure invasive debug.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCAUXCTLR</spirit:name>
          <spirit:description>Auxiliary Control Register </spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCAUXCTLR -->
          <spirit:field>
            <spirit:name>AFREADY</spirit:name>
            <spirit:displayName>Always respond to AFREADY immediately</spirit:displayName>
            <spirit:description>Always respond to AFREADY immediately. Does not have any interaction with FIFO draining even in WFI state.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IDLEACK</spirit:name>
            <spirit:displayName>Force idle-drain acknowledge</spirit:displayName>
            <spirit:description>Force idle-drain acknowledge high CPU does not wait for trace to drain before entering WFX state. When this bit is set to 1 trace unit behavior deviates from architecturally-specified behavior.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OVFLW</spirit:name>
            <spirit:displayName>Overflow if synchronization is not completed</spirit:displayName>
            <spirit:description>Force an overflow if synchronization is not completed when second synchronization becomes due. When this bit is set to 1 the trace unit behavior deviates from architecturally-specified behavior.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SYNCDELAY</spirit:name>
            <spirit:displayName>Delay periodic synchronization</spirit:displayName>
            <spirit:description>Delay periodic synchronization if FIFO is more than half-full.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TSNODELAY</spirit:name>
            <spirit:displayName>Do not delay timestamp insertion</spirit:displayName>
            <spirit:description>Do not delay timestamp insertion based on FIFO depth.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AUTHNOFLUSH</spirit:name>
            <spirit:displayName>De-assertion of authentication inputs</spirit:displayName>
            <spirit:description>Do not flush trace on de-assertion of authentication inputs. When this bit is set to 1 the trace unit behavior deviates from architecturally-specified behavior.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCAUXCTLR_6_6</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COREIFEN</spirit:name>
            <spirit:displayName>Core interface enabled</spirit:displayName>
            <spirit:description>Keep core interface enabled regardless of trace enable register state</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCAUXCTLR_31_8</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCBBCTLR</spirit:name>
          <spirit:description>Branch Broadcast Control Register </spirit:description>
          <spirit:addressOffset>0x03C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCBBCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCBBCTLR_31_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>23</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MODE</spirit:name>
            <spirit:displayName>MODE</spirit:displayName>
            <spirit:description>Mode bit:
      0
      
      Exclude mode. Branch broadcasting is not enabled in the address range that RANGE defines. If RANGE==0 then branch broadcasting is enabled for the entire memory map.
      
      
    
      1
      
      Include mode. Branch broadcasting is enabled in the address range that RANGE defines. If RANGE==0 then the branch broadcasting behavior is UNPREDICTABLE.
      
      
    </spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RANGE</spirit:name>
            <spirit:displayName>RANGE</spirit:displayName>
            <spirit:description>Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each bit represents an address range comparator pair, so bit[n] controls the selection of address range comparator pair n. If bit[n] is:
      0
      
      The address range that address range comparator pair n defines is not selected.
      
      
    
      1
      
      The address range that address range comparator pair n defines is selected.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCCCTLR</spirit:name>
          <spirit:description>Cycle Count Control Register </spirit:description>
          <spirit:addressOffset>0x038</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFF000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCCCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCCCCTLR_31_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>THRESHOLD</spirit:name>
            <spirit:displayName>THRESHOLD</spirit:displayName>
            <spirit:description>Sets the threshold value for instruction trace cycle counting.The minimum threshold value that can be programmed into THRESHOLD is given in TRCIDR3.CCITMIN.Writing a value of zero might cause UNPREDICTABLE behaviour.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDCCTLR0</spirit:name>
          <spirit:description>Context ID Comparator Control Register 0 </spirit:description>
          <spirit:addressOffset>0x680</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDCCTLR0 -->
          <spirit:field>
            <spirit:name>COMP_n</spirit:name>
            <spirit:displayName>COMP&lt;n&gt;</spirit:displayName>
            <spirit:description>Controls the mask value that the trace unit applies to TRCCIDCVRn. Each bit in this field corresponds to a byte in TRCCIDCVRn. When a bit is:
      0
      
      The trace unit includes the relevant byte in TRCCIDCVRn when it performs the Context ID comparison.
      
      
    
      1
      
      The trace unit ignores the relevant byte in TRCCIDCVRn when it performs the Context ID comparison.
      
      
    Supported only if TRCIDR4.NUMCIDC &gt; n, otherwise the field is RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDCVR0</spirit:name>
          <spirit:description>Context ID Comparator Value Register 0 </spirit:description>
          <spirit:addressOffset>0x600</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCCIDCVR0 -->
          <spirit:field>
            <spirit:name>VALUE</spirit:name>
            <spirit:displayName>VALUE</spirit:displayName>
            <spirit:description>Context ID value. The implemented width of this field is IMPLEMENTATION DEFINED and is set by TRCIDR2.CIDSIZE. Unimplemented bits are RAZ/WI.After a processor reset, the ETM architecture assumes that the Context ID is zero until the processor updates the Context ID.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR0</spirit:name>
          <spirit:description>Component Identification Register 0 </spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR1</spirit:name>
          <spirit:description>Component Identification Register 1 </spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, to indicate that the ETM is a debug component, with CoreSight architecture compliant management registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR2</spirit:name>
          <spirit:description>Component Identification Register 2 </spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR3</spirit:name>
          <spirit:description>Component Identification Register 3 </spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCLAIMCLR</spirit:name>
          <spirit:description>Claim Tag Clear Register </spirit:description>
          <spirit:addressOffset>0xFA4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCLAIMCLR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCCLAIMCLR_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLR</spirit:name>
            <spirit:displayName>CLR</spirit:displayName>
            <spirit:description>Clears bits in the claim tag and determines the current value of the claim tag.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCLAIMSET</spirit:name>
          <spirit:description>Claim Tag Set Register </spirit:description>
          <spirit:addressOffset>0xFA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000F</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCLAIMSET -->
          <spirit:field>
            <spirit:name>RESERVED_TRCCLAIMSET_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SET</spirit:name>
            <spirit:displayName>SET</spirit:displayName>
            <spirit:description>Sets bits in the claim tag and determines the number of claim tag bits implemented.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTCTLR0</spirit:name>
          <spirit:description>Counter Control Register 0 </spirit:description>
          <spirit:addressOffset>0x150</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTCTLR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTCTLR0_31_18</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTCHAIN_n</spirit:name>
            <spirit:displayName>CNTCHAIN&lt;n&gt;</spirit:displayName>
            <spirit:description>For TRCCNTCTLR3 and TRCCNTCTLR1, controls whether counter &lt;n&gt; decrements when a reload event occurs for counter &lt;n-1&gt;:
      0
      
      
      
      
    
      1
      
      
      
      
    For TRCCNTCTLR2 and TRCCNTCTLR0, this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDSELF_n</spirit:name>
            <spirit:displayName>RLDSELF&lt;n&gt;</spirit:displayName>
            <spirit:description>Controls whether a reload event occurs for counter &lt;n&gt;, when counter &lt;n&gt; reaches zero:
      0
      
      The trace unit does not generate a reload event.
      
      
    
      1
      
      The trace unit generates a reload event for counter &lt;n&gt;, provided that the event resource that CNTEVENT&lt;n&gt; specifies is active.
      
      
    </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDEVENT_n</spirit:name>
            <spirit:displayName>RLDEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes a reload event for counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTEVENT_n</spirit:name>
            <spirit:displayName>CNTEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes counter &lt;n&gt; to decrement.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTCTLR1</spirit:name>
          <spirit:description>Counter Control Register 1 </spirit:description>
          <spirit:addressOffset>0x154</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFD7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTCTLR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTCTLR1_31_18</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTCHAIN_n</spirit:name>
            <spirit:displayName>CNTCHAIN&lt;n&gt;</spirit:displayName>
            <spirit:description>For TRCCNTCTLR3 and TRCCNTCTLR1, controls whether counter &lt;n&gt; decrements when a reload event occurs for counter &lt;n-1&gt;:
      0
      
      
      
      
    
      1
      
      
      
      
    For TRCCNTCTLR2 and TRCCNTCTLR0, this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDSELF_n</spirit:name>
            <spirit:displayName>RLDSELF&lt;n&gt;</spirit:displayName>
            <spirit:description>Controls whether a reload event occurs for counter &lt;n&gt;, when counter &lt;n&gt; reaches zero:
      0
      
      The trace unit does not generate a reload event.
      
      
    
      1
      
      The trace unit generates a reload event for counter &lt;n&gt;, provided that the event resource that CNTEVENT&lt;n&gt; specifies is active.
      
      
    </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDEVENT_n</spirit:name>
            <spirit:displayName>RLDEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes a reload event for counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTEVENT_n</spirit:name>
            <spirit:displayName>CNTEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes counter &lt;n&gt; to decrement.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTRLDVR0</spirit:name>
          <spirit:description>Counter Reload Value Registers 0</spirit:description>
          <spirit:addressOffset>0x140</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTRLDVR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTRLDVR0_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the reload value for counter &lt;n&gt;. When a reload event occurs for counter &lt;n&gt; then the trace unit copies the VALUE&lt;n&gt; field into counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTRLDVR1</spirit:name>
          <spirit:description>Counter Reload Value Registers 1</spirit:description>
          <spirit:addressOffset>0x144</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTRLDVR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTRLDVR1_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the reload value for counter &lt;n&gt;. When a reload event occurs for counter &lt;n&gt; then the trace unit copies the VALUE&lt;n&gt; field into counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTVR0</spirit:name>
          <spirit:description>Counter Value Registers 0</spirit:description>
          <spirit:addressOffset>0x160</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTVR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTVR0_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the count value of counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTVR1</spirit:name>
          <spirit:description>Counter Value Registers 1</spirit:description>
          <spirit:addressOffset>0x164</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTVR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTVR1_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the count value of counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCONFIGR</spirit:name>
          <spirit:description>Trace Configuration Register </spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000001</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCONFIGR -->
          <spirit:field>
            <spirit:name>RES0_TRCCONFIGR_31_18</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DV</spirit:name>
            <spirit:displayName>DV</spirit:displayName>
            <spirit:description>Data value tracing bit:
      0
      
      Data value tracing is disabled.
      
      
    
      1
      
      Data value tracing is enabled when INSTP0 is not 0b00.
      
      
    TRCIDR0.TRCDATA indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DA</spirit:name>
            <spirit:displayName>DA</spirit:displayName>
            <spirit:description>Data address tracing bit:
      0
      
      Data address tracing is disabled.
      
      
    
      1
      
      Data address tracing is enabled when INSTP0 is not 0b00.
      
      
    TRCIDR0.TRCDATA indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCCONFIGR_15_15</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>QE</spirit:name>
            <spirit:displayName>QE</spirit:displayName>
            <spirit:description>Q element enable field:
      00
      
      Q elements are disabled.
      
      
    
      01
      
      Q elements with instruction counts are enabled. Q elements without instruction counts are disabled.
      
      
    
      11
      
      Q elements with and without instruction counts are enabled.
      
      
    The value 0b10 is reserved.TRCIDR0.QSUPP indicates which values of this field are implemented.TRCCONFIGR.QE must be set to 0b00 if any of the following are true:TRCCONFIGR.INSTP0 is not 0b00.TRCCONFIGR.COND is not 0b000.TRCCONFIGR.BB is not 0.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RS</spirit:name>
            <spirit:displayName>RS</spirit:displayName>
            <spirit:description>Return stack enable bit.
      0
      
      Return stack is disabled.
      
      
    
      1
      
      Return stack is enabled.
      
      
    TRCIDR0.RETSTACK indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TS</spirit:name>
            <spirit:displayName>TS</spirit:displayName>
            <spirit:description>Global timestamp tracing bit:
      0
      
      Global timestamp tracing is disabled.
      
      
    
      1
      
      Global timestamp tracing is enabled. TRCTSCTLR controls the insertion of timestamps in the trace.
      
      
    TRCIDR0.TSSIZE indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COND</spirit:name>
            <spirit:displayName>COND</spirit:displayName>
            <spirit:description>Conditional instruction tracing bit. The permitted values are:
      000
      
      Conditional instruction tracing is disabled.
      
      
    
      001
      
      Conditional load instructions are traced.
      
      
    
      010
      
      Conditional store instructions are traced.
      
      
    
      011
      
      Conditional load and store instructions are traced.
      
      
    
      111
      
      All conditional instructions are traced.
      
      
    All other values are reserved.TRCIDR0.TRCCOND indicates whether this field is supported. If it is not supported then this field is RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VMID</spirit:name>
            <spirit:displayName>VMID</spirit:displayName>
            <spirit:description>VMID tracing bit:
      0
      
      VMID tracing is disabled.
      
      
    
      1
      
      VMID tracing is enabled.
      
      
    TRCIDR2.VMIDSIZE indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CID</spirit:name>
            <spirit:displayName>CID</spirit:displayName>
            <spirit:description>Context ID tracing bit:
      0
      
      Context ID tracing is disabled.
      
      
    
      1
      
      Context ID tracing is enabled.
      
      
    TRCIDR2.CIDSIZE indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCCONFIGR_5_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCI</spirit:name>
            <spirit:displayName>CCI</spirit:displayName>
            <spirit:description>Cycle counting instruction trace bit:
      0
      
      Cycle counting in the instruction trace is disabled.
      
      
    
      1
      
      Cycle counting in the instruction trace is enabled. TRCCCCTLR controls the threshold value for cycle counting.
      
      
    TRCIDR0.TRCCCI indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BB</spirit:name>
            <spirit:displayName>BB</spirit:displayName>
            <spirit:description>Branch broadcast mode bit:
      0
      
      Branch broadcast mode is disabled.
      
      
    
      1
      
      Branch broadcast mode is enabled. TRCBBCTLR controls which regions of memory are enabled to use branch broadcasting.
      
      
    TRCIDR0.TRCBB indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INSTP0</spirit:name>
            <spirit:displayName>INSTP0</spirit:displayName>
            <spirit:description>Instruction P0 bit. This field controls whether load and store instructions are traced as P0 instructions:
      00
      
      Do not trace load and store instructions as P0 instructions.
      
      
    
      01
      
      Trace load instructions as P0 instructions.
      
      
    
      10
      
      Trace store instructions as P0 instructions.
      
      
    
      11
      
      Trace load and store instructions as P0 instructions.
      
      
    TRCIDR0.INSTP0 indicates whether this field is supported. If it is not supported then this field is RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES1_TRCCONFIGR_0_0</spirit:name>
            <spirit:displayName>1</spirit:displayName>
            <spirit:description>Reserved, RES1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVAFF0</spirit:name>
          <spirit:description>Device Affinity Register 0 </spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000003</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVAFF0 -->
          <spirit:field>
            <spirit:name>MPIDR_EL1_31:0</spirit:name>
            <spirit:displayName>MPIDR_EL1[31:0]</spirit:displayName>
            <spirit:description>Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVAFF1</spirit:name>
          <spirit:description>Device Affinity Register 1 </spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVAFF1 -->
          <spirit:field>
            <spirit:name>MPIDR_EL1_63:32</spirit:name>
            <spirit:displayName>MPIDR_EL1[63:32]</spirit:displayName>
            <spirit:description>Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVARCH</spirit:name>
          <spirit:description>Device Architecture Register </spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47704A13</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For trace, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is RAO.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For trace, the revision defined by ETMv4 is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For trace, bits [15:12] are the architecture version, 0x4; bits [11:0] are the architecture part number, 0xA13.This corresponds to trace architecture version ETMv4.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVID</spirit:name>
          <spirit:description>Device ID Register </spirit:description>
          <spirit:addressOffset>0xFC8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCDEVID -->
          <spirit:field>
            <spirit:name>DEVID</spirit:name>
            <spirit:displayName>DEVID</spirit:displayName>
            <spirit:description>Indicates the capabilities of the trace unit. The implemented width of this field and its bit assignments are IMPLEMENTATION DEFINED. Unimplemented bits are RAZ/WI.If a component is configurable then ARM recommends that this field can also indicate which configuration options are implemented that differ from the standard configuration.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVTYPE</spirit:name>
          <spirit:description>Device Type Register </spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000013</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_TRCDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Returns 0x1, to indicate that the ETM generates processor trace.All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAIN</spirit:name>
            <spirit:displayName>MAIN</spirit:displayName>
            <spirit:description>Returns 0x3, to indicate that the ETM is a trace source.All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCEVENTCTL0R</spirit:name>
          <spirit:description>Event Control 0 Register </spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0x70707070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCEVENTCTL0R -->
          <spirit:field>
            <spirit:name>TYPE3</spirit:name>
            <spirit:displayName>TYPE3</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 3</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_30_28</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL3</spirit:name>
            <spirit:displayName>SEL3</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE3</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE2</spirit:name>
            <spirit:displayName>TYPE2</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 2</spirit:description>
            <spirit:bitOffset>23</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_22_20</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL2</spirit:name>
            <spirit:displayName>SEL2</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE2</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE1</spirit:name>
            <spirit:displayName>TYPE1</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 1</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_14_12</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL1</spirit:name>
            <spirit:displayName>SEL1</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE1</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE0</spirit:name>
            <spirit:displayName>TYPE0</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 0</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_6_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL0</spirit:name>
            <spirit:displayName>SEL0</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCEVENTCTL1R</spirit:name>
          <spirit:description>Event Control 1 Register </spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFE7F0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCEVENTCTL1R -->
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL1R_31_13</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>19</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LPOVERRIDE</spirit:name>
            <spirit:displayName>LPOVERRIDE</spirit:displayName>
            <spirit:description>Low power state behavior override</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATB</spirit:name>
            <spirit:displayName>ATB</spirit:displayName>
            <spirit:description>ATB trigger enable</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL1R_10_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EN</spirit:name>
            <spirit:displayName>EN</spirit:displayName>
            <spirit:description>One bit per event to enable generation of an event element in the instruction trace stream when the selected event occurs</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCEXTINSELR</spirit:name>
          <spirit:description>External Input Select Register </spirit:description>
          <spirit:addressOffset>0x120</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0x80808080</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCEXTINSELR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_31_29</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL3</spirit:name>
            <spirit:displayName>SEL3</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 3.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_23_21</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL2</spirit:name>
            <spirit:displayName>SEL2</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 2</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_15_13</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL1</spirit:name>
            <spirit:displayName>SEL1</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 1</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_7_5</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL0</spirit:name>
            <spirit:displayName>SEL0</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR0</spirit:name>
          <spirit:description>ID Register 0 </spirit:description>
          <spirit:addressOffset>0x1E0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x28000EA1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_31_30</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COMMOPT</spirit:name>
            <spirit:displayName>COMMOPT</spirit:displayName>
            <spirit:description>Conditional instruction tracing support bit. Indicates if the trace unit supports conditional instruction tracing:
      0
      
      Conditional instruction tracing is not supported.
      
      
    
      1
      
      Conditional instruction tracing is supported, so TRCCONFIGR.COND is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TSSIZE</spirit:name>
            <spirit:displayName>TSSIZE</spirit:displayName>
            <spirit:description>Global timestamp size field. The permitted values are:
      00000
      
      Global timestamping is not implemented.
      
      
    
      00110
      
      Implementation supports a maximum global timestamp of 48bits.
      
      
    
      01000
      
      Implementation supports a maximum global timestamp of 64bits.
      
      
    All other values are reserved.When global timestamping is implemented then TRCCONFIGR.TS and TRCTSCTLR are supported.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_23_17</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>QSUPP</spirit:name>
            <spirit:displayName>QSUPP</spirit:displayName>
            <spirit:description>Q element support field. The permitted values are:
      00
      
      Q element support is not implemented. TRCCONFIGR.QE is RES0.
      
      
    
      01
      
      Q element support is implemented, and only supports Q elements with instruction counts. TRCCONFIGR.QE can only take the values 0b00 or 0b01.
      
      
    
      10
      
      Q element support is implemented, and only supports Q elements without instruction counts. TRCCONFIGR.QE can only take the values 0b00 or 0b11.
      
      
    
      11
      
      Q element support is implemented, and supports both Q elements with instruction counts and Q elements without instruction counts. TRCCONFIGR.QE is fully implemented.
      
      
    </spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>QFILT</spirit:name>
            <spirit:displayName>QFILT</spirit:displayName>
            <spirit:description>Q element filtering support field. The permitted values are:
      0
      
      Q element filtering is not implemented.
      
      
    
      1
      
      Q element filtering is implemented. TRCQCTLR is implemented.
      
      
    When QSUPP==0b00, this field is RES0.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONDTYPE</spirit:name>
            <spirit:displayName>CONDTYPE</spirit:displayName>
            <spirit:description>Conditional tracing field. The permitted values are:
      00
      
      The trace unit indicates only if a conditional instruction is a pass or fail.
      
      
    
      01
      
      The trace unit provides the Current Program Status Register (CPSR) status, for a conditional instruction.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMEVENT</spirit:name>
            <spirit:displayName>NUMEVENT</spirit:displayName>
            <spirit:description>Number of events field. Indicates how many events the trace unit supports:
      00
      
      The trace unit supports 1 event.
      
      
    
      01
      
      The trace unit supports 2 events.
      
      
    
      10
      
      The trace unit supports 3 events.
      
      
    
      11
      
      The trace unit supports 4 events.
      
      
    This field controls how many fields are supported in TRCEVENTCTL0R, and indicates the size of TRCEVENTCTL1R.INSTEN.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RETSTACK</spirit:name>
            <spirit:displayName>RETSTACK</spirit:displayName>
            <spirit:description>Return stack bit. Indicates if the implementation supports a return stack:
      0
      
      Return stack is not implemented.
      
      
    
      1
      
      Return stack is implemented, so TRCCONFIGR.RS is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_8_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCCCI</spirit:name>
            <spirit:displayName>TRCCCI</spirit:displayName>
            <spirit:description>Cycle counting instruction bit. Indicates if the trace unit supports cycle counting for instructions:
      0
      
      Cycle counting in the instruction trace is not implemented.
      
      
    
      1
      
      Cycle counting in the instruction trace is implemented, so TRCCONFIGR.CCI and TRCCCCTLR are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCCOND</spirit:name>
            <spirit:displayName>TRCCOND</spirit:displayName>
            <spirit:description>Conditional instruction tracing support bit. Indicates if the trace unit supports conditional instruction tracing:
      0
      
      Conditional instruction tracing is not supported.
      
      
    
      1
      
      Conditional instruction tracing is supported, so TRCCONFIGR.COND is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCBB</spirit:name>
            <spirit:displayName>TRCBB</spirit:displayName>
            <spirit:description>Branch broadcast tracing support bit. Indicates if the trace unit supports branch broadcast tracing:
      0
      
      Branch broadcast tracing is not supported.
      
      
    
      1
      
      Branch broadcast tracing is supported, so TRCCONFIGR.BB and TRCBBCTLR are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCDATA</spirit:name>
            <spirit:displayName>TRCDATA</spirit:displayName>
            <spirit:description>Conditional tracing field. The permitted values are:
      00
      
      Data tracing is not supported.
      
      
    
      11
      
      Tracing of data addresses and data values is supported, so TRCCONFIGR.DA, TRCCONFIGR.DV, TRCSTALLCTLR.DATADISCARD, TRCSTALLCTLR.INSTPRIORITY, TRCSTALLCTLR.DSTALL, and TRCEVENTCTL1R.DATAEN are supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INSTP0</spirit:name>
            <spirit:displayName>INSTP0</spirit:displayName>
            <spirit:description>P0 tracing support field. The permitted values are:
      00
      
      Tracing of load and store instructions as P0 elements is not supported.
      
      
    
      11
      
      Tracing of load and store instructions as P0 elements is supported, so TRCCONFIGR.INSTP0 is supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_0_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR1</spirit:name>
          <spirit:description>ID Register 1 </spirit:description>
          <spirit:addressOffset>0x1E4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x4100F404</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR1 -->
          <spirit:field>
            <spirit:name>DESIGNER</spirit:name>
            <spirit:displayName>DESIGNER</spirit:displayName>
            <spirit:description>Indicates which company designed the trace unit. The permitted values are:
      01000001
      
      ARM Limited.
      
      
    
      01000100
      
      Digital Equipment Corporation.
      
      
    
      01001101
      
      Motorola, Freescale Semiconductor Inc.
      
      
    
      01010001
      
      QUALCOMM Inc.
      
      
    
      01010110
      
      Marvell Semiconductor Inc.
      
      
    
      01101001
      
      Intel Corporation.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR1_23_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES1_TRCIDR1_15_12</spirit:name>
            <spirit:displayName>1</spirit:displayName>
            <spirit:description>Reserved, RES1.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCARCHMAJ</spirit:name>
            <spirit:displayName>TRCARCHMAJ</spirit:displayName>
            <spirit:description>Indicates the major version of the ETM architecture. The permitted value is:
      100
      
      ETMv4.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCARCHMIN</spirit:name>
            <spirit:displayName>TRCARCHMIN</spirit:displayName>
            <spirit:description>Indicates the minor version of the ETM architecture. The permitted value is:
      0
      
      ETMv4 minor version 0.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Returns an IMPLEMENTATION DEFINED value that identifies the revision of the trace registers and the OS Save and Restore registers.ARM recommends:That the initial implementation sets REVISION==0x0 and the field then increments for any subsequent implementations. However, it is acceptable to omit some values or use another scheme to identify the revision number.That TRCPIDR2.REVISION==TRCIDR1.REVISION. However, in situations where it is difficult to align these fields, such as with a metal layer fix, then it is acceptable to change the REVISION fields independently.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR10</spirit:name>
          <spirit:description>ID Register 10 </spirit:description>
          <spirit:addressOffset>0x188</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR10 -->
          <spirit:field>
            <spirit:name>NUMP1KEY</spirit:name>
            <spirit:displayName>NUMP1KEY</spirit:displayName>
            <spirit:description>Indicates the number of P1 right-hand keys that the trace unit can use. The number includes normal and special keys.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR11</spirit:name>
          <spirit:description>ID Register 11 </spirit:description>
          <spirit:addressOffset>0x18C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR11 -->
          <spirit:field>
            <spirit:name>NUMP1SPC</spirit:name>
            <spirit:displayName>NUMP1SPC</spirit:displayName>
            <spirit:description>Indicates the number of special P1 right-hand keys that the trace unit can use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR12</spirit:name>
          <spirit:description>ID Register 12 </spirit:description>
          <spirit:addressOffset>0x190</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR12 -->
          <spirit:field>
            <spirit:name>NUMCONDKEY</spirit:name>
            <spirit:displayName>NUMCONDKEY</spirit:displayName>
            <spirit:description>Indicates the number of conditional instruction right-hand keys that the trace unit can use. The number includes normal and special keys.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR13</spirit:name>
          <spirit:description>ID Register 13 </spirit:description>
          <spirit:addressOffset>0x194</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR13 -->
          <spirit:field>
            <spirit:name>NUMCONDSPC</spirit:name>
            <spirit:displayName>NUMCONDSPC</spirit:displayName>
            <spirit:description>Indicates the number of special conditional instruction right-hand keys that the trace unit can use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR2</spirit:name>
          <spirit:description>ID Register 2 </spirit:description>
          <spirit:addressOffset>0x1E8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000488</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCIDR2_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCSIZE</spirit:name>
            <spirit:displayName>CCSIZE</spirit:displayName>
            <spirit:description>Indicates the size of the cycle counter in bits minus 12.
      0000
      
      The cycle counter is 12 bits in length.
      
      
    
      0001
      
      The cycle counter is 13 bits in length.
      
      
    and so on up to 0b1000, indicating the cycle counter is 20 bits in length.All other values are reserved.If cycle counting is not implemented, as indicated by TRCIDR0.TRCCCI, this field is 0b0000.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DVSIZE</spirit:name>
            <spirit:displayName>DVSIZE</spirit:displayName>
            <spirit:description>Indicates the data value size in bytes. The permitted values are:
      00000
      
      Data value tracing is not supported. Therefore, an implementation must also set TRCIDR0.TRCDATA==0b00.
      
      
    
      00100
      
      Maximum of 32-bit data value size.
      
      
    
      01000
      
      Maximum of 64-bit data value size.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DASIZE</spirit:name>
            <spirit:displayName>DASIZE</spirit:displayName>
            <spirit:description>Indicates the data address size in bytes. The permitted values are:
      00000
      
      Data address tracing is not supported. Therefore, an implementation must also set TRCIDR0.TRCDATA==0b00.
      
      
    
      00100
      
      Maximum of 32-bit data address size.
      
      
    
      01000
      
      Maximum of 64-bit data address size.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VMIDSIZE</spirit:name>
            <spirit:displayName>VMIDSIZE</spirit:displayName>
            <spirit:description>Indicates the VMID size. The permitted values are:
      00000
      
      VMID tracing is not supported.
      
      
    
      00001
      
      Maximum of 8-bit VMID size, so TRCCONFIGR.VMID is supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CIDSIZE</spirit:name>
            <spirit:displayName>CIDSIZE</spirit:displayName>
            <spirit:description>Indicates the Context ID size. The permitted values are:
      00000
      
      Context ID tracing is not supported.
      
      
    
      00100
      
      Maximum of 32-bit Context ID size, so TRCCONFIGR.CID is supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IASIZE</spirit:name>
            <spirit:displayName>IASIZE</spirit:displayName>
            <spirit:description>Indicates the instruction address size. The permitted values are:
      00100
      
      Maximum of 32-bit address size.
      
      
    
      01000
      
      Maximum of 64-bit address size.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR3</spirit:name>
          <spirit:description>ID Register 3 </spirit:description>
          <spirit:addressOffset>0x1EC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0D7B0004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR3 -->
          <spirit:field>
            <spirit:name>NOOVERFLOW</spirit:name>
            <spirit:displayName>NOOVERFLOW</spirit:displayName>
            <spirit:description>Indicates if TRCSTALLCTLR.NOOVERFLOW is supported:
      0
      
      TRCSTALLCTLR.NOOVERFLOW is not supported, or STALLCTL==0.
      
      
    
      1
      
      TRCSTALLCTLR.NOOVERFLOW is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMPROC</spirit:name>
            <spirit:displayName>NUMPROC</spirit:displayName>
            <spirit:description>Indicates the number of processors available for tracing. The possible values are:
      000
      
      The trace unit can trace one processor.
      
      
    
      001
      
      The trace unit can trace two processors.
      
      
    
      010
      
      The trace unit can trace three processors.
      
      
    and so on up to 0b111, which indicates the trace unit can trace eight processors.This field sets the maximum value of TRCPROCSELR.PROCSEL.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SYSSTALL</spirit:name>
            <spirit:displayName>SYSSTALL</spirit:displayName>
            <spirit:description>Indicates if the implementation can support stall control:
      0
      
      The system does not support stall control of the processor.
      
      
    
      1
      
      The system can support stall control of the processor.
      
      
    The system supports stalling of the processor only when SYSSTALL==1 and STALLCTL==1.</spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STALLCTL</spirit:name>
            <spirit:displayName>STALLCTL</spirit:displayName>
            <spirit:description>Indicates if TRCSTALLCTLR is supported:
      0
      
      TRCSTALLCTLR is not supported.
      
      
    
      1
      
      TRCSTALLCTLR is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SYNCPR</spirit:name>
            <spirit:displayName>SYNCPR</spirit:displayName>
            <spirit:description>Indicates if an implementation has a fixed synchronization period:
      0
      
      TRCSYNCPR is read-write so software can change the synchronization period.
      
      
    
      1
      
      TRCSYNCPR is read-only so the synchronization period is fixed.
      
      
    </spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCERR</spirit:name>
            <spirit:displayName>TRCERR</spirit:displayName>
            <spirit:description>Indicates if TRCVICTLR.TRCERR is supported:
      0
      
      TRCVICTLR.TRCERR is not supported
      
      
    
      1
      
      TRCVICTLR.TRCERR is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit indicates whether instruction tracing is supported for the corresponding exception level:
      0
      
      In Non-secure state, exception level n is not supported so the corresponding bits in TRCACATRn.EXLEVEL_NS and TRCVICTLR.EXLEVEL_NS are not supported.
      
      
    
      1
      
      In Non-secure state, exception level n is supported so the corresponding bits in TRCACATRn.EXLEVEL_NS and TRCVICTLR.EXLEVEL_NS are supported.
      
      
    The exception levels are:Bit[20]Exception level 0.Bit[21]Exception level 1.Bit[22]Exception level 2.Bit[23]SBZ. EXLEVEL_NS[3] is never implemented.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit indicates whether instruction tracing is supported for the corresponding exception level:
      0
      
      In Secure state, exception level n is not supported so the corresponding bits in TRCACATRn.EXLEVEL_S and TRCVICTLR.EXLEVEL_S are not supported.
      
      
    
      1
      
      In Secure state, exception level n is supported so the corresponding bits in TRCACATRn.EXLEVEL_S and TRCVICTLR.EXLEVEL_S are supported.
      
      
    The exception levels are:Bit[16]Exception level 0.Bit[17]Exception level 1.Bit[18]SBZ. EXLEVEL_S[2] is never implemented.Bit[19]Exception level 3.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR3_15_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCITMIN</spirit:name>
            <spirit:displayName>CCITMIN</spirit:displayName>
            <spirit:description>Indicates the minimum value that can be programmed in TRCCCCTLR.THRESHOLD.When cycle counting in the instruction trace is supported, that is TRCIDR0.TRCCCI==1, then the minimum value of this field is 0x001, otherwise it is 0x000.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR4</spirit:name>
          <spirit:description>ID Register 4 </spirit:description>
          <spirit:addressOffset>0x1F0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x11170004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR4 -->
          <spirit:field>
            <spirit:name>NUMVMIDC</spirit:name>
            <spirit:displayName>NUMVMIDC</spirit:displayName>
            <spirit:description>Indicates the number of VMID comparators that are available for tracing. The permitted values are:
      0000
      
      No VMID comparators are available.
      
      
    
      0001
      
      The implementation has one VMID comparator.
      
      
    
      0010
      
      The implementation has two VMID comparators.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight VMID comparators.All other values are reserved.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMCIDC</spirit:name>
            <spirit:displayName>NUMCIDC</spirit:displayName>
            <spirit:description>Indicates the number of Context ID comparators that are available for tracing. The permitted values are:
      0000
      
      No Context ID comparators are available.
      
      
    
      0001
      
      The implementation has one Context ID comparator.
      
      
    
      0010
      
      The implementation has two Context ID comparators.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight Context ID comparators.All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMSSCC</spirit:name>
            <spirit:displayName>NUMSSCC</spirit:displayName>
            <spirit:description>Indicates the number of single-shot comparator controls that are available for tracing. The permitted values are:
      0000
      
      No single-shot comparator controls are available.
      
      
    
      0001
      
      The implementation has one single-shot comparator control.
      
      
    
      0010
      
      The implementation has two single-shot comparator controls.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight single-shot comparator controls.All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMRSPAIR</spirit:name>
            <spirit:displayName>NUMRSPAIR</spirit:displayName>
            <spirit:description>Indicates the number of resource selection pairs that are available for tracing. The permitted values are:
      0000
      
      The implementation has one resource selection pair.
      
      
    
      0001
      
      The implementation has two resource selection pairs.
      
      
    
      0010
      
      The implementation has three resource selection pairs.
      
      
    and so on up to 0b1111, which indicates that the implementation has 16 resource selection pairs.Implementations always have at least one resource selection pair so that they can support the FALSE and TRUE resource selectors, 0 and 1.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMPC</spirit:name>
            <spirit:displayName>NUMPC</spirit:displayName>
            <spirit:description>Indicates the number of processor comparator inputs that are available for tracing. The permitted values are:
      0000
      
      No processor comparator inputs are available.
      
      
    
      0001
      
      The implementation has one processor comparator input.
      
      
    
      0010
      
      The implementation has two processor comparator inputs.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight processor comparator inputs.All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR4_11_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUPPDAC</spirit:name>
            <spirit:displayName>SUPPDAC</spirit:displayName>
            <spirit:description>Indicates if the implementation can support data address comparisons:
      0
      
      The implementation does not support data address comparisons.
      
      
    
      1
      
      The implementation can support data address comparisons
      
      
    </spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMDVC</spirit:name>
            <spirit:displayName>NUMDVC</spirit:displayName>
            <spirit:description>Indicates the number of data value comparators that are available for tracing. The permitted values are:
      0000
      
      No data value comparators are available.
      
      
    
      0001
      
      The implementation has one data value comparator.
      
      
    
      0010
      
      The implementation has two data value comparators.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight data value comparators.All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMACPAIRS</spirit:name>
            <spirit:displayName>NUMACPAIRS</spirit:displayName>
            <spirit:description>Indicates the number of address comparator pairs that are available for tracing. The permitted values are:
      0000
      
      No address comparator pairs are available.
      
      
    
      0001
      
      The implementation has one address comparator pair.
      
      
    
      0010
      
      The implementation has two address comparator pairs.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight address comparator pairs.All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR5</spirit:name>
          <spirit:description>ID Register 5 </spirit:description>
          <spirit:addressOffset>0x1F4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x28C7081E</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR5 -->
          <spirit:field>
            <spirit:name>REDFUNCNTR</spirit:name>
            <spirit:displayName>REDFUNCNTR</spirit:displayName>
            <spirit:description>Indicates if the reduced function counter is implemented:
      0
      
      The reduced function counter is not supported.
      
      
    
      1
      
      Counter 0 is implemented as a reduced function counter.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMCNTR</spirit:name>
            <spirit:displayName>NUMCNTR</spirit:displayName>
            <spirit:description>Indicates the number of counters that are available for tracing. The permitted values are:
      000
      
      No counters are available.
      
      
    
      001
      
      The implementation has one counter.
      
      
    
      010
      
      The implementation has two counters.
      
      
    
      011
      
      The implementation has three counters.
      
      
    
      100
      
      The implementation has four counters.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMSEQSTATE</spirit:name>
            <spirit:displayName>NUMSEQSTATE</spirit:displayName>
            <spirit:description>Indicates the number of sequencer states that are implemented. The permitted values are:
      000
      
      No sequencer states are implemented.
      
      
    
      100
      
      The implementation has four sequencer states.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR5_24_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LPOVERRIDE</spirit:name>
            <spirit:displayName>LPOVERRIDE</spirit:displayName>
            <spirit:description>Indicates if the implementation can support low-power state override:
      0
      
      The implementation does not support low-power state override.
      
      
    
      1
      
      The implementation supports low-power state override, and the TRCEVENTCTL1R.LPOVERRIDE field is implemented.
      
      
    The trace unit must support low-power state override if it can enter a low-power mode where the resources and event trace generation are disabled.</spirit:description>
            <spirit:bitOffset>23</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATBTRIG</spirit:name>
            <spirit:displayName>ATBTRIG</spirit:displayName>
            <spirit:description>Indicates if the implementation can support ATB triggers:
      0
      
      The implementation does not support ATB triggers.
      
      
    
      1
      
      The implementation supports ATB triggers, and the TRCEVENTCTL1R.ATBTRIG field is implemented.
      
      
    </spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRACEIDSIZE</spirit:name>
            <spirit:displayName>TRACEIDSIZE</spirit:displayName>
            <spirit:description>Indicates the trace ID width. The permitted value is:
      111
      
      The implementation supports a 7-bit trace ID. This sets the width of the TRCTRACEIDR.TRACEID field.
      
      
    All other values are reserved.The CoreSight ATB requires a 7-bit trace ID width.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR5_15_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMEXTINSEL</spirit:name>
            <spirit:displayName>NUMEXTINSEL</spirit:displayName>
            <spirit:description>Indicates how many external input select resources are implemented. The permitted values are:
      000
      
      No external input select resources are available. If NUMEXTINSEL is zero, NUMEXTIN must also be zero.
      
      
    
      001
      
      The implementation has one external input select resource.
      
      
    
      010
      
      The implementation has two external input select resources.
      
      
    
      011
      
      The implementation has three external input select resources.
      
      
    
      100
      
      The implementation has four external input select resources.
      
      
    All other values are reserved.See TRCEXTINSELR for how to select an input select resource.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMEXTIN</spirit:name>
            <spirit:displayName>NUMEXTIN</spirit:displayName>
            <spirit:description>Indicates how many external inputs are implemented. The permitted values are:
      000000000
      
      No external inputs are available. If NUMEXTIN is zero, NUMEXTINSEL must also be zero.
      
      
    
      000000001
      
      The implementation has one external input.
      
      
    
      000000010
      
      The implementation has two external inputs.
      
      
    and so on up to 0b100000000, which indicates that the implementation has 256 external inputs.All other values &gt;0b100000000 are reserved.See TRCEXTINSELR for how to select an external input.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>9</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR8</spirit:name>
          <spirit:description>ID Register 8 </spirit:description>
          <spirit:addressOffset>0x180</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR8 -->
          <spirit:field>
            <spirit:name>MAXSPEC</spirit:name>
            <spirit:displayName>MAXSPEC</spirit:displayName>
            <spirit:description>Indicates the maximum speculation depth of the instruction trace stream. This is the maximum number of P0 elements in the trace stream that can be speculative at any time.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR9</spirit:name>
          <spirit:description>ID Register 9 </spirit:description>
          <spirit:addressOffset>0x184</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR9 -->
          <spirit:field>
            <spirit:name>NUMP0KEY</spirit:name>
            <spirit:displayName>NUMP0KEY</spirit:displayName>
            <spirit:description>Indicates the number of P0 right-hand keys that the trace unit can use. A value of 0 or 1 indicates one P0 key.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIMSPEC0</spirit:name>
          <spirit:description>Implementation Specific Register 0 </spirit:description>
          <spirit:addressOffset>0x1C0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCIMSPEC0 -->
          <spirit:field>
            <spirit:name>RES0_TRCIMSPEC0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EN</spirit:name>
            <spirit:displayName>EN</spirit:displayName>
            <spirit:description>If SUPPORT is not 0b0000, controls whether the IMPLEMENTATION DEFINED features are enabled. The permitted values are:
      0000
      
      The IMPLEMENTATION DEFINED features are not enabled. The trace unit must behave as if the IMPLEMENTATION DEFINED features are not supported.
      
      
    and any other value, which indicates that the trace unit behavior is IMPLEMENTATION DEFINED.If SUPPORT is 0b0000, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUPPORT</spirit:name>
            <spirit:displayName>SUPPORT</spirit:displayName>
            <spirit:description>Indicates whether the implementation supports IMPLEMENTATION DEFINED features. The permitted values are:
      0000
      
      No IMPLEMENTATION DEFINED features are supported. The EN field is RES0.
      
      
    and any other value, which indicates that IMPLEMENTATION DEFINED features are supported. Use of these values requires written permission from ARM.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITATBIDR</spirit:name>
          <spirit:description>Integration ATB Identification Register </spirit:description>
          <spirit:addressOffset>0xEE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCITATBIDR -->
          <spirit:field>
            <spirit:name>ID</spirit:name>
            <spirit:displayName>ID</spirit:displayName>
            <spirit:description>Drives the ATIDMn[6:0] output pins</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCITATBIDR_31_7</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>25</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITCTRL</spirit:name>
          <spirit:description>Integration Mode Control Register </spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCITCTRL -->
          <spirit:field>
            <spirit:name>RES0_TRCITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ITEN</spirit:name>
            <spirit:displayName>ITEN</spirit:displayName>
            <spirit:description>Integration mode enable bit:
      0
      
      The trace unit is not in integration mode.
      
      
    
      1
      
      The trace unit is in integration mode. This mode enables a debug agent to perform topology detection, and System-on-Chip (SoC) test software to perform integration testing.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITIATBINR</spirit:name>
          <spirit:description>Integration Instruction ATB In Register </spirit:description>
          <spirit:addressOffset>0xEF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCITIATBINR -->
          <spirit:field>
            <spirit:name>ATREADYM</spirit:name>
            <spirit:displayName>ATREADYM</spirit:displayName>
            <spirit:description>Returns the value of the ATREADYMn input pin</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AFVALIDM</spirit:name>
            <spirit:displayName>AFVALIDM</spirit:displayName>
            <spirit:description>Returns the value of the AFVALIDMn input pin</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCITIATBINR_31_2</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved. Read undefined.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITIATBOUTR</spirit:name>
          <spirit:description>Integration Instruction ATB Out Register </spirit:description>
          <spirit:addressOffset>0xEFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCITIATBOUTR -->
          <spirit:field>
            <spirit:name>ATVALID</spirit:name>
            <spirit:displayName>ATVALID</spirit:displayName>
            <spirit:description>Drives the ATVALIDMn output pin</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AFREADY</spirit:name>
            <spirit:displayName>AFREADY</spirit:displayName>
            <spirit:description>Drives the AFREADYMn output pin</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCITIATBOUTR_7_2</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved. Read undefined.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BYTES</spirit:name>
            <spirit:displayName>BYTES</spirit:displayName>
            <spirit:description>Drives the ATBYTESMn[1:0] output pins</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCITIATBOUTR_31_10</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved. Read undefined.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>22</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITIDATAR</spirit:name>
          <spirit:description>Integration Instruction ATB Data Register </spirit:description>
          <spirit:addressOffset>0xEEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCITIDATAR -->
          <spirit:field>
            <spirit:name>ATDATAM_0</spirit:name>
            <spirit:displayName>ATDATAM_0</spirit:displayName>
            <spirit:description>Drives the ATDATAM[0] output</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_7</spirit:name>
            <spirit:displayName>ATDATAM_7</spirit:displayName>
            <spirit:description>Drives the ATDATAM[7] output</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_15</spirit:name>
            <spirit:displayName>ATDATAM_15</spirit:displayName>
            <spirit:description>Drives the ATDATAM[15] output</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_23</spirit:name>
            <spirit:displayName>ATDATAM_23</spirit:displayName>
            <spirit:description>Drives the ATDATAM[23] output</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_31</spirit:name>
            <spirit:displayName>ATDATAM_31</spirit:displayName>
            <spirit:description>Drives the ATDATAM[31] output</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCITIDATAR_31_5</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>27</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCLAR</spirit:name>
          <spirit:description>Software Lock Access Register </spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCLAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Writing the key value 0xC5ACCE55 to this field clears the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register sets the lock, disabling write accesses to this component's registers through a memory mapped interface.Software can use the Software Lock to prevent accidental modification of the trace unit registers by software being debugged. For example, software that accidentally initializes an incorrect region of memory might disable the trace unit and make it impossible to trace the software.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCLSR</spirit:name>
          <spirit:description>Software Lock Status Register </spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCLSR -->
          <spirit:field>
            <spirit:name>RES0_TRCLSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. Possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. RAO.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCOSLAR</spirit:name>
          <spirit:description>OS Lock Access Register </spirit:description>
          <spirit:addressOffset>0x300</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCOSLAR -->
          <spirit:field>
            <spirit:name>RES0_TRCOSLAR_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LOCK</spirit:name>
            <spirit:displayName>LOCK</spirit:displayName>
            <spirit:description>OS Lock control bit:
      0
      
      Unlocks the OS Lock.
      
      
    
      1
      
      Locks the OS Lock. This setting disables the trace unit.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCOSLSR</spirit:name>
          <spirit:description>OS Lock Status Register </spirit:description>
          <spirit:addressOffset>0x304</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000A</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCOSLSR -->
          <spirit:field>
            <spirit:name>RES0_TRCOSLSR_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>Indicates whether the OS Lock is implemented.This bit is RES1, which indicates that the OS Lock is always implemented.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BIT32</spirit:name>
            <spirit:displayName>32BIT</spirit:displayName>
            <spirit:description>This bit is RES0, which indicates that software must perform a 32-bit write to update the TRCOSLAR.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LOCKED</spirit:name>
            <spirit:displayName>LOCKED</spirit:displayName>
            <spirit:description>OS Lock status bit:
      0
      
      The OS Lock is unlocked.
      
      
    
      1
      
      The OS Lock is locked.
      
      
    When the trace unit core power domain is powered down the value is UNKNOWN. The TRCPDSR indicates if the trace unit core power domain is powered down.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCOSLSR_0_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPDCR</spirit:name>
          <spirit:description>Power Down Control Register </spirit:description>
          <spirit:addressOffset>0x310</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPDCR -->
          <spirit:field>
            <spirit:name>RES0_TRCPDCR_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PU</spirit:name>
            <spirit:displayName>PU</spirit:displayName>
            <spirit:description>Powerup request bit:
      0
      
      The system can remove power from the trace unit. The TRCPDSR indicates if the trace unit is powered down.
      
      
    
      1
      
      The system must provide power to the trace unit.
      
      
    Typically, a trace unit drives a signal representing the value of this bit to a power controller to request that the trace unit core power domain is powered up. However, if the trace unit and the processor are in the same power domain then the implementation might combine the PU status with a signal from the processor.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCPDCR_2_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPDSR</spirit:name>
          <spirit:description>Power Down Status Register </spirit:description>
          <spirit:addressOffset>0x314</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCPDSR -->
          <spirit:field>
            <spirit:name>RES0_TRCPDSR_31_6</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>26</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LOCKED</spirit:name>
            <spirit:displayName>LOCKED</spirit:displayName>
            <spirit:description>OS Lock status bit:
      0
      
      The OS Lock is unlocked.
      
      
    
      1
      
      The OS Lock is locked.
      
      
    The value is UNKNOWN when the trace unit core power domain is powered down, that is, when POWER==0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCPDSR_4_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STICKYPD</spirit:name>
            <spirit:displayName>STICKYPD</spirit:displayName>
            <spirit:description>Sticky powerdown status bit. Indicates whether the trace register state is valid:
      0
      
      If POWER==1 then the state of TRCOSLSR and the trace registers are valid. If POWER==0 then it is UNKNOWN whether the state of TRCOSLSR and the trace registers are valid.
      
      
    
      1
      
      The state of TRCOSLSR and the trace registers might not be valid. The trace unit sets this bit to 1 if either the trace unit is reset, or the power to the trace unit core power domain is removed and the trace register state is not valid.
      
      
    After this register is read, if the Software Lock is unlocked and the trace unit core power domain is powered up, then the trace unit sets this bit to 0. The TRCLAR controls whether the Software Lock is locked.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>POWER</spirit:name>
            <spirit:displayName>POWER</spirit:displayName>
            <spirit:description>Power status bit:
      0
      
      The trace unit core power domain is not powered. The trace registers are not accessible and they all return an error response.
      
      
    
      1
      
      The trace unit core power domain is powered. The trace registers are accessible.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR0</spirit:name>
          <spirit:description>Peripheral Identification Register 0 </spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000005D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, bits[7:0].</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR1</spirit:name>
          <spirit:description>Peripheral Identification Register 1 </spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B9</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, bits[3:0] of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, bits[11:8].</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR2</spirit:name>
          <spirit:description>Peripheral Identification Register 2 </spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>The IMPLEMENTATION DEFINED revision number for the ETM implementation. See also TRCIDR1.REVISION.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR3</spirit:name>
          <spirit:description>Peripheral Identification Register 3 </spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>The IMPLEMENTATION DEFINED manufacturing revision number for the implementation. After silicon is available, if metal fixes are necessary, the manufacturer can alter the top metal layer so that this field can indicate any post-fab silicon changes.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR4</spirit:name>
          <spirit:description>Peripheral Identification Register 4 </spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RES0. This indicates that the ETM memory map occupies 4KB.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR5</spirit:name>
          <spirit:description>Peripheral Identification Register 5</spirit:description>
          <spirit:addressOffset>0xFD4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR5 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR5_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCPIDR5_7_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>RES0, reserved for future use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR6</spirit:name>
          <spirit:description>Peripheral Identification Register 6</spirit:description>
          <spirit:addressOffset>0xFD8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR6 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR6_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCPIDR6_7_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>RES0, reserved for future use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR7</spirit:name>
          <spirit:description>Peripheral Identification Register 7</spirit:description>
          <spirit:addressOffset>0xFDC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR7 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR7_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCPIDR7_7_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>RES0, reserved for future use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPRGCTLR</spirit:name>
          <spirit:description>Programming Control Register</spirit:description>
          <spirit:addressOffset>0x004</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPRGCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCPRGCTLR_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EN</spirit:name>
            <spirit:displayName>EN</spirit:displayName>
            <spirit:description>Trace unit enable bit. Possible values are:
      0
      
      The trace unit is disabled. All trace resources are inactive and no trace is generated.
      
      
    
      1
      
      The trace unit is enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR10</spirit:name>
          <spirit:description>Resource Selection Control Registers 10</spirit:description>
          <spirit:addressOffset>0x228</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR10 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR10_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR11</spirit:name>
          <spirit:description>Resource Selection Control Registers 11</spirit:description>
          <spirit:addressOffset>0x22c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR11 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR11_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR12</spirit:name>
          <spirit:description>Resource Selection Control Registers 12</spirit:description>
          <spirit:addressOffset>0x230</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR12 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR12_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR13</spirit:name>
          <spirit:description>Resource Selection Control Registers 13</spirit:description>
          <spirit:addressOffset>0x234</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR13 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR13_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR14</spirit:name>
          <spirit:description>Resource Selection Control Registers 14</spirit:description>
          <spirit:addressOffset>0x238</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR14 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR14_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR15</spirit:name>
          <spirit:description>Resource Selection Control Registers 15</spirit:description>
          <spirit:addressOffset>0x23c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR15 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR15_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR2</spirit:name>
          <spirit:description>Resource Selection Control Registers 2</spirit:description>
          <spirit:addressOffset>0x208</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR2_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR3</spirit:name>
          <spirit:description>Resource Selection Control Registers 3</spirit:description>
          <spirit:addressOffset>0x20c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR3_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR4</spirit:name>
          <spirit:description>Resource Selection Control Registers 4</spirit:description>
          <spirit:addressOffset>0x210</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR4 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR4_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR5</spirit:name>
          <spirit:description>Resource Selection Control Registers 5</spirit:description>
          <spirit:addressOffset>0x214</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR5 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR5_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR6</spirit:name>
          <spirit:description>Resource Selection Control Registers 6</spirit:description>
          <spirit:addressOffset>0x218</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR6 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR6_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR7</spirit:name>
          <spirit:description>Resource Selection Control Registers 7</spirit:description>
          <spirit:addressOffset>0x21c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR7 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR7_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR8</spirit:name>
          <spirit:description>Resource Selection Control Registers 8</spirit:description>
          <spirit:addressOffset>0x220</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR8 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR8_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR9</spirit:name>
          <spirit:description>Resource Selection Control Registers 9</spirit:description>
          <spirit:addressOffset>0x224</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR9 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR9_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQEVR0</spirit:name>
          <spirit:description>Sequencer State Transition Control Registers 0</spirit:description>
          <spirit:addressOffset>0x100</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQEVR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQEVR0_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>B_n</spirit:name>
            <spirit:displayName>B&lt;n&gt;</spirit:displayName>
            <spirit:description>Backward field. Contains an event number. When the event occurs then the sequencer state moves from state n+1 to state n.For example, for TRCSEQEVR2, if B2==0x14 then when event 0x14 occurs, the sequencer moves from state 3 to state 2.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_n</spirit:name>
            <spirit:displayName>F&lt;n&gt;</spirit:displayName>
            <spirit:description>Forward field. Contains an event number. When the event occurs then the sequencer state moves from state n to state n+1.For example, for TRCSEQEVR1, if F1==0x12 then when event 0x12 occurs, the sequencer moves from state 1 to state 2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQEVR1</spirit:name>
          <spirit:description>Sequencer State Transition Control Registers 1</spirit:description>
          <spirit:addressOffset>0x104</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQEVR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQEVR1_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>B_n</spirit:name>
            <spirit:displayName>B&lt;n&gt;</spirit:displayName>
            <spirit:description>Backward field. Contains an event number. When the event occurs then the sequencer state moves from state n+1 to state n.For example, for TRCSEQEVR2, if B2==0x14 then when event 0x14 occurs, the sequencer moves from state 3 to state 2.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_n</spirit:name>
            <spirit:displayName>F&lt;n&gt;</spirit:displayName>
            <spirit:description>Forward field. Contains an event number. When the event occurs then the sequencer state moves from state n to state n+1.For example, for TRCSEQEVR1, if F1==0x12 then when event 0x12 occurs, the sequencer moves from state 1 to state 2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQEVR2</spirit:name>
          <spirit:description>Sequencer State Transition Control Registers 2</spirit:description>
          <spirit:addressOffset>0x108</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQEVR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQEVR2_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>B_n</spirit:name>
            <spirit:displayName>B&lt;n&gt;</spirit:displayName>
            <spirit:description>Backward field. Contains an event number. When the event occurs then the sequencer state moves from state n+1 to state n.For example, for TRCSEQEVR2, if B2==0x14 then when event 0x14 occurs, the sequencer moves from state 3 to state 2.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_n</spirit:name>
            <spirit:displayName>F&lt;n&gt;</spirit:displayName>
            <spirit:description>Forward field. Contains an event number. When the event occurs then the sequencer state moves from state n to state n+1.For example, for TRCSEQEVR1, if F1==0x12 then when event 0x12 occurs, the sequencer moves from state 1 to state 2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQRSTEVR</spirit:name>
          <spirit:description>Sequencer Reset Control Register </spirit:description>
          <spirit:addressOffset>0x118</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF70</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQRSTEVR -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQRSTEVR_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RST</spirit:name>
            <spirit:displayName>RST</spirit:displayName>
            <spirit:description>Contains an event number. When the event occurs then the sequencer state moves to state 0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQSTR</spirit:name>
          <spirit:description>Sequencer State Register </spirit:description>
          <spirit:addressOffset>0x11C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQSTR -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQSTR_31_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STATE</spirit:name>
            <spirit:displayName>STATE</spirit:displayName>
            <spirit:description>Sets or returns the state of the sequencer:
      00
      
      State 0.
      
      
    
      01
      
      State 1.
      
      
    
      10
      
      State 2.
      
      
    
      11
      
      State 3.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSSCCR0</spirit:name>
          <spirit:description>Single-Shot Comparator Control Register 0 </spirit:description>
          <spirit:addressOffset>0x280</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSSCCR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCSSCCR0_31_25</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RST</spirit:name>
            <spirit:displayName>RST</spirit:displayName>
            <spirit:description>Controls whether the single-shot comparator resource is reset when it fires.
      0
      
      When the single-shot comparator resource fires, it is not reset.
      
      
    
      1
      
      When the single-shot comparator resource fires, it is reset. This enables the single-shot comparator resource to fire multiple times.
      
      
    </spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARC</spirit:name>
            <spirit:displayName>ARC</spirit:displayName>
            <spirit:description>Selects one or more address range comparators for single-shot control.Each bit represents an address range comparator pair, so bit[n-16] controls the selection of address range comparator pair n-16. If bit[n-16] is:
      0
      
      The address range comparator pair n-16 is not selected for single-shot control.
      
      
    
      1
      
      The address range comparator pair n-16 is selected for single-shot control.
      
      
    The width of this field is IMPLEMENTATION DEFINED. The field contains a number of implemented bits equal to TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SAC</spirit:name>
            <spirit:displayName>SAC</spirit:displayName>
            <spirit:description>Selects one or more single address comparators for single-shot control.Each bit represents a single address comparator, so bit[n] controls the selection of single address comparator n. If bit[n] is:
      0
      
      The single address comparator n, is not selected for single-shot control.
      
      
    
      1
      
      The single address comparator n, is selected for single-shot control.
      
      
    The width of this field is IMPLEMENTATION DEFINED. The field contains a number of implemented bits equal to 2 x TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSSCSR0</spirit:name>
          <spirit:description>Single-Shot Comparator Status Register 0 </spirit:description>
          <spirit:addressOffset>0x2A0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000001</spirit:value>
            <spirit:mask>0x7FFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSSCSR0 -->
          <spirit:field>
            <spirit:name>STATUS</spirit:name>
            <spirit:displayName>STATUS</spirit:displayName>
            <spirit:description>Single-shot status bit. Indicates if any of the comparators that TRCSSCCRn.SAC or TRCSSCCRn.ARC selects have matched:
      0
      
      No match has occurred.
      
      
    
      1
      
      One or more matches has occurred. If TRCSSCCRn.RST==0 then there is only one match and no more matches are possible, and software must reset this bit to 0 to re-enable the single-shot control.
      
      
    STATUS must be written to set an initial state when configuring the trace unit, if the single-shot comparator is to be used.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCSSCSR0_30_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DV</spirit:name>
            <spirit:displayName>DV</spirit:displayName>
            <spirit:description>Data value comparator support bit. Indicates if the trace unit supports data address with data value comparisons:
      0
      
      Single-shot data address with data value comparisons are not supported.
      
      
    
      1
      
      Single-shot data address with data value comparisons are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DA</spirit:name>
            <spirit:displayName>DA</spirit:displayName>
            <spirit:description>Data address comparator support bit. Indicates if the trace unit supports data address comparisons:
      0
      
      Single-shot data address comparisons are not supported.
      
      
    
      1
      
      Single-shot data address comparisons are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INST</spirit:name>
            <spirit:displayName>INST</spirit:displayName>
            <spirit:description>Instruction address comparator support bit. Indicates if the trace unit supports instruction address comparisons:
      0
      
      Single-shot instruction address comparisons are not supported.
      
      
    
      1
      
      Single-shot instruction address comparisons are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSTALLCTLR</spirit:name>
          <spirit:description>Stall Control Register </spirit:description>
          <spirit:addressOffset>0x02C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSTALLCTLR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCSTALLCTLR_31_9</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>23</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ISTALL</spirit:name>
            <spirit:displayName>Instruction stall bit</spirit:displayName>
            <spirit:description>Controls if the trace unit can stall the processor when the instruction trace buffer space is less than LEVEL</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCSTALLCTLR_7_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LEVEL</spirit:name>
            <spirit:displayName>Threshold level field</spirit:displayName>
            <spirit:description>The field can support 4 monotonic levels from 0b00 to 0b11</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCSTALLCTLR_1_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSTATR</spirit:name>
          <spirit:description>Status Register </spirit:description>
          <spirit:addressOffset>0x00C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCSTATR -->
          <spirit:field>
            <spirit:name>RES0_TRCSTATR_31_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMSTABLE</spirit:name>
            <spirit:displayName>PMSTABLE</spirit:displayName>
            <spirit:description>Programmer's model stable bit:
      0
      
      The programmer's model is not stable.
      
      
    
      1
      
      The programmer's model is stable. When polled, the trace unit trace registers return stable data.
      
      
    The programmer's model is stable when all of the following are true:TRCPRGCTLR.EN==0 or the OS Lock is locked.Reads from trace unit registers return stable data.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IDLE</spirit:name>
            <spirit:displayName>IDLE</spirit:displayName>
            <spirit:description>Idle status bit:
      0
      
      The trace unit is not idle.
      
      
    
      1
      
      The trace unit is idle.
      
      
    The trace unit is idle when all of the following are true:TRCPRGCTLR.EN==0 or the OS Lock is locked.The trace unit is drained of any trace.With the exception of the programming interfaces, all external interfaces on the trace unit are quiescent.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSYNCPR</spirit:name>
          <spirit:description>Synchronization Period Register </spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFE0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSYNCPR -->
          <spirit:field>
            <spirit:name>RES0_TRCSYNCPR_31_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>27</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PERIOD</spirit:name>
            <spirit:displayName>PERIOD</spirit:displayName>
            <spirit:description>Controls how many bytes of trace, the sum of instruction and data, that a trace unit can generate before a periodic trace synchronization request occurs. The number of bytes is always a power of two and the permitted values are:
      00000
      
      Periodic trace synchronization requests are disabled. This setting does not disable other types of trace synchronization request.
      
      
    
      01000
      
      Periodic trace synchronization request occurs after 2^8, or 256, bytes of trace.
      
      
    
      01001
      
      Periodic trace synchronization request occurs after 2^9, or 512, bytes of trace.
      
      
    
      01010
      
      Periodic trace synchronization request occurs after 2^10, or 1024, bytes of trace.
      
      
    and so on up to 0b10100, for which the request occurs after 2^20, or 1048576, bytes of trace.Values between 0b00001 and 0b001111 are reserved, as are values from 0b10101 onwards.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCTRACEIDR</spirit:name>
          <spirit:description>Trace ID Register </spirit:description>
          <spirit:addressOffset>0x040</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCTRACEIDR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCTRACEIDR_31_7</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>25</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRACEID</spirit:name>
            <spirit:displayName>TRACEID</spirit:displayName>
            <spirit:description>Trace ID value. When only instruction tracing is enabled this provides the trace ID.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCTSCTLR</spirit:name>
          <spirit:description>Global Timestamp Control Register </spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF70</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCTSCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCTSCTLR_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EVENT</spirit:name>
            <spirit:displayName>EVENT</spirit:displayName>
            <spirit:description>An event selector. When the selected event is triggered, the trace unit inserts a global timestamp into the trace streams.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVICTLR</spirit:name>
          <spirit:description>ViewInst Main Control Register </spirit:description>
          <spirit:addressOffset>0x080</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFF84F370</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVICTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCVICTLR_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level:
      0
      
      The trace unit generates instruction trace, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not generate instruction trace, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[20]Exception level 0.Bit[21]Exception level 1.Bit[22]Exception level 2.Bit[23]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. If instruction tracing is not implemented for a given exception level, the corresponding bit in this field is not implemented. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level:
      0
      
      The trace unit generates instruction trace, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not generate instruction trace, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[16]Exception level 0.Bit[17]Exception level 1.Bit[18]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[19]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. If instruction tracing is not implemented for a given exception level, the corresponding bit in this field is not implemented. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCVICTLR_15_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCERR</spirit:name>
            <spirit:displayName>TRCERR</spirit:displayName>
            <spirit:description>If TRCIDR3.TRCERR==1, this bit controls whether a trace unit must trace a system error exception:
      0
      
      The trace unit does not trace a system error exception unless it traces the exception or instruction immediately prior to the system error exception.
      
      
    
      1
      
      The trace unit always traces a system error exception.
      
      
    If TRCIDR3.TRCERR==0, this bit is RES0.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCRESET</spirit:name>
            <spirit:displayName>TRCRESET</spirit:displayName>
            <spirit:description>Controls whether a trace unit must trace a Reset exception:
      0
      
      The trace unit does not trace a Reset exception unless it traces the exception or instruction immediately prior to the Reset exception.
      
      
    
      1
      
      The trace unit always traces a Reset exception.
      
      
    </spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSSTATUS</spirit:name>
            <spirit:displayName>SSSTATUS</spirit:displayName>
            <spirit:description>IF TRCIDR4.NUMACPAIRS&gt;0 or TRCIDR.NUMPC&gt;0, this bit returns the status of the start-stop logic:
      0
      
      The start-stop logic is in the stopped state.
      
      
    
      1
      
      The start-stop logic is in the started state.
      
      
    The bit only returns stable data when TRCSTATR.PMSTABLE==1.Before software enables the trace unit, TRCPRGCTLR.EN==1, it must write to this bit to set the initial state of the start-stop logic. If the start-stop logic is not used then set this bit to 1. ARM recommends that the value of this bit is set before each trace run begins.If TRCIDR4.NUMACPAIRS==0 and TRCIDR4.NUMPC==0, this bit is RES0, indicating that the start-stop logic is not implemented.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCVICTLR_8_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EVENT</spirit:name>
            <spirit:displayName>EVENT</spirit:displayName>
            <spirit:description>An event selector. [TODO: Add the bit assignments for EVENT fields into the descriptions directly?]</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVIIECTLR</spirit:name>
          <spirit:description>ViewInst Include-Exclude Control Register </spirit:description>
          <spirit:addressOffset>0x084</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFF0FFF0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVIIECTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCVIIECTLR_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXCLUDE</spirit:name>
            <spirit:displayName>EXCLUDE</spirit:displayName>
            <spirit:description>
      0
      
      
      
      
    
      1
      
      
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCVIIECTLR_15_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INCLUDE</spirit:name>
            <spirit:displayName>INCLUDE</spirit:displayName>
            <spirit:description>Include range field. Selects which address range comparator pairs are in use with ViewInst include control. Each bit represents an address range comparator pair, so bit[m] controls the selection of address range comparator pair m. If bit[m] is:
      0
      
      The address range that address range comparator pair m defines is not selected for ViewInst include control.
      
      
    
      1
      
      The address range that address range comparator pair m defines is selected for ViewInst include control.
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.Selecting no include comparators indicates that all instructions are included by default. The exclude control then indicates which ranges are excluded.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVISSCTLR</spirit:name>
          <spirit:description>ViewInst Start-Stop Control Register </spirit:description>
          <spirit:addressOffset>0x088</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFF00FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVISSCTLR -->
          <spirit:field>
            <spirit:name>STOP</spirit:name>
            <spirit:displayName>STOP</spirit:displayName>
            <spirit:description>Selects which single address comparators are in use with ViewInst start-stop control, for the purpose of stopping trace. Each bit represents a single address comparator, so bit[m] controls the selection of single address comparator m-16. If bit[m] is:
      0
      
      The single address comparator m-16 is not selected as a stop resource.
      
      
    
      1
      
      The single address comparator m-16 is selected as a stop resource.
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of 2 x TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>START</spirit:name>
            <spirit:displayName>START</spirit:displayName>
            <spirit:description>Selects which single address comparators are in use with ViewInst start-stop control, for the purpose of starting trace. Each bit represents a single address comparator, so bit[n] controls the selection of single address comparator n. If bit[n] is:
      0
      
      The single address comparator n is not selected as a start resource.
      
      
    
      1
      
      The single address comparator n is selected as a start resource.
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of 2 x TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVMIDCVR0</spirit:name>
          <spirit:description>VMID Comparator Value Register 0 </spirit:description>
          <spirit:addressOffset>0x640</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVMIDCVR0 -->
          <spirit:field>
            <spirit:name>RESERVED_TRCVMIDCVR0_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE</spirit:name>
            <spirit:displayName>VALUE</spirit:displayName>
            <spirit:description>Contains a VMID value.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_ETM_CPU0</spirit:name>
        <spirit:displayName>APBADDR_ETM_0</spirit:displayName>
        <spirit:description>APBADDR_ETM_0</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">262144</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_ETM_CPU0>  -->
        <spirit:register>
          <spirit:name>TRCACATR0</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 0</spirit:description>
          <spirit:addressOffset>0x480</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR0_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR0_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR1</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 1</spirit:description>
          <spirit:addressOffset>0x488</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR1_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR1_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR2</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 2</spirit:description>
          <spirit:addressOffset>0x490</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR2_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR2_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR3</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 3</spirit:description>
          <spirit:addressOffset>0x498</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR3_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR3_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR4</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 4</spirit:description>
          <spirit:addressOffset>0x4a0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR4 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR4_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR4_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR5</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 5</spirit:description>
          <spirit:addressOffset>0x4a8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR5 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR5_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR5_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR6</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 6</spirit:description>
          <spirit:addressOffset>0x4b0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR6 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR6_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR6_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR7</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 7</spirit:description>
          <spirit:addressOffset>0x4B8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR7 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR7_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR7_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR0_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 0 (low word)</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR0_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR0_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 0 (high word)</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR0_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR1_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 1 (low word)</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR1_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR1_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 1 (high word)</spirit:description>
          <spirit:addressOffset>0x40c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR1_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR2_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 2 (low word)</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR2_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR2_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 2 (high word)</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR2_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR3_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 3 (low word)</spirit:description>
          <spirit:addressOffset>0x418</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR3_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR3_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 3 (high word)</spirit:description>
          <spirit:addressOffset>0x41c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR3_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR4_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 4 (low word)</spirit:description>
          <spirit:addressOffset>0x420</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR4_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR4_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 4 (high word)</spirit:description>
          <spirit:addressOffset>0x424</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR4_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR5_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 5 (low word)</spirit:description>
          <spirit:addressOffset>0x428</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR5_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR5_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 5 (high word)</spirit:description>
          <spirit:addressOffset>0x42c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR5_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR6_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 6 (low word)</spirit:description>
          <spirit:addressOffset>0x430</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR6_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR6_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 6 (high word)</spirit:description>
          <spirit:addressOffset>0x434</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR6_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR7_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 7 (low word)</spirit:description>
          <spirit:addressOffset>0x438</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR7_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR7_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 7 (high word)</spirit:description>
          <spirit:addressOffset>0x43c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR7_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCAUTHSTATUS</spirit:name>
          <spirit:description>Authentication Status Register </spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000088</spirit:value>
            <spirit:mask>0xFFFFFFBB</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCAUTHSTATUS -->
          <spirit:field>
            <spirit:name>RES0_TRCAUTHSTATUS_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNID</spirit:name>
            <spirit:displayName>SNID</spirit:displayName>
            <spirit:description>Indicates whether the system enables the trace unit to support Secure non-invasive debug:
      00
      
      The trace unit does not implement support for Secure non-invasive debug.
      
      
    
      01
      
      Reserved.
      
      
    
      10
      
      Secure non-invasive debug is disabled.
      
      
    
      11
      
      Secure non-invasive debug is enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SID</spirit:name>
            <spirit:displayName>SID</spirit:displayName>
            <spirit:description>Indicates whether the trace unit supports Secure invasive debug:
      00
      
      The trace unit does not support Secure invasive debug.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>Indicates whether the system enables the trace unit to support Non-secure non-invasive debug:
      00
      
      The trace unit does not implement support for Non-secure non-invasive debug.
      
      
    
      01
      
      Reserved.
      
      
    
      10
      
      Non-secure non-invasive debug is disabled.
      
      
    
      11
      
      Non-secure non-invasive debug is enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSID</spirit:name>
            <spirit:displayName>NSID</spirit:displayName>
            <spirit:description>Indicates whether the trace unit supports Non-secure invasive debug:
      00
      
      The trace unit does not support Non-secure invasive debug.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCAUXCTLR</spirit:name>
          <spirit:description>Auxiliary Control Register </spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCAUXCTLR -->
          <spirit:field>
            <spirit:name>AFREADY</spirit:name>
            <spirit:displayName>Always respond to AFREADY immediately</spirit:displayName>
            <spirit:description>Always respond to AFREADY immediately. Does not have any interaction with FIFO draining even in WFI state.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IDLEACK</spirit:name>
            <spirit:displayName>Force idle-drain acknowledge</spirit:displayName>
            <spirit:description>Force idle-drain acknowledge high CPU does not wait for trace to drain before entering WFX state. When this bit is set to 1 trace unit behavior deviates from architecturally-specified behavior.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OVFLW</spirit:name>
            <spirit:displayName>Overflow if synchronization is not completed</spirit:displayName>
            <spirit:description>Force an overflow if synchronization is not completed when second synchronization becomes due. When this bit is set to 1 the trace unit behavior deviates from architecturally-specified behavior.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SYNCDELAY</spirit:name>
            <spirit:displayName>Delay periodic synchronization</spirit:displayName>
            <spirit:description>Delay periodic synchronization if FIFO is more than half-full.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TSNODELAY</spirit:name>
            <spirit:displayName>Do not delay timestamp insertion</spirit:displayName>
            <spirit:description>Do not delay timestamp insertion based on FIFO depth.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AUTHNOFLUSH</spirit:name>
            <spirit:displayName>De-assertion of authentication inputs</spirit:displayName>
            <spirit:description>Do not flush trace on de-assertion of authentication inputs. When this bit is set to 1 the trace unit behavior deviates from architecturally-specified behavior.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCAUXCTLR_6_6</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COREIFEN</spirit:name>
            <spirit:displayName>Core interface enabled</spirit:displayName>
            <spirit:description>Keep core interface enabled regardless of trace enable register state</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCAUXCTLR_31_8</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCBBCTLR</spirit:name>
          <spirit:description>Branch Broadcast Control Register </spirit:description>
          <spirit:addressOffset>0x03C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCBBCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCBBCTLR_31_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>23</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MODE</spirit:name>
            <spirit:displayName>MODE</spirit:displayName>
            <spirit:description>Mode bit:
      0
      
      Exclude mode. Branch broadcasting is not enabled in the address range that RANGE defines. If RANGE==0 then branch broadcasting is enabled for the entire memory map.
      
      
    
      1
      
      Include mode. Branch broadcasting is enabled in the address range that RANGE defines. If RANGE==0 then the branch broadcasting behavior is UNPREDICTABLE.
      
      
    </spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RANGE</spirit:name>
            <spirit:displayName>RANGE</spirit:displayName>
            <spirit:description>Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each bit represents an address range comparator pair, so bit[n] controls the selection of address range comparator pair n. If bit[n] is:
      0
      
      The address range that address range comparator pair n defines is not selected.
      
      
    
      1
      
      The address range that address range comparator pair n defines is selected.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCCCTLR</spirit:name>
          <spirit:description>Cycle Count Control Register </spirit:description>
          <spirit:addressOffset>0x038</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFF000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCCCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCCCCTLR_31_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>THRESHOLD</spirit:name>
            <spirit:displayName>THRESHOLD</spirit:displayName>
            <spirit:description>Sets the threshold value for instruction trace cycle counting.The minimum threshold value that can be programmed into THRESHOLD is given in TRCIDR3.CCITMIN.Writing a value of zero might cause UNPREDICTABLE behaviour.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDCCTLR0</spirit:name>
          <spirit:description>Context ID Comparator Control Register 0 </spirit:description>
          <spirit:addressOffset>0x680</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDCCTLR0 -->
          <spirit:field>
            <spirit:name>COMP_n</spirit:name>
            <spirit:displayName>COMP&lt;n&gt;</spirit:displayName>
            <spirit:description>Controls the mask value that the trace unit applies to TRCCIDCVRn. Each bit in this field corresponds to a byte in TRCCIDCVRn. When a bit is:
      0
      
      The trace unit includes the relevant byte in TRCCIDCVRn when it performs the Context ID comparison.
      
      
    
      1
      
      The trace unit ignores the relevant byte in TRCCIDCVRn when it performs the Context ID comparison.
      
      
    Supported only if TRCIDR4.NUMCIDC &gt; n, otherwise the field is RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDCVR0</spirit:name>
          <spirit:description>Context ID Comparator Value Register 0 </spirit:description>
          <spirit:addressOffset>0x600</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCCIDCVR0 -->
          <spirit:field>
            <spirit:name>VALUE</spirit:name>
            <spirit:displayName>VALUE</spirit:displayName>
            <spirit:description>Context ID value. The implemented width of this field is IMPLEMENTATION DEFINED and is set by TRCIDR2.CIDSIZE. Unimplemented bits are RAZ/WI.After a processor reset, the ETM architecture assumes that the Context ID is zero until the processor updates the Context ID.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR0</spirit:name>
          <spirit:description>Component Identification Register 0 </spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR1</spirit:name>
          <spirit:description>Component Identification Register 1 </spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, to indicate that the ETM is a debug component, with CoreSight architecture compliant management registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR2</spirit:name>
          <spirit:description>Component Identification Register 2 </spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR3</spirit:name>
          <spirit:description>Component Identification Register 3 </spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCLAIMCLR</spirit:name>
          <spirit:description>Claim Tag Clear Register </spirit:description>
          <spirit:addressOffset>0xFA4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCLAIMCLR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCCLAIMCLR_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLR</spirit:name>
            <spirit:displayName>CLR</spirit:displayName>
            <spirit:description>Clears bits in the claim tag and determines the current value of the claim tag.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCLAIMSET</spirit:name>
          <spirit:description>Claim Tag Set Register </spirit:description>
          <spirit:addressOffset>0xFA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000F</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCLAIMSET -->
          <spirit:field>
            <spirit:name>RESERVED_TRCCLAIMSET_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SET</spirit:name>
            <spirit:displayName>SET</spirit:displayName>
            <spirit:description>Sets bits in the claim tag and determines the number of claim tag bits implemented.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTCTLR0</spirit:name>
          <spirit:description>Counter Control Register 0 </spirit:description>
          <spirit:addressOffset>0x150</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTCTLR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTCTLR0_31_18</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTCHAIN_n</spirit:name>
            <spirit:displayName>CNTCHAIN&lt;n&gt;</spirit:displayName>
            <spirit:description>For TRCCNTCTLR3 and TRCCNTCTLR1, controls whether counter &lt;n&gt; decrements when a reload event occurs for counter &lt;n-1&gt;:
      0
      
      
      
      
    
      1
      
      
      
      
    For TRCCNTCTLR2 and TRCCNTCTLR0, this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDSELF_n</spirit:name>
            <spirit:displayName>RLDSELF&lt;n&gt;</spirit:displayName>
            <spirit:description>Controls whether a reload event occurs for counter &lt;n&gt;, when counter &lt;n&gt; reaches zero:
      0
      
      The trace unit does not generate a reload event.
      
      
    
      1
      
      The trace unit generates a reload event for counter &lt;n&gt;, provided that the event resource that CNTEVENT&lt;n&gt; specifies is active.
      
      
    </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDEVENT_n</spirit:name>
            <spirit:displayName>RLDEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes a reload event for counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTEVENT_n</spirit:name>
            <spirit:displayName>CNTEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes counter &lt;n&gt; to decrement.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTCTLR1</spirit:name>
          <spirit:description>Counter Control Register 1 </spirit:description>
          <spirit:addressOffset>0x154</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFD7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTCTLR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTCTLR1_31_18</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTCHAIN_n</spirit:name>
            <spirit:displayName>CNTCHAIN&lt;n&gt;</spirit:displayName>
            <spirit:description>For TRCCNTCTLR3 and TRCCNTCTLR1, controls whether counter &lt;n&gt; decrements when a reload event occurs for counter &lt;n-1&gt;:
      0
      
      
      
      
    
      1
      
      
      
      
    For TRCCNTCTLR2 and TRCCNTCTLR0, this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDSELF_n</spirit:name>
            <spirit:displayName>RLDSELF&lt;n&gt;</spirit:displayName>
            <spirit:description>Controls whether a reload event occurs for counter &lt;n&gt;, when counter &lt;n&gt; reaches zero:
      0
      
      The trace unit does not generate a reload event.
      
      
    
      1
      
      The trace unit generates a reload event for counter &lt;n&gt;, provided that the event resource that CNTEVENT&lt;n&gt; specifies is active.
      
      
    </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDEVENT_n</spirit:name>
            <spirit:displayName>RLDEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes a reload event for counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTEVENT_n</spirit:name>
            <spirit:displayName>CNTEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes counter &lt;n&gt; to decrement.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTRLDVR0</spirit:name>
          <spirit:description>Counter Reload Value Registers 0</spirit:description>
          <spirit:addressOffset>0x140</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTRLDVR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTRLDVR0_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the reload value for counter &lt;n&gt;. When a reload event occurs for counter &lt;n&gt; then the trace unit copies the VALUE&lt;n&gt; field into counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTRLDVR1</spirit:name>
          <spirit:description>Counter Reload Value Registers 1</spirit:description>
          <spirit:addressOffset>0x144</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTRLDVR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTRLDVR1_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the reload value for counter &lt;n&gt;. When a reload event occurs for counter &lt;n&gt; then the trace unit copies the VALUE&lt;n&gt; field into counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTVR0</spirit:name>
          <spirit:description>Counter Value Registers 0</spirit:description>
          <spirit:addressOffset>0x160</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTVR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTVR0_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the count value of counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTVR1</spirit:name>
          <spirit:description>Counter Value Registers 1</spirit:description>
          <spirit:addressOffset>0x164</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTVR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTVR1_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the count value of counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCONFIGR</spirit:name>
          <spirit:description>Trace Configuration Register </spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000001</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCONFIGR -->
          <spirit:field>
            <spirit:name>RES0_TRCCONFIGR_31_18</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DV</spirit:name>
            <spirit:displayName>DV</spirit:displayName>
            <spirit:description>Data value tracing bit:
      0
      
      Data value tracing is disabled.
      
      
    
      1
      
      Data value tracing is enabled when INSTP0 is not 0b00.
      
      
    TRCIDR0.TRCDATA indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DA</spirit:name>
            <spirit:displayName>DA</spirit:displayName>
            <spirit:description>Data address tracing bit:
      0
      
      Data address tracing is disabled.
      
      
    
      1
      
      Data address tracing is enabled when INSTP0 is not 0b00.
      
      
    TRCIDR0.TRCDATA indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCCONFIGR_15_15</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>QE</spirit:name>
            <spirit:displayName>QE</spirit:displayName>
            <spirit:description>Q element enable field:
      00
      
      Q elements are disabled.
      
      
    
      01
      
      Q elements with instruction counts are enabled. Q elements without instruction counts are disabled.
      
      
    
      11
      
      Q elements with and without instruction counts are enabled.
      
      
    The value 0b10 is reserved.TRCIDR0.QSUPP indicates which values of this field are implemented.TRCCONFIGR.QE must be set to 0b00 if any of the following are true:TRCCONFIGR.INSTP0 is not 0b00.TRCCONFIGR.COND is not 0b000.TRCCONFIGR.BB is not 0.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RS</spirit:name>
            <spirit:displayName>RS</spirit:displayName>
            <spirit:description>Return stack enable bit.
      0
      
      Return stack is disabled.
      
      
    
      1
      
      Return stack is enabled.
      
      
    TRCIDR0.RETSTACK indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TS</spirit:name>
            <spirit:displayName>TS</spirit:displayName>
            <spirit:description>Global timestamp tracing bit:
      0
      
      Global timestamp tracing is disabled.
      
      
    
      1
      
      Global timestamp tracing is enabled. TRCTSCTLR controls the insertion of timestamps in the trace.
      
      
    TRCIDR0.TSSIZE indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COND</spirit:name>
            <spirit:displayName>COND</spirit:displayName>
            <spirit:description>Conditional instruction tracing bit. The permitted values are:
      000
      
      Conditional instruction tracing is disabled.
      
      
    
      001
      
      Conditional load instructions are traced.
      
      
    
      010
      
      Conditional store instructions are traced.
      
      
    
      011
      
      Conditional load and store instructions are traced.
      
      
    
      111
      
      All conditional instructions are traced.
      
      
    All other values are reserved.TRCIDR0.TRCCOND indicates whether this field is supported. If it is not supported then this field is RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VMID</spirit:name>
            <spirit:displayName>VMID</spirit:displayName>
            <spirit:description>VMID tracing bit:
      0
      
      VMID tracing is disabled.
      
      
    
      1
      
      VMID tracing is enabled.
      
      
    TRCIDR2.VMIDSIZE indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CID</spirit:name>
            <spirit:displayName>CID</spirit:displayName>
            <spirit:description>Context ID tracing bit:
      0
      
      Context ID tracing is disabled.
      
      
    
      1
      
      Context ID tracing is enabled.
      
      
    TRCIDR2.CIDSIZE indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCCONFIGR_5_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCI</spirit:name>
            <spirit:displayName>CCI</spirit:displayName>
            <spirit:description>Cycle counting instruction trace bit:
      0
      
      Cycle counting in the instruction trace is disabled.
      
      
    
      1
      
      Cycle counting in the instruction trace is enabled. TRCCCCTLR controls the threshold value for cycle counting.
      
      
    TRCIDR0.TRCCCI indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BB</spirit:name>
            <spirit:displayName>BB</spirit:displayName>
            <spirit:description>Branch broadcast mode bit:
      0
      
      Branch broadcast mode is disabled.
      
      
    
      1
      
      Branch broadcast mode is enabled. TRCBBCTLR controls which regions of memory are enabled to use branch broadcasting.
      
      
    TRCIDR0.TRCBB indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INSTP0</spirit:name>
            <spirit:displayName>INSTP0</spirit:displayName>
            <spirit:description>Instruction P0 bit. This field controls whether load and store instructions are traced as P0 instructions:
      00
      
      Do not trace load and store instructions as P0 instructions.
      
      
    
      01
      
      Trace load instructions as P0 instructions.
      
      
    
      10
      
      Trace store instructions as P0 instructions.
      
      
    
      11
      
      Trace load and store instructions as P0 instructions.
      
      
    TRCIDR0.INSTP0 indicates whether this field is supported. If it is not supported then this field is RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES1_TRCCONFIGR_0_0</spirit:name>
            <spirit:displayName>1</spirit:displayName>
            <spirit:description>Reserved, RES1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVAFF0</spirit:name>
          <spirit:description>Device Affinity Register 0 </spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000000</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVAFF0 -->
          <spirit:field>
            <spirit:name>MPIDR_EL1_31:0</spirit:name>
            <spirit:displayName>MPIDR_EL1[31:0]</spirit:displayName>
            <spirit:description>Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVAFF1</spirit:name>
          <spirit:description>Device Affinity Register 1 </spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVAFF1 -->
          <spirit:field>
            <spirit:name>MPIDR_EL1_63:32</spirit:name>
            <spirit:displayName>MPIDR_EL1[63:32]</spirit:displayName>
            <spirit:description>Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVARCH</spirit:name>
          <spirit:description>Device Architecture Register </spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47704A13</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For trace, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is RAO.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For trace, the revision defined by ETMv4 is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For trace, bits [15:12] are the architecture version, 0x4; bits [11:0] are the architecture part number, 0xA13.This corresponds to trace architecture version ETMv4.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVID</spirit:name>
          <spirit:description>Device ID Register </spirit:description>
          <spirit:addressOffset>0xFC8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCDEVID -->
          <spirit:field>
            <spirit:name>DEVID</spirit:name>
            <spirit:displayName>DEVID</spirit:displayName>
            <spirit:description>Indicates the capabilities of the trace unit. The implemented width of this field and its bit assignments are IMPLEMENTATION DEFINED. Unimplemented bits are RAZ/WI.If a component is configurable then ARM recommends that this field can also indicate which configuration options are implemented that differ from the standard configuration.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVTYPE</spirit:name>
          <spirit:description>Device Type Register </spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000013</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_TRCDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Returns 0x1, to indicate that the ETM generates processor trace.All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAIN</spirit:name>
            <spirit:displayName>MAIN</spirit:displayName>
            <spirit:description>Returns 0x3, to indicate that the ETM is a trace source.All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCEVENTCTL0R</spirit:name>
          <spirit:description>Event Control 0 Register </spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0x70707070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCEVENTCTL0R -->
          <spirit:field>
            <spirit:name>TYPE3</spirit:name>
            <spirit:displayName>TYPE3</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 3</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_30_28</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL3</spirit:name>
            <spirit:displayName>SEL3</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE3</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE2</spirit:name>
            <spirit:displayName>TYPE2</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 2</spirit:description>
            <spirit:bitOffset>23</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_22_20</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL2</spirit:name>
            <spirit:displayName>SEL2</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE2</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE1</spirit:name>
            <spirit:displayName>TYPE1</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 1</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_14_12</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL1</spirit:name>
            <spirit:displayName>SEL1</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE1</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE0</spirit:name>
            <spirit:displayName>TYPE0</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 0</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_6_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL0</spirit:name>
            <spirit:displayName>SEL0</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCEVENTCTL1R</spirit:name>
          <spirit:description>Event Control 1 Register </spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFE7F0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCEVENTCTL1R -->
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL1R_31_13</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>19</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LPOVERRIDE</spirit:name>
            <spirit:displayName>LPOVERRIDE</spirit:displayName>
            <spirit:description>Low power state behavior override</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATB</spirit:name>
            <spirit:displayName>ATB</spirit:displayName>
            <spirit:description>ATB trigger enable</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL1R_10_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EN</spirit:name>
            <spirit:displayName>EN</spirit:displayName>
            <spirit:description>One bit per event to enable generation of an event element in the instruction trace stream when the selected event occurs</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCEXTINSELR</spirit:name>
          <spirit:description>External Input Select Register </spirit:description>
          <spirit:addressOffset>0x120</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0x80808080</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCEXTINSELR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_31_29</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL3</spirit:name>
            <spirit:displayName>SEL3</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 3.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_23_21</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL2</spirit:name>
            <spirit:displayName>SEL2</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 2</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_15_13</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL1</spirit:name>
            <spirit:displayName>SEL1</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 1</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_7_5</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL0</spirit:name>
            <spirit:displayName>SEL0</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR0</spirit:name>
          <spirit:description>ID Register 0 </spirit:description>
          <spirit:addressOffset>0x1E0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x28000EA1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_31_30</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COMMOPT</spirit:name>
            <spirit:displayName>COMMOPT</spirit:displayName>
            <spirit:description>Conditional instruction tracing support bit. Indicates if the trace unit supports conditional instruction tracing:
      0
      
      Conditional instruction tracing is not supported.
      
      
    
      1
      
      Conditional instruction tracing is supported, so TRCCONFIGR.COND is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TSSIZE</spirit:name>
            <spirit:displayName>TSSIZE</spirit:displayName>
            <spirit:description>Global timestamp size field. The permitted values are:
      00000
      
      Global timestamping is not implemented.
      
      
    
      00110
      
      Implementation supports a maximum global timestamp of 48bits.
      
      
    
      01000
      
      Implementation supports a maximum global timestamp of 64bits.
      
      
    All other values are reserved.When global timestamping is implemented then TRCCONFIGR.TS and TRCTSCTLR are supported.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_23_17</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>QSUPP</spirit:name>
            <spirit:displayName>QSUPP</spirit:displayName>
            <spirit:description>Q element support field. The permitted values are:
      00
      
      Q element support is not implemented. TRCCONFIGR.QE is RES0.
      
      
    
      01
      
      Q element support is implemented, and only supports Q elements with instruction counts. TRCCONFIGR.QE can only take the values 0b00 or 0b01.
      
      
    
      10
      
      Q element support is implemented, and only supports Q elements without instruction counts. TRCCONFIGR.QE can only take the values 0b00 or 0b11.
      
      
    
      11
      
      Q element support is implemented, and supports both Q elements with instruction counts and Q elements without instruction counts. TRCCONFIGR.QE is fully implemented.
      
      
    </spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>QFILT</spirit:name>
            <spirit:displayName>QFILT</spirit:displayName>
            <spirit:description>Q element filtering support field. The permitted values are:
      0
      
      Q element filtering is not implemented.
      
      
    
      1
      
      Q element filtering is implemented. TRCQCTLR is implemented.
      
      
    When QSUPP==0b00, this field is RES0.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONDTYPE</spirit:name>
            <spirit:displayName>CONDTYPE</spirit:displayName>
            <spirit:description>Conditional tracing field. The permitted values are:
      00
      
      The trace unit indicates only if a conditional instruction is a pass or fail.
      
      
    
      01
      
      The trace unit provides the Current Program Status Register (CPSR) status, for a conditional instruction.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMEVENT</spirit:name>
            <spirit:displayName>NUMEVENT</spirit:displayName>
            <spirit:description>Number of events field. Indicates how many events the trace unit supports:
      00
      
      The trace unit supports 1 event.
      
      
    
      01
      
      The trace unit supports 2 events.
      
      
    
      10
      
      The trace unit supports 3 events.
      
      
    
      11
      
      The trace unit supports 4 events.
      
      
    This field controls how many fields are supported in TRCEVENTCTL0R, and indicates the size of TRCEVENTCTL1R.INSTEN.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RETSTACK</spirit:name>
            <spirit:displayName>RETSTACK</spirit:displayName>
            <spirit:description>Return stack bit. Indicates if the implementation supports a return stack:
      0
      
      Return stack is not implemented.
      
      
    
      1
      
      Return stack is implemented, so TRCCONFIGR.RS is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_8_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCCCI</spirit:name>
            <spirit:displayName>TRCCCI</spirit:displayName>
            <spirit:description>Cycle counting instruction bit. Indicates if the trace unit supports cycle counting for instructions:
      0
      
      Cycle counting in the instruction trace is not implemented.
      
      
    
      1
      
      Cycle counting in the instruction trace is implemented, so TRCCONFIGR.CCI and TRCCCCTLR are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCCOND</spirit:name>
            <spirit:displayName>TRCCOND</spirit:displayName>
            <spirit:description>Conditional instruction tracing support bit. Indicates if the trace unit supports conditional instruction tracing:
      0
      
      Conditional instruction tracing is not supported.
      
      
    
      1
      
      Conditional instruction tracing is supported, so TRCCONFIGR.COND is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCBB</spirit:name>
            <spirit:displayName>TRCBB</spirit:displayName>
            <spirit:description>Branch broadcast tracing support bit. Indicates if the trace unit supports branch broadcast tracing:
      0
      
      Branch broadcast tracing is not supported.
      
      
    
      1
      
      Branch broadcast tracing is supported, so TRCCONFIGR.BB and TRCBBCTLR are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCDATA</spirit:name>
            <spirit:displayName>TRCDATA</spirit:displayName>
            <spirit:description>Conditional tracing field. The permitted values are:
      00
      
      Data tracing is not supported.
      
      
    
      11
      
      Tracing of data addresses and data values is supported, so TRCCONFIGR.DA, TRCCONFIGR.DV, TRCSTALLCTLR.DATADISCARD, TRCSTALLCTLR.INSTPRIORITY, TRCSTALLCTLR.DSTALL, and TRCEVENTCTL1R.DATAEN are supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INSTP0</spirit:name>
            <spirit:displayName>INSTP0</spirit:displayName>
            <spirit:description>P0 tracing support field. The permitted values are:
      00
      
      Tracing of load and store instructions as P0 elements is not supported.
      
      
    
      11
      
      Tracing of load and store instructions as P0 elements is supported, so TRCCONFIGR.INSTP0 is supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_0_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR1</spirit:name>
          <spirit:description>ID Register 1 </spirit:description>
          <spirit:addressOffset>0x1E4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x4100F404</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR1 -->
          <spirit:field>
            <spirit:name>DESIGNER</spirit:name>
            <spirit:displayName>DESIGNER</spirit:displayName>
            <spirit:description>Indicates which company designed the trace unit. The permitted values are:
      01000001
      
      ARM Limited.
      
      
    
      01000100
      
      Digital Equipment Corporation.
      
      
    
      01001101
      
      Motorola, Freescale Semiconductor Inc.
      
      
    
      01010001
      
      QUALCOMM Inc.
      
      
    
      01010110
      
      Marvell Semiconductor Inc.
      
      
    
      01101001
      
      Intel Corporation.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR1_23_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES1_TRCIDR1_15_12</spirit:name>
            <spirit:displayName>1</spirit:displayName>
            <spirit:description>Reserved, RES1.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCARCHMAJ</spirit:name>
            <spirit:displayName>TRCARCHMAJ</spirit:displayName>
            <spirit:description>Indicates the major version of the ETM architecture. The permitted value is:
      100
      
      ETMv4.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCARCHMIN</spirit:name>
            <spirit:displayName>TRCARCHMIN</spirit:displayName>
            <spirit:description>Indicates the minor version of the ETM architecture. The permitted value is:
      0
      
      ETMv4 minor version 0.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Returns an IMPLEMENTATION DEFINED value that identifies the revision of the trace registers and the OS Save and Restore registers.ARM recommends:That the initial implementation sets REVISION==0x0 and the field then increments for any subsequent implementations. However, it is acceptable to omit some values or use another scheme to identify the revision number.That TRCPIDR2.REVISION==TRCIDR1.REVISION. However, in situations where it is difficult to align these fields, such as with a metal layer fix, then it is acceptable to change the REVISION fields independently.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR10</spirit:name>
          <spirit:description>ID Register 10 </spirit:description>
          <spirit:addressOffset>0x188</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR10 -->
          <spirit:field>
            <spirit:name>NUMP1KEY</spirit:name>
            <spirit:displayName>NUMP1KEY</spirit:displayName>
            <spirit:description>Indicates the number of P1 right-hand keys that the trace unit can use. The number includes normal and special keys.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR11</spirit:name>
          <spirit:description>ID Register 11 </spirit:description>
          <spirit:addressOffset>0x18C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR11 -->
          <spirit:field>
            <spirit:name>NUMP1SPC</spirit:name>
            <spirit:displayName>NUMP1SPC</spirit:displayName>
            <spirit:description>Indicates the number of special P1 right-hand keys that the trace unit can use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR12</spirit:name>
          <spirit:description>ID Register 12 </spirit:description>
          <spirit:addressOffset>0x190</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR12 -->
          <spirit:field>
            <spirit:name>NUMCONDKEY</spirit:name>
            <spirit:displayName>NUMCONDKEY</spirit:displayName>
            <spirit:description>Indicates the number of conditional instruction right-hand keys that the trace unit can use. The number includes normal and special keys.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR13</spirit:name>
          <spirit:description>ID Register 13 </spirit:description>
          <spirit:addressOffset>0x194</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR13 -->
          <spirit:field>
            <spirit:name>NUMCONDSPC</spirit:name>
            <spirit:displayName>NUMCONDSPC</spirit:displayName>
            <spirit:description>Indicates the number of special conditional instruction right-hand keys that the trace unit can use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR2</spirit:name>
          <spirit:description>ID Register 2 </spirit:description>
          <spirit:addressOffset>0x1E8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000488</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCIDR2_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCSIZE</spirit:name>
            <spirit:displayName>CCSIZE</spirit:displayName>
            <spirit:description>Indicates the size of the cycle counter in bits minus 12.
      0000
      
      The cycle counter is 12 bits in length.
      
      
    
      0001
      
      The cycle counter is 13 bits in length.
      
      
    and so on up to 0b1000, indicating the cycle counter is 20 bits in length.All other values are reserved.If cycle counting is not implemented, as indicated by TRCIDR0.TRCCCI, this field is 0b0000.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DVSIZE</spirit:name>
            <spirit:displayName>DVSIZE</spirit:displayName>
            <spirit:description>Indicates the data value size in bytes. The permitted values are:
      00000
      
      Data value tracing is not supported. Therefore, an implementation must also set TRCIDR0.TRCDATA==0b00.
      
      
    
      00100
      
      Maximum of 32-bit data value size.
      
      
    
      01000
      
      Maximum of 64-bit data value size.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DASIZE</spirit:name>
            <spirit:displayName>DASIZE</spirit:displayName>
            <spirit:description>Indicates the data address size in bytes. The permitted values are:
      00000
      
      Data address tracing is not supported. Therefore, an implementation must also set TRCIDR0.TRCDATA==0b00.
      
      
    
      00100
      
      Maximum of 32-bit data address size.
      
      
    
      01000
      
      Maximum of 64-bit data address size.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VMIDSIZE</spirit:name>
            <spirit:displayName>VMIDSIZE</spirit:displayName>
            <spirit:description>Indicates the VMID size. The permitted values are:
      00000
      
      VMID tracing is not supported.
      
      
    
      00001
      
      Maximum of 8-bit VMID size, so TRCCONFIGR.VMID is supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CIDSIZE</spirit:name>
            <spirit:displayName>CIDSIZE</spirit:displayName>
            <spirit:description>Indicates the Context ID size. The permitted values are:
      00000
      
      Context ID tracing is not supported.
      
      
    
      00100
      
      Maximum of 32-bit Context ID size, so TRCCONFIGR.CID is supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IASIZE</spirit:name>
            <spirit:displayName>IASIZE</spirit:displayName>
            <spirit:description>Indicates the instruction address size. The permitted values are:
      00100
      
      Maximum of 32-bit address size.
      
      
    
      01000
      
      Maximum of 64-bit address size.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR3</spirit:name>
          <spirit:description>ID Register 3 </spirit:description>
          <spirit:addressOffset>0x1EC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0D7B0004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR3 -->
          <spirit:field>
            <spirit:name>NOOVERFLOW</spirit:name>
            <spirit:displayName>NOOVERFLOW</spirit:displayName>
            <spirit:description>Indicates if TRCSTALLCTLR.NOOVERFLOW is supported:
      0
      
      TRCSTALLCTLR.NOOVERFLOW is not supported, or STALLCTL==0.
      
      
    
      1
      
      TRCSTALLCTLR.NOOVERFLOW is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMPROC</spirit:name>
            <spirit:displayName>NUMPROC</spirit:displayName>
            <spirit:description>Indicates the number of processors available for tracing. The possible values are:
      000
      
      The trace unit can trace one processor.
      
      
    
      001
      
      The trace unit can trace two processors.
      
      
    
      010
      
      The trace unit can trace three processors.
      
      
    and so on up to 0b111, which indicates the trace unit can trace eight processors.This field sets the maximum value of TRCPROCSELR.PROCSEL.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SYSSTALL</spirit:name>
            <spirit:displayName>SYSSTALL</spirit:displayName>
            <spirit:description>Indicates if the implementation can support stall control:
      0
      
      The system does not support stall control of the processor.
      
      
    
      1
      
      The system can support stall control of the processor.
      
      
    The system supports stalling of the processor only when SYSSTALL==1 and STALLCTL==1.</spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STALLCTL</spirit:name>
            <spirit:displayName>STALLCTL</spirit:displayName>
            <spirit:description>Indicates if TRCSTALLCTLR is supported:
      0
      
      TRCSTALLCTLR is not supported.
      
      
    
      1
      
      TRCSTALLCTLR is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SYNCPR</spirit:name>
            <spirit:displayName>SYNCPR</spirit:displayName>
            <spirit:description>Indicates if an implementation has a fixed synchronization period:
      0
      
      TRCSYNCPR is read-write so software can change the synchronization period.
      
      
    
      1
      
      TRCSYNCPR is read-only so the synchronization period is fixed.
      
      
    </spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCERR</spirit:name>
            <spirit:displayName>TRCERR</spirit:displayName>
            <spirit:description>Indicates if TRCVICTLR.TRCERR is supported:
      0
      
      TRCVICTLR.TRCERR is not supported
      
      
    
      1
      
      TRCVICTLR.TRCERR is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit indicates whether instruction tracing is supported for the corresponding exception level:
      0
      
      In Non-secure state, exception level n is not supported so the corresponding bits in TRCACATRn.EXLEVEL_NS and TRCVICTLR.EXLEVEL_NS are not supported.
      
      
    
      1
      
      In Non-secure state, exception level n is supported so the corresponding bits in TRCACATRn.EXLEVEL_NS and TRCVICTLR.EXLEVEL_NS are supported.
      
      
    The exception levels are:Bit[20]Exception level 0.Bit[21]Exception level 1.Bit[22]Exception level 2.Bit[23]SBZ. EXLEVEL_NS[3] is never implemented.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit indicates whether instruction tracing is supported for the corresponding exception level:
      0
      
      In Secure state, exception level n is not supported so the corresponding bits in TRCACATRn.EXLEVEL_S and TRCVICTLR.EXLEVEL_S are not supported.
      
      
    
      1
      
      In Secure state, exception level n is supported so the corresponding bits in TRCACATRn.EXLEVEL_S and TRCVICTLR.EXLEVEL_S are supported.
      
      
    The exception levels are:Bit[16]Exception level 0.Bit[17]Exception level 1.Bit[18]SBZ. EXLEVEL_S[2] is never implemented.Bit[19]Exception level 3.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR3_15_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCITMIN</spirit:name>
            <spirit:displayName>CCITMIN</spirit:displayName>
            <spirit:description>Indicates the minimum value that can be programmed in TRCCCCTLR.THRESHOLD.When cycle counting in the instruction trace is supported, that is TRCIDR0.TRCCCI==1, then the minimum value of this field is 0x001, otherwise it is 0x000.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR4</spirit:name>
          <spirit:description>ID Register 4 </spirit:description>
          <spirit:addressOffset>0x1F0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x11170004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR4 -->
          <spirit:field>
            <spirit:name>NUMVMIDC</spirit:name>
            <spirit:displayName>NUMVMIDC</spirit:displayName>
            <spirit:description>Indicates the number of VMID comparators that are available for tracing. The permitted values are:
      0000
      
      No VMID comparators are available.
      
      
    
      0001
      
      The implementation has one VMID comparator.
      
      
    
      0010
      
      The implementation has two VMID comparators.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight VMID comparators.All other values are reserved.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMCIDC</spirit:name>
            <spirit:displayName>NUMCIDC</spirit:displayName>
            <spirit:description>Indicates the number of Context ID comparators that are available for tracing. The permitted values are:
      0000
      
      No Context ID comparators are available.
      
      
    
      0001
      
      The implementation has one Context ID comparator.
      
      
    
      0010
      
      The implementation has two Context ID comparators.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight Context ID comparators.All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMSSCC</spirit:name>
            <spirit:displayName>NUMSSCC</spirit:displayName>
            <spirit:description>Indicates the number of single-shot comparator controls that are available for tracing. The permitted values are:
      0000
      
      No single-shot comparator controls are available.
      
      
    
      0001
      
      The implementation has one single-shot comparator control.
      
      
    
      0010
      
      The implementation has two single-shot comparator controls.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight single-shot comparator controls.All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMRSPAIR</spirit:name>
            <spirit:displayName>NUMRSPAIR</spirit:displayName>
            <spirit:description>Indicates the number of resource selection pairs that are available for tracing. The permitted values are:
      0000
      
      The implementation has one resource selection pair.
      
      
    
      0001
      
      The implementation has two resource selection pairs.
      
      
    
      0010
      
      The implementation has three resource selection pairs.
      
      
    and so on up to 0b1111, which indicates that the implementation has 16 resource selection pairs.Implementations always have at least one resource selection pair so that they can support the FALSE and TRUE resource selectors, 0 and 1.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMPC</spirit:name>
            <spirit:displayName>NUMPC</spirit:displayName>
            <spirit:description>Indicates the number of processor comparator inputs that are available for tracing. The permitted values are:
      0000
      
      No processor comparator inputs are available.
      
      
    
      0001
      
      The implementation has one processor comparator input.
      
      
    
      0010
      
      The implementation has two processor comparator inputs.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight processor comparator inputs.All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR4_11_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUPPDAC</spirit:name>
            <spirit:displayName>SUPPDAC</spirit:displayName>
            <spirit:description>Indicates if the implementation can support data address comparisons:
      0
      
      The implementation does not support data address comparisons.
      
      
    
      1
      
      The implementation can support data address comparisons
      
      
    </spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMDVC</spirit:name>
            <spirit:displayName>NUMDVC</spirit:displayName>
            <spirit:description>Indicates the number of data value comparators that are available for tracing. The permitted values are:
      0000
      
      No data value comparators are available.
      
      
    
      0001
      
      The implementation has one data value comparator.
      
      
    
      0010
      
      The implementation has two data value comparators.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight data value comparators.All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMACPAIRS</spirit:name>
            <spirit:displayName>NUMACPAIRS</spirit:displayName>
            <spirit:description>Indicates the number of address comparator pairs that are available for tracing. The permitted values are:
      0000
      
      No address comparator pairs are available.
      
      
    
      0001
      
      The implementation has one address comparator pair.
      
      
    
      0010
      
      The implementation has two address comparator pairs.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight address comparator pairs.All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR5</spirit:name>
          <spirit:description>ID Register 5 </spirit:description>
          <spirit:addressOffset>0x1F4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x28C7081E</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR5 -->
          <spirit:field>
            <spirit:name>REDFUNCNTR</spirit:name>
            <spirit:displayName>REDFUNCNTR</spirit:displayName>
            <spirit:description>Indicates if the reduced function counter is implemented:
      0
      
      The reduced function counter is not supported.
      
      
    
      1
      
      Counter 0 is implemented as a reduced function counter.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMCNTR</spirit:name>
            <spirit:displayName>NUMCNTR</spirit:displayName>
            <spirit:description>Indicates the number of counters that are available for tracing. The permitted values are:
      000
      
      No counters are available.
      
      
    
      001
      
      The implementation has one counter.
      
      
    
      010
      
      The implementation has two counters.
      
      
    
      011
      
      The implementation has three counters.
      
      
    
      100
      
      The implementation has four counters.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMSEQSTATE</spirit:name>
            <spirit:displayName>NUMSEQSTATE</spirit:displayName>
            <spirit:description>Indicates the number of sequencer states that are implemented. The permitted values are:
      000
      
      No sequencer states are implemented.
      
      
    
      100
      
      The implementation has four sequencer states.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR5_24_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LPOVERRIDE</spirit:name>
            <spirit:displayName>LPOVERRIDE</spirit:displayName>
            <spirit:description>Indicates if the implementation can support low-power state override:
      0
      
      The implementation does not support low-power state override.
      
      
    
      1
      
      The implementation supports low-power state override, and the TRCEVENTCTL1R.LPOVERRIDE field is implemented.
      
      
    The trace unit must support low-power state override if it can enter a low-power mode where the resources and event trace generation are disabled.</spirit:description>
            <spirit:bitOffset>23</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATBTRIG</spirit:name>
            <spirit:displayName>ATBTRIG</spirit:displayName>
            <spirit:description>Indicates if the implementation can support ATB triggers:
      0
      
      The implementation does not support ATB triggers.
      
      
    
      1
      
      The implementation supports ATB triggers, and the TRCEVENTCTL1R.ATBTRIG field is implemented.
      
      
    </spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRACEIDSIZE</spirit:name>
            <spirit:displayName>TRACEIDSIZE</spirit:displayName>
            <spirit:description>Indicates the trace ID width. The permitted value is:
      111
      
      The implementation supports a 7-bit trace ID. This sets the width of the TRCTRACEIDR.TRACEID field.
      
      
    All other values are reserved.The CoreSight ATB requires a 7-bit trace ID width.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR5_15_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMEXTINSEL</spirit:name>
            <spirit:displayName>NUMEXTINSEL</spirit:displayName>
            <spirit:description>Indicates how many external input select resources are implemented. The permitted values are:
      000
      
      No external input select resources are available. If NUMEXTINSEL is zero, NUMEXTIN must also be zero.
      
      
    
      001
      
      The implementation has one external input select resource.
      
      
    
      010
      
      The implementation has two external input select resources.
      
      
    
      011
      
      The implementation has three external input select resources.
      
      
    
      100
      
      The implementation has four external input select resources.
      
      
    All other values are reserved.See TRCEXTINSELR for how to select an input select resource.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMEXTIN</spirit:name>
            <spirit:displayName>NUMEXTIN</spirit:displayName>
            <spirit:description>Indicates how many external inputs are implemented. The permitted values are:
      000000000
      
      No external inputs are available. If NUMEXTIN is zero, NUMEXTINSEL must also be zero.
      
      
    
      000000001
      
      The implementation has one external input.
      
      
    
      000000010
      
      The implementation has two external inputs.
      
      
    and so on up to 0b100000000, which indicates that the implementation has 256 external inputs.All other values &gt;0b100000000 are reserved.See TRCEXTINSELR for how to select an external input.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>9</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR8</spirit:name>
          <spirit:description>ID Register 8 </spirit:description>
          <spirit:addressOffset>0x180</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR8 -->
          <spirit:field>
            <spirit:name>MAXSPEC</spirit:name>
            <spirit:displayName>MAXSPEC</spirit:displayName>
            <spirit:description>Indicates the maximum speculation depth of the instruction trace stream. This is the maximum number of P0 elements in the trace stream that can be speculative at any time.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR9</spirit:name>
          <spirit:description>ID Register 9 </spirit:description>
          <spirit:addressOffset>0x184</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR9 -->
          <spirit:field>
            <spirit:name>NUMP0KEY</spirit:name>
            <spirit:displayName>NUMP0KEY</spirit:displayName>
            <spirit:description>Indicates the number of P0 right-hand keys that the trace unit can use. A value of 0 or 1 indicates one P0 key.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIMSPEC0</spirit:name>
          <spirit:description>Implementation Specific Register 0 </spirit:description>
          <spirit:addressOffset>0x1C0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCIMSPEC0 -->
          <spirit:field>
            <spirit:name>RES0_TRCIMSPEC0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EN</spirit:name>
            <spirit:displayName>EN</spirit:displayName>
            <spirit:description>If SUPPORT is not 0b0000, controls whether the IMPLEMENTATION DEFINED features are enabled. The permitted values are:
      0000
      
      The IMPLEMENTATION DEFINED features are not enabled. The trace unit must behave as if the IMPLEMENTATION DEFINED features are not supported.
      
      
    and any other value, which indicates that the trace unit behavior is IMPLEMENTATION DEFINED.If SUPPORT is 0b0000, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUPPORT</spirit:name>
            <spirit:displayName>SUPPORT</spirit:displayName>
            <spirit:description>Indicates whether the implementation supports IMPLEMENTATION DEFINED features. The permitted values are:
      0000
      
      No IMPLEMENTATION DEFINED features are supported. The EN field is RES0.
      
      
    and any other value, which indicates that IMPLEMENTATION DEFINED features are supported. Use of these values requires written permission from ARM.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITATBIDR</spirit:name>
          <spirit:description>Integration ATB Identification Register </spirit:description>
          <spirit:addressOffset>0xEE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCITATBIDR -->
          <spirit:field>
            <spirit:name>ID</spirit:name>
            <spirit:displayName>ID</spirit:displayName>
            <spirit:description>Drives the ATIDMn[6:0] output pins</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCITATBIDR_31_7</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>25</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITCTRL</spirit:name>
          <spirit:description>Integration Mode Control Register </spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCITCTRL -->
          <spirit:field>
            <spirit:name>RES0_TRCITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ITEN</spirit:name>
            <spirit:displayName>ITEN</spirit:displayName>
            <spirit:description>Integration mode enable bit:
      0
      
      The trace unit is not in integration mode.
      
      
    
      1
      
      The trace unit is in integration mode. This mode enables a debug agent to perform topology detection, and System-on-Chip (SoC) test software to perform integration testing.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITIATBINR</spirit:name>
          <spirit:description>Integration Instruction ATB In Register </spirit:description>
          <spirit:addressOffset>0xEF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCITIATBINR -->
          <spirit:field>
            <spirit:name>ATREADYM</spirit:name>
            <spirit:displayName>ATREADYM</spirit:displayName>
            <spirit:description>Returns the value of the ATREADYMn input pin</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AFVALIDM</spirit:name>
            <spirit:displayName>AFVALIDM</spirit:displayName>
            <spirit:description>Returns the value of the AFVALIDMn input pin</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCITIATBINR_31_2</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved. Read undefined.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITIATBOUTR</spirit:name>
          <spirit:description>Integration Instruction ATB Out Register </spirit:description>
          <spirit:addressOffset>0xEFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCITIATBOUTR -->
          <spirit:field>
            <spirit:name>ATVALID</spirit:name>
            <spirit:displayName>ATVALID</spirit:displayName>
            <spirit:description>Drives the ATVALIDMn output pin</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AFREADY</spirit:name>
            <spirit:displayName>AFREADY</spirit:displayName>
            <spirit:description>Drives the AFREADYMn output pin</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCITIATBOUTR_7_2</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved. Read undefined.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BYTES</spirit:name>
            <spirit:displayName>BYTES</spirit:displayName>
            <spirit:description>Drives the ATBYTESMn[1:0] output pins</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCITIATBOUTR_31_10</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved. Read undefined.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>22</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITIDATAR</spirit:name>
          <spirit:description>Integration Instruction ATB Data Register </spirit:description>
          <spirit:addressOffset>0xEEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCITIDATAR -->
          <spirit:field>
            <spirit:name>ATDATAM_0</spirit:name>
            <spirit:displayName>ATDATAM_0</spirit:displayName>
            <spirit:description>Drives the ATDATAM[0] output</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_7</spirit:name>
            <spirit:displayName>ATDATAM_7</spirit:displayName>
            <spirit:description>Drives the ATDATAM[7] output</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_15</spirit:name>
            <spirit:displayName>ATDATAM_15</spirit:displayName>
            <spirit:description>Drives the ATDATAM[15] output</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_23</spirit:name>
            <spirit:displayName>ATDATAM_23</spirit:displayName>
            <spirit:description>Drives the ATDATAM[23] output</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_31</spirit:name>
            <spirit:displayName>ATDATAM_31</spirit:displayName>
            <spirit:description>Drives the ATDATAM[31] output</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCITIDATAR_31_5</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>27</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCLAR</spirit:name>
          <spirit:description>Software Lock Access Register </spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCLAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Writing the key value 0xC5ACCE55 to this field clears the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register sets the lock, disabling write accesses to this component's registers through a memory mapped interface.Software can use the Software Lock to prevent accidental modification of the trace unit registers by software being debugged. For example, software that accidentally initializes an incorrect region of memory might disable the trace unit and make it impossible to trace the software.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCLSR</spirit:name>
          <spirit:description>Software Lock Status Register </spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCLSR -->
          <spirit:field>
            <spirit:name>RES0_TRCLSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. Possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. RAO.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCOSLAR</spirit:name>
          <spirit:description>OS Lock Access Register </spirit:description>
          <spirit:addressOffset>0x300</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCOSLAR -->
          <spirit:field>
            <spirit:name>RES0_TRCOSLAR_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LOCK</spirit:name>
            <spirit:displayName>LOCK</spirit:displayName>
            <spirit:description>OS Lock control bit:
      0
      
      Unlocks the OS Lock.
      
      
    
      1
      
      Locks the OS Lock. This setting disables the trace unit.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCOSLSR</spirit:name>
          <spirit:description>OS Lock Status Register </spirit:description>
          <spirit:addressOffset>0x304</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000A</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCOSLSR -->
          <spirit:field>
            <spirit:name>RES0_TRCOSLSR_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>Indicates whether the OS Lock is implemented.This bit is RES1, which indicates that the OS Lock is always implemented.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BIT32</spirit:name>
            <spirit:displayName>32BIT</spirit:displayName>
            <spirit:description>This bit is RES0, which indicates that software must perform a 32-bit write to update the TRCOSLAR.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LOCKED</spirit:name>
            <spirit:displayName>LOCKED</spirit:displayName>
            <spirit:description>OS Lock status bit:
      0
      
      The OS Lock is unlocked.
      
      
    
      1
      
      The OS Lock is locked.
      
      
    When the trace unit core power domain is powered down the value is UNKNOWN. The TRCPDSR indicates if the trace unit core power domain is powered down.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCOSLSR_0_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPDCR</spirit:name>
          <spirit:description>Power Down Control Register </spirit:description>
          <spirit:addressOffset>0x310</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPDCR -->
          <spirit:field>
            <spirit:name>RES0_TRCPDCR_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PU</spirit:name>
            <spirit:displayName>PU</spirit:displayName>
            <spirit:description>Powerup request bit:
      0
      
      The system can remove power from the trace unit. The TRCPDSR indicates if the trace unit is powered down.
      
      
    
      1
      
      The system must provide power to the trace unit.
      
      
    Typically, a trace unit drives a signal representing the value of this bit to a power controller to request that the trace unit core power domain is powered up. However, if the trace unit and the processor are in the same power domain then the implementation might combine the PU status with a signal from the processor.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCPDCR_2_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPDSR</spirit:name>
          <spirit:description>Power Down Status Register </spirit:description>
          <spirit:addressOffset>0x314</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCPDSR -->
          <spirit:field>
            <spirit:name>RES0_TRCPDSR_31_6</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>26</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LOCKED</spirit:name>
            <spirit:displayName>LOCKED</spirit:displayName>
            <spirit:description>OS Lock status bit:
      0
      
      The OS Lock is unlocked.
      
      
    
      1
      
      The OS Lock is locked.
      
      
    The value is UNKNOWN when the trace unit core power domain is powered down, that is, when POWER==0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCPDSR_4_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STICKYPD</spirit:name>
            <spirit:displayName>STICKYPD</spirit:displayName>
            <spirit:description>Sticky powerdown status bit. Indicates whether the trace register state is valid:
      0
      
      If POWER==1 then the state of TRCOSLSR and the trace registers are valid. If POWER==0 then it is UNKNOWN whether the state of TRCOSLSR and the trace registers are valid.
      
      
    
      1
      
      The state of TRCOSLSR and the trace registers might not be valid. The trace unit sets this bit to 1 if either the trace unit is reset, or the power to the trace unit core power domain is removed and the trace register state is not valid.
      
      
    After this register is read, if the Software Lock is unlocked and the trace unit core power domain is powered up, then the trace unit sets this bit to 0. The TRCLAR controls whether the Software Lock is locked.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>POWER</spirit:name>
            <spirit:displayName>POWER</spirit:displayName>
            <spirit:description>Power status bit:
      0
      
      The trace unit core power domain is not powered. The trace registers are not accessible and they all return an error response.
      
      
    
      1
      
      The trace unit core power domain is powered. The trace registers are accessible.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR0</spirit:name>
          <spirit:description>Peripheral Identification Register 0 </spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000005D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, bits[7:0].</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR1</spirit:name>
          <spirit:description>Peripheral Identification Register 1 </spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B9</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, bits[3:0] of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, bits[11:8].</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR2</spirit:name>
          <spirit:description>Peripheral Identification Register 2 </spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>The IMPLEMENTATION DEFINED revision number for the ETM implementation. See also TRCIDR1.REVISION.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR3</spirit:name>
          <spirit:description>Peripheral Identification Register 3 </spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>The IMPLEMENTATION DEFINED manufacturing revision number for the implementation. After silicon is available, if metal fixes are necessary, the manufacturer can alter the top metal layer so that this field can indicate any post-fab silicon changes.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR4</spirit:name>
          <spirit:description>Peripheral Identification Register 4 </spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RES0. This indicates that the ETM memory map occupies 4KB.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR5</spirit:name>
          <spirit:description>Peripheral Identification Register 5</spirit:description>
          <spirit:addressOffset>0xFD4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR5 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR5_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCPIDR5_7_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>RES0, reserved for future use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR6</spirit:name>
          <spirit:description>Peripheral Identification Register 6</spirit:description>
          <spirit:addressOffset>0xFD8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR6 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR6_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCPIDR6_7_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>RES0, reserved for future use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR7</spirit:name>
          <spirit:description>Peripheral Identification Register 7</spirit:description>
          <spirit:addressOffset>0xFDC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR7 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR7_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCPIDR7_7_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>RES0, reserved for future use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPRGCTLR</spirit:name>
          <spirit:description>Programming Control Register</spirit:description>
          <spirit:addressOffset>0x004</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPRGCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCPRGCTLR_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EN</spirit:name>
            <spirit:displayName>EN</spirit:displayName>
            <spirit:description>Trace unit enable bit. Possible values are:
      0
      
      The trace unit is disabled. All trace resources are inactive and no trace is generated.
      
      
    
      1
      
      The trace unit is enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR10</spirit:name>
          <spirit:description>Resource Selection Control Registers 10</spirit:description>
          <spirit:addressOffset>0x228</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR10 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR10_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR11</spirit:name>
          <spirit:description>Resource Selection Control Registers 11</spirit:description>
          <spirit:addressOffset>0x22c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR11 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR11_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR12</spirit:name>
          <spirit:description>Resource Selection Control Registers 12</spirit:description>
          <spirit:addressOffset>0x230</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR12 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR12_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR13</spirit:name>
          <spirit:description>Resource Selection Control Registers 13</spirit:description>
          <spirit:addressOffset>0x234</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR13 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR13_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR14</spirit:name>
          <spirit:description>Resource Selection Control Registers 14</spirit:description>
          <spirit:addressOffset>0x238</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR14 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR14_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR15</spirit:name>
          <spirit:description>Resource Selection Control Registers 15</spirit:description>
          <spirit:addressOffset>0x23c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR15 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR15_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR2</spirit:name>
          <spirit:description>Resource Selection Control Registers 2</spirit:description>
          <spirit:addressOffset>0x208</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR2_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR3</spirit:name>
          <spirit:description>Resource Selection Control Registers 3</spirit:description>
          <spirit:addressOffset>0x20c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR3_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR4</spirit:name>
          <spirit:description>Resource Selection Control Registers 4</spirit:description>
          <spirit:addressOffset>0x210</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR4 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR4_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR5</spirit:name>
          <spirit:description>Resource Selection Control Registers 5</spirit:description>
          <spirit:addressOffset>0x214</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR5 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR5_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR6</spirit:name>
          <spirit:description>Resource Selection Control Registers 6</spirit:description>
          <spirit:addressOffset>0x218</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR6 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR6_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR7</spirit:name>
          <spirit:description>Resource Selection Control Registers 7</spirit:description>
          <spirit:addressOffset>0x21c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR7 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR7_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR8</spirit:name>
          <spirit:description>Resource Selection Control Registers 8</spirit:description>
          <spirit:addressOffset>0x220</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR8 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR8_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR9</spirit:name>
          <spirit:description>Resource Selection Control Registers 9</spirit:description>
          <spirit:addressOffset>0x224</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR9 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR9_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQEVR0</spirit:name>
          <spirit:description>Sequencer State Transition Control Registers 0</spirit:description>
          <spirit:addressOffset>0x100</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQEVR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQEVR0_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>B_n</spirit:name>
            <spirit:displayName>B&lt;n&gt;</spirit:displayName>
            <spirit:description>Backward field. Contains an event number. When the event occurs then the sequencer state moves from state n+1 to state n.For example, for TRCSEQEVR2, if B2==0x14 then when event 0x14 occurs, the sequencer moves from state 3 to state 2.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_n</spirit:name>
            <spirit:displayName>F&lt;n&gt;</spirit:displayName>
            <spirit:description>Forward field. Contains an event number. When the event occurs then the sequencer state moves from state n to state n+1.For example, for TRCSEQEVR1, if F1==0x12 then when event 0x12 occurs, the sequencer moves from state 1 to state 2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQEVR1</spirit:name>
          <spirit:description>Sequencer State Transition Control Registers 1</spirit:description>
          <spirit:addressOffset>0x104</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQEVR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQEVR1_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>B_n</spirit:name>
            <spirit:displayName>B&lt;n&gt;</spirit:displayName>
            <spirit:description>Backward field. Contains an event number. When the event occurs then the sequencer state moves from state n+1 to state n.For example, for TRCSEQEVR2, if B2==0x14 then when event 0x14 occurs, the sequencer moves from state 3 to state 2.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_n</spirit:name>
            <spirit:displayName>F&lt;n&gt;</spirit:displayName>
            <spirit:description>Forward field. Contains an event number. When the event occurs then the sequencer state moves from state n to state n+1.For example, for TRCSEQEVR1, if F1==0x12 then when event 0x12 occurs, the sequencer moves from state 1 to state 2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQEVR2</spirit:name>
          <spirit:description>Sequencer State Transition Control Registers 2</spirit:description>
          <spirit:addressOffset>0x108</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQEVR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQEVR2_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>B_n</spirit:name>
            <spirit:displayName>B&lt;n&gt;</spirit:displayName>
            <spirit:description>Backward field. Contains an event number. When the event occurs then the sequencer state moves from state n+1 to state n.For example, for TRCSEQEVR2, if B2==0x14 then when event 0x14 occurs, the sequencer moves from state 3 to state 2.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_n</spirit:name>
            <spirit:displayName>F&lt;n&gt;</spirit:displayName>
            <spirit:description>Forward field. Contains an event number. When the event occurs then the sequencer state moves from state n to state n+1.For example, for TRCSEQEVR1, if F1==0x12 then when event 0x12 occurs, the sequencer moves from state 1 to state 2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQRSTEVR</spirit:name>
          <spirit:description>Sequencer Reset Control Register </spirit:description>
          <spirit:addressOffset>0x118</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF70</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQRSTEVR -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQRSTEVR_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RST</spirit:name>
            <spirit:displayName>RST</spirit:displayName>
            <spirit:description>Contains an event number. When the event occurs then the sequencer state moves to state 0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQSTR</spirit:name>
          <spirit:description>Sequencer State Register </spirit:description>
          <spirit:addressOffset>0x11C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQSTR -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQSTR_31_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STATE</spirit:name>
            <spirit:displayName>STATE</spirit:displayName>
            <spirit:description>Sets or returns the state of the sequencer:
      00
      
      State 0.
      
      
    
      01
      
      State 1.
      
      
    
      10
      
      State 2.
      
      
    
      11
      
      State 3.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSSCCR0</spirit:name>
          <spirit:description>Single-Shot Comparator Control Register 0 </spirit:description>
          <spirit:addressOffset>0x280</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSSCCR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCSSCCR0_31_25</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RST</spirit:name>
            <spirit:displayName>RST</spirit:displayName>
            <spirit:description>Controls whether the single-shot comparator resource is reset when it fires.
      0
      
      When the single-shot comparator resource fires, it is not reset.
      
      
    
      1
      
      When the single-shot comparator resource fires, it is reset. This enables the single-shot comparator resource to fire multiple times.
      
      
    </spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARC</spirit:name>
            <spirit:displayName>ARC</spirit:displayName>
            <spirit:description>Selects one or more address range comparators for single-shot control.Each bit represents an address range comparator pair, so bit[n-16] controls the selection of address range comparator pair n-16. If bit[n-16] is:
      0
      
      The address range comparator pair n-16 is not selected for single-shot control.
      
      
    
      1
      
      The address range comparator pair n-16 is selected for single-shot control.
      
      
    The width of this field is IMPLEMENTATION DEFINED. The field contains a number of implemented bits equal to TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SAC</spirit:name>
            <spirit:displayName>SAC</spirit:displayName>
            <spirit:description>Selects one or more single address comparators for single-shot control.Each bit represents a single address comparator, so bit[n] controls the selection of single address comparator n. If bit[n] is:
      0
      
      The single address comparator n, is not selected for single-shot control.
      
      
    
      1
      
      The single address comparator n, is selected for single-shot control.
      
      
    The width of this field is IMPLEMENTATION DEFINED. The field contains a number of implemented bits equal to 2 x TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSSCSR0</spirit:name>
          <spirit:description>Single-Shot Comparator Status Register 0 </spirit:description>
          <spirit:addressOffset>0x2A0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000001</spirit:value>
            <spirit:mask>0x7FFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSSCSR0 -->
          <spirit:field>
            <spirit:name>STATUS</spirit:name>
            <spirit:displayName>STATUS</spirit:displayName>
            <spirit:description>Single-shot status bit. Indicates if any of the comparators that TRCSSCCRn.SAC or TRCSSCCRn.ARC selects have matched:
      0
      
      No match has occurred.
      
      
    
      1
      
      One or more matches has occurred. If TRCSSCCRn.RST==0 then there is only one match and no more matches are possible, and software must reset this bit to 0 to re-enable the single-shot control.
      
      
    STATUS must be written to set an initial state when configuring the trace unit, if the single-shot comparator is to be used.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCSSCSR0_30_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DV</spirit:name>
            <spirit:displayName>DV</spirit:displayName>
            <spirit:description>Data value comparator support bit. Indicates if the trace unit supports data address with data value comparisons:
      0
      
      Single-shot data address with data value comparisons are not supported.
      
      
    
      1
      
      Single-shot data address with data value comparisons are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DA</spirit:name>
            <spirit:displayName>DA</spirit:displayName>
            <spirit:description>Data address comparator support bit. Indicates if the trace unit supports data address comparisons:
      0
      
      Single-shot data address comparisons are not supported.
      
      
    
      1
      
      Single-shot data address comparisons are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INST</spirit:name>
            <spirit:displayName>INST</spirit:displayName>
            <spirit:description>Instruction address comparator support bit. Indicates if the trace unit supports instruction address comparisons:
      0
      
      Single-shot instruction address comparisons are not supported.
      
      
    
      1
      
      Single-shot instruction address comparisons are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSTALLCTLR</spirit:name>
          <spirit:description>Stall Control Register </spirit:description>
          <spirit:addressOffset>0x02C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSTALLCTLR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCSTALLCTLR_31_9</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>23</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ISTALL</spirit:name>
            <spirit:displayName>Instruction stall bit</spirit:displayName>
            <spirit:description>Controls if the trace unit can stall the processor when the instruction trace buffer space is less than LEVEL</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCSTALLCTLR_7_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LEVEL</spirit:name>
            <spirit:displayName>Threshold level field</spirit:displayName>
            <spirit:description>The field can support 4 monotonic levels from 0b00 to 0b11</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCSTALLCTLR_1_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSTATR</spirit:name>
          <spirit:description>Status Register </spirit:description>
          <spirit:addressOffset>0x00C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCSTATR -->
          <spirit:field>
            <spirit:name>RES0_TRCSTATR_31_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMSTABLE</spirit:name>
            <spirit:displayName>PMSTABLE</spirit:displayName>
            <spirit:description>Programmer's model stable bit:
      0
      
      The programmer's model is not stable.
      
      
    
      1
      
      The programmer's model is stable. When polled, the trace unit trace registers return stable data.
      
      
    The programmer's model is stable when all of the following are true:TRCPRGCTLR.EN==0 or the OS Lock is locked.Reads from trace unit registers return stable data.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IDLE</spirit:name>
            <spirit:displayName>IDLE</spirit:displayName>
            <spirit:description>Idle status bit:
      0
      
      The trace unit is not idle.
      
      
    
      1
      
      The trace unit is idle.
      
      
    The trace unit is idle when all of the following are true:TRCPRGCTLR.EN==0 or the OS Lock is locked.The trace unit is drained of any trace.With the exception of the programming interfaces, all external interfaces on the trace unit are quiescent.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSYNCPR</spirit:name>
          <spirit:description>Synchronization Period Register </spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFE0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSYNCPR -->
          <spirit:field>
            <spirit:name>RES0_TRCSYNCPR_31_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>27</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PERIOD</spirit:name>
            <spirit:displayName>PERIOD</spirit:displayName>
            <spirit:description>Controls how many bytes of trace, the sum of instruction and data, that a trace unit can generate before a periodic trace synchronization request occurs. The number of bytes is always a power of two and the permitted values are:
      00000
      
      Periodic trace synchronization requests are disabled. This setting does not disable other types of trace synchronization request.
      
      
    
      01000
      
      Periodic trace synchronization request occurs after 2^8, or 256, bytes of trace.
      
      
    
      01001
      
      Periodic trace synchronization request occurs after 2^9, or 512, bytes of trace.
      
      
    
      01010
      
      Periodic trace synchronization request occurs after 2^10, or 1024, bytes of trace.
      
      
    and so on up to 0b10100, for which the request occurs after 2^20, or 1048576, bytes of trace.Values between 0b00001 and 0b001111 are reserved, as are values from 0b10101 onwards.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCTRACEIDR</spirit:name>
          <spirit:description>Trace ID Register </spirit:description>
          <spirit:addressOffset>0x040</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCTRACEIDR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCTRACEIDR_31_7</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>25</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRACEID</spirit:name>
            <spirit:displayName>TRACEID</spirit:displayName>
            <spirit:description>Trace ID value. When only instruction tracing is enabled this provides the trace ID.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCTSCTLR</spirit:name>
          <spirit:description>Global Timestamp Control Register </spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF70</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCTSCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCTSCTLR_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EVENT</spirit:name>
            <spirit:displayName>EVENT</spirit:displayName>
            <spirit:description>An event selector. When the selected event is triggered, the trace unit inserts a global timestamp into the trace streams.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVICTLR</spirit:name>
          <spirit:description>ViewInst Main Control Register </spirit:description>
          <spirit:addressOffset>0x080</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFF84F370</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVICTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCVICTLR_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level:
      0
      
      The trace unit generates instruction trace, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not generate instruction trace, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[20]Exception level 0.Bit[21]Exception level 1.Bit[22]Exception level 2.Bit[23]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. If instruction tracing is not implemented for a given exception level, the corresponding bit in this field is not implemented. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level:
      0
      
      The trace unit generates instruction trace, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not generate instruction trace, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[16]Exception level 0.Bit[17]Exception level 1.Bit[18]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[19]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. If instruction tracing is not implemented for a given exception level, the corresponding bit in this field is not implemented. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCVICTLR_15_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCERR</spirit:name>
            <spirit:displayName>TRCERR</spirit:displayName>
            <spirit:description>If TRCIDR3.TRCERR==1, this bit controls whether a trace unit must trace a system error exception:
      0
      
      The trace unit does not trace a system error exception unless it traces the exception or instruction immediately prior to the system error exception.
      
      
    
      1
      
      The trace unit always traces a system error exception.
      
      
    If TRCIDR3.TRCERR==0, this bit is RES0.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCRESET</spirit:name>
            <spirit:displayName>TRCRESET</spirit:displayName>
            <spirit:description>Controls whether a trace unit must trace a Reset exception:
      0
      
      The trace unit does not trace a Reset exception unless it traces the exception or instruction immediately prior to the Reset exception.
      
      
    
      1
      
      The trace unit always traces a Reset exception.
      
      
    </spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSSTATUS</spirit:name>
            <spirit:displayName>SSSTATUS</spirit:displayName>
            <spirit:description>IF TRCIDR4.NUMACPAIRS&gt;0 or TRCIDR.NUMPC&gt;0, this bit returns the status of the start-stop logic:
      0
      
      The start-stop logic is in the stopped state.
      
      
    
      1
      
      The start-stop logic is in the started state.
      
      
    The bit only returns stable data when TRCSTATR.PMSTABLE==1.Before software enables the trace unit, TRCPRGCTLR.EN==1, it must write to this bit to set the initial state of the start-stop logic. If the start-stop logic is not used then set this bit to 1. ARM recommends that the value of this bit is set before each trace run begins.If TRCIDR4.NUMACPAIRS==0 and TRCIDR4.NUMPC==0, this bit is RES0, indicating that the start-stop logic is not implemented.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCVICTLR_8_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EVENT</spirit:name>
            <spirit:displayName>EVENT</spirit:displayName>
            <spirit:description>An event selector. [TODO: Add the bit assignments for EVENT fields into the descriptions directly?]</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVIIECTLR</spirit:name>
          <spirit:description>ViewInst Include-Exclude Control Register </spirit:description>
          <spirit:addressOffset>0x084</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFF0FFF0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVIIECTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCVIIECTLR_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXCLUDE</spirit:name>
            <spirit:displayName>EXCLUDE</spirit:displayName>
            <spirit:description>
      0
      
      
      
      
    
      1
      
      
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCVIIECTLR_15_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INCLUDE</spirit:name>
            <spirit:displayName>INCLUDE</spirit:displayName>
            <spirit:description>Include range field. Selects which address range comparator pairs are in use with ViewInst include control. Each bit represents an address range comparator pair, so bit[m] controls the selection of address range comparator pair m. If bit[m] is:
      0
      
      The address range that address range comparator pair m defines is not selected for ViewInst include control.
      
      
    
      1
      
      The address range that address range comparator pair m defines is selected for ViewInst include control.
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.Selecting no include comparators indicates that all instructions are included by default. The exclude control then indicates which ranges are excluded.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVISSCTLR</spirit:name>
          <spirit:description>ViewInst Start-Stop Control Register </spirit:description>
          <spirit:addressOffset>0x088</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFF00FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVISSCTLR -->
          <spirit:field>
            <spirit:name>STOP</spirit:name>
            <spirit:displayName>STOP</spirit:displayName>
            <spirit:description>Selects which single address comparators are in use with ViewInst start-stop control, for the purpose of stopping trace. Each bit represents a single address comparator, so bit[m] controls the selection of single address comparator m-16. If bit[m] is:
      0
      
      The single address comparator m-16 is not selected as a stop resource.
      
      
    
      1
      
      The single address comparator m-16 is selected as a stop resource.
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of 2 x TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>START</spirit:name>
            <spirit:displayName>START</spirit:displayName>
            <spirit:description>Selects which single address comparators are in use with ViewInst start-stop control, for the purpose of starting trace. Each bit represents a single address comparator, so bit[n] controls the selection of single address comparator n. If bit[n] is:
      0
      
      The single address comparator n is not selected as a start resource.
      
      
    
      1
      
      The single address comparator n is selected as a start resource.
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of 2 x TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVMIDCVR0</spirit:name>
          <spirit:description>VMID Comparator Value Register 0 </spirit:description>
          <spirit:addressOffset>0x640</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVMIDCVR0 -->
          <spirit:field>
            <spirit:name>RESERVED_TRCVMIDCVR0_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE</spirit:name>
            <spirit:displayName>VALUE</spirit:displayName>
            <spirit:description>Contains a VMID value.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_PMU_CPU3</spirit:name>
        <spirit:displayName>APBADDR_PMU_3</spirit:displayName>
        <spirit:description>APBADDR_PMU_3</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">3342336</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_PMU_CPU3>  -->
        <spirit:register>
          <spirit:name>PMAUTHSTATUS</spirit:name>
          <spirit:description>Performance Monitors Authentication Status Register</spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000088</spirit:value>
            <spirit:mask>0xFFFFFFBB</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMAUTHSTATUS -->
          <spirit:field>
            <spirit:name>RES0_PMAUTHSTATUS_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNID</spirit:name>
            <spirit:displayName>SNID</spirit:displayName>
            <spirit:description>Holds the same value as DBGAUTHSTATUS_EL1.SNID.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMAUTHSTATUS_5_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>Holds the same value as DBGAUTHSTATUS_EL1.NSNID.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMAUTHSTATUS_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCCFILTR_EL0</spirit:name>
          <spirit:description>Performance Monitors Cycle Counter Filter Register</spirit:description>
          <spirit:addressOffset>0x47C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCCFILTR_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count cycles in EL1.
      
      
    
      1
      
      Do not count cycles in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count cycles in EL0.
      
      
    
      1
      
      Do not count cycles in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, cycles in Non-secure EL1 are counted.Otherwise, cycles in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, cycles in Non-secure EL0 are counted.Otherwise, cycles in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count cycles in EL2.
      
      
    
      1
      
      Count cycles in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, cycles in Secure EL3 are counted.Otherwise, cycles in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMCCFILTR_EL0_25_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>26</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCCNTR_EL0_31:0</spirit:name>
          <spirit:description>Performance Monitors Cycle Counter (low word)</spirit:description>
          <spirit:addressOffset>0x0F8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCCNTR_EL0_31:0 -->
          <spirit:field>
            <spirit:name>CCNT</spirit:name>
            <spirit:displayName>CCNT</spirit:displayName>
            <spirit:description>Cycle count. Depending on the values of PMCR_EL0.{LC,D}, the cycle count increments in one of the following ways:Every processor clock cycle.Every 64th processor clock cycle.The cycle count can be reset to zero by writing 1 to PMCR_EL0.C.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCCNTR_EL0_63:32</spirit:name>
          <spirit:description>Performance Monitors Cycle Counter (high word)</spirit:description>
          <spirit:addressOffset>0x0FC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCCNTR_EL0_63:32 -->
          <spirit:field>
            <spirit:name>CCNT</spirit:name>
            <spirit:displayName>CCNT</spirit:displayName>
            <spirit:description>Cycle count. Depending on the values of PMCR_EL0.{LC,D}, the cycle count increments in one of the following ways:Every processor clock cycle.Every 64th processor clock cycle.The cycle count can be reset to zero by writing 1 to PMCR_EL0.C.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCEID0_EL0</spirit:name>
          <spirit:description>Performance Monitors Common Event Identification Register 0</spirit:description>
          <spirit:addressOffset>0xE20</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="immediate">1744814079</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCEID0_EL0 -->
          <spirit:field>
            <spirit:name>CE_31:0</spirit:name>
            <spirit:displayName>CE[31:0]</spirit:displayName>
            <spirit:description>Common architectural and microarchitectural feature events that can be counted by the PMU event counters.For each bit described in the following table, the event is implemented if the bit is set to 1, or not implemented if the bit is set to 0.BitEvent numberEvent mnemonic310x01FL1D_CACHE_ALLOCATE300x01ECHAIN290x01DBUS_CYCLES280x01CTTBR_WRITE_RETIRED270x01BINST_SPEC260x01AMEMORY_ERROR250x019BUS_ACCESS240x018L2D_CACHE_WB230x017L2D_CACHE_REFILL220x016L2D_CACHE210x015L1D_CACHE_WB200x014L1I_CACHE190x013MEM_ACCESS180x012BR_PRED170x011CPU_CYCLES160x010BR_MIS_PRED150x00FUNALIGNED_LDST_RETIRED140x00EBR_RETURN_RETIRED130x00DBR_IMMED_RETIRED120x00CPC_WRITE_RETIRED110x00BCID_WRITE_RETIRED100x00AEXC_RETURN90x009EXC_TAKEN80x008INST_RETIRED70x007ST_RETIRED60x006LD_RETIRED50x005L1D_TLB_REFILL40x004L1D_CACHE30x003L1D_CACHE_REFILL20x002L1I_TLB_REFILL10x001L1I_CACHE_REFILL00x000SW_INCR</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCEID1_EL0</spirit:name>
          <spirit:description>Performance Monitors Common Event Identification Register 1</spirit:description>
          <spirit:addressOffset>0xE24</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCEID1_EL0 -->
          <spirit:field>
            <spirit:name>RES0_PMCEID1_EL0_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CE_32</spirit:name>
            <spirit:displayName>CE[32]</spirit:displayName>
            <spirit:description>Common architectural and microarchitectural feature events that can be counted by the PMU event counters.For the bit described in the following table, the event is implemented if the bit is set to 1, or not implemented if the bit is set to 0.BitEvent numberEvent mnemonic00x020L2D_CACHE_ALLOCATE</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCFGR</spirit:name>
          <spirit:description>Performance Monitors Configuration Register</spirit:description>
          <spirit:addressOffset>0xE00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0001FF06</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCFGR -->
          <spirit:field>
            <spirit:name>RES0_PMCFGR_31_20</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>UEN</spirit:name>
            <spirit:displayName>UEN</spirit:displayName>
            <spirit:description>User-mode Enable Register supported. PMUSERENR_EL0 is not visible in the external debug interface, so this bit is RES0.</spirit:description>
            <spirit:bitOffset>19</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>This feature is not supported, so this bit is RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NA</spirit:name>
            <spirit:displayName>NA</spirit:displayName>
            <spirit:description>This feature is not supported, so this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EX</spirit:name>
            <spirit:displayName>EX</spirit:displayName>
            <spirit:description>Export supported. Value is IMPLEMENTATION DEFINED.
      0
      
      PMCR_EL0.X is RES0.
      
      
    
      1
      
      PMCR_EL0.X is read/write.
      
      
    </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCD</spirit:name>
            <spirit:displayName>CCD</spirit:displayName>
            <spirit:description>Cycle counter has prescale. This is RES1 if AArch32 is supported at any EL, and RES0 otherwise.
      0
      
      PMCR_EL0.D is RES0.
      
      
    
      1
      
      PMCR_EL0.D is read/write.
      
      
    </spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CC</spirit:name>
            <spirit:displayName>CC</spirit:displayName>
            <spirit:description>Dedicated cycle counter (counter 31) supported. This bit is RES1.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of counters. This field determines the spacing of counters in the memory-map.In v8-A the counters are at doubleword-aligned addresses, and the largest counter is 64-bits, so this field is 0b111111.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>N</spirit:name>
            <spirit:displayName>N</spirit:displayName>
            <spirit:description>Number of counters implemented in addition to the cycle counter, PMCCNTR_EL0. The maximum number of event counters is 31, so bits[7:5] are always RES0.
      00000000
      
      Only PMCCNTR_EL0 implemented.
      
      
    
      00000001
      
      PMCCNTR_EL0 plus one event counter implemented.
      
      
    and so on up to 0b00011111, which indicates PMCCNTR_EL0 and 31 event counters implemented.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR0</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR1</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR1 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, debug component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR2</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR3</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR3 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCNTENCLR_EL0</spirit:name>
          <spirit:description>Performance Monitors Count Enable Clear Register</spirit:description>
          <spirit:addressOffset>0xC20</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCNTENCLR_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 disable bit. Disables the cycle counter register. Possible values are:
      0
      
      When read, means the cycle counter is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter is enabled. When written, disables the cycle counter.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter disable bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values of each bit are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; is enabled. When written, disables PMEVCNTR&lt;x&gt;.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCNTENSET_EL0</spirit:name>
          <spirit:description>Performance Monitors Count Enable Set Register</spirit:description>
          <spirit:addressOffset>0xC00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCNTENSET_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 enable bit. Enables the cycle counter register. Possible values are:
      0
      
      When read, means the cycle counter is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter is enabled. When written, enables the cycle counter.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter enable bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values of each bit are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; event counter is enabled. When written, enables PMEVCNTR&lt;x&gt;.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCR_EL0</spirit:name>
          <spirit:description>Performance Monitors Control Register</spirit:description>
          <spirit:addressOffset>0xE04</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCR_EL0 -->
          <spirit:field>
            <spirit:name>RES0_PMCR_EL0_31_11</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RAZ/WI.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>21</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMCR_EL0_10_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LC</spirit:name>
            <spirit:displayName>LC</spirit:displayName>
            <spirit:description>Long cycle counter enable. Determines which PMCCNTR_EL0 bit generates an overflow recorded by PMOVSR[31].
      0
      
      Cycle counter overflow on increment that changes PMCCNTR_EL0[31] from 1 to 0.
      
      
    
      1
      
      Cycle counter overflow on increment that changes PMCCNTR_EL0[63] from 1 to 0.
      
      
    ARM deprecates use of PMCR_EL0.LC = 0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DP</spirit:name>
            <spirit:displayName>DP</spirit:displayName>
            <spirit:description>Disable cycle counter when event counting is prohibited. The possible values of this bit are:
      0
      
      PMCCNTR_EL0, if enabled, counts when event counting is prohibited.
      
      
    
      1
      
      PMCCNTR_EL0 does not count when event counting is prohibited.
      
      
    Event counting is prohibited when ProfilingProhibited(IsSecure(),PSTATE.EL) == TRUE.This bit is RW.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>X</spirit:name>
            <spirit:displayName>X</spirit:displayName>
            <spirit:description>Enable export of events in an IMPLEMENTATION DEFINED event stream. The possible values of this bit are:
      0
      
      Do not export events.
      
      
    
      1
      
      Export events where not prohibited.
      
      
    This bit is used to permit events to be exported to another debug device, such as an OPTIONAL trace extension, over an event bus. If the implementation does not include such an event bus, this bit is RAZ/WI.This bit does not affect the generation of Performance Monitors overflow interrupt requests or signaling to a cross-trigger interface (CTI) that can be implemented as signals exported from the processor.If the implementation does not include an exported event stream, this bit is RAZ/WI. Otherwise this bit is RW.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>D</spirit:name>
            <spirit:displayName>D</spirit:displayName>
            <spirit:description>Clock divider. The possible values of this bit are:
      0
      
      When enabled, PMCCNTR_EL0 counts every clock cycle.
      
      
    
      1
      
      When enabled, PMCCNTR_EL0 counts once every 64 clock cycles.
      
      
    This bit is RW.If PMCR_EL0.LC == 1, this bit is ignored and the cycle counter counts every clock cycle.ARM deprecates use of PMCR.D = 1.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>Cycle counter reset. This bit is WO. The effects of writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Reset PMCCNTR_EL0 to zero.
      
      
    This bit is always RAZ.Resetting PMCCNTR_EL0 does not clear the PMCCNTR_EL0 overflow bit to 0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>Event counter reset. This bit is WO. The effects of writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Reset all event counters, not including PMCCNTR_EL0, to zero.
      
      
    This bit is always RAZ.Resetting the event counters does not clear any overflow bits to 0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable. The possible values of this bit are:
      0
      
      All counters, including PMCCNTR_EL0, are disabled.
      
      
    
      1
      
      All counters are enabled by PMCNTENSET_EL0.
      
      
    This bit is RW.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVAFF0</spirit:name>
          <spirit:description>Performance Monitors Device Affinity Register 0</spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000003</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMDEVAFF0 -->
          <spirit:field>
            <spirit:name>PMDEVAFF0</spirit:name>
            <spirit:displayName>PMDEVAFF0</spirit:displayName>
            <spirit:description>MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVAFF1</spirit:name>
          <spirit:description>Performance Monitors Device Affinity Register 1</spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: PMDEVAFF1 -->
          <spirit:field>
            <spirit:name>PMDEVAFF1</spirit:name>
            <spirit:displayName>PMDEVAFF1</spirit:displayName>
            <spirit:description>MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVARCH</spirit:name>
          <spirit:description>Performance Monitors Device Architecture Register</spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47702a16</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For Performance Monitors, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For Performance Monitors, the revision defined by v8-A is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For Performance Monitors:Bits [15:12] are the architecture version, 0x2.Bits [11:0] are the architecture part number, 0xA16.This corresponds to Performance Monitors architecture version PMUv3.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVTYPE</spirit:name>
          <spirit:description>Performance Monitors Device Type Register</spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000016</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_PMDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Subtype. Must read as 0x1 to indicate this is a processor component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAJOR</spirit:name>
            <spirit:displayName>MAJOR</spirit:displayName>
            <spirit:description>Major type. Must read as 0x6 to indicate this is a performance monitor component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR0_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 0</spirit:description>
          <spirit:addressOffset>0x000</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR0_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR0_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR0_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR1_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 1</spirit:description>
          <spirit:addressOffset>0x008</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR1_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR1_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR1_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR2_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 2</spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR2_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR2_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR2_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR3_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 3</spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR3_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR3_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR3_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR4_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 4</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR4_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR4_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR4_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR5_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 5</spirit:description>
          <spirit:addressOffset>0x028</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR5_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR5_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR5_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER0_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 0</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER0_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER0_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER1_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 1</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER1_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER1_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER2_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 2</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER2_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER2_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER3_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 3</spirit:description>
          <spirit:addressOffset>0x40c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER3_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER3_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER4_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 4</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER4_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER4_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER5_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 5</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER5_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER5_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMINTENCLR_EL1</spirit:name>
          <spirit:description>Performance Monitors Interrupt Enable Clear Register</spirit:description>
          <spirit:addressOffset>0xC60</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMINTENCLR_EL1 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow interrupt request disable bit. Possible values are:
      0
      
      When read, means the cycle counter overflow interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter overflow interrupt request is enabled. When written, disables the cycle count overflow interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow interrupt request disable bit for PMEVCNTR&lt;x&gt;_EL0.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values are:
      0
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is enabled. When written, disables the PMEVCNTR&lt;x&gt;_EL0 interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMINTENSET_EL1</spirit:name>
          <spirit:description>Performance Monitors Interrupt Enable Set Register</spirit:description>
          <spirit:addressOffset>0xC40</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMINTENSET_EL1 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow interrupt request enable bit. Possible values are:
      0
      
      When read, means the cycle counter overflow interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter overflow interrupt request is enabled. When written, enables the cycle count overflow interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow interrupt request enable bit for PMEVCNTR&lt;x&gt;_EL0.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values are:
      0
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is enabled. When written, enables the PMEVCNTR&lt;x&gt;_EL0 interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMITCTRL</spirit:name>
          <spirit:description>Performance Monitors Integration mode Control Register</spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMITCTRL -->
          <spirit:field>
            <spirit:name>RES0_PMITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IME</spirit:name>
            <spirit:displayName>IME</spirit:displayName>
            <spirit:description>Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.
      0
      
      Normal operation.
      
      
    
      1
      
      Integration mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMLAR</spirit:name>
          <spirit:description>Performance Monitors Lock Access Register</spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: PMLAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMLSR</spirit:name>
          <spirit:description>Performance Monitors Lock Status Register</spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMLSR -->
          <spirit:field>
            <spirit:name>RES0_PMLSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:
      0
      
      Software lock not implemented or not memory-mapped access.
      
      
    
      1
      
      Software lock implemented and memory-mapped access.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMOVSCLR_EL0</spirit:name>
          <spirit:description>Performance Monitors Overflow Flag Status Clear Register</spirit:description>
          <spirit:addressOffset>0xC80</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMOVSCLR_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow bit. Possible values are:
      0
      
      When read, means the cycle counter has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter has overflowed. When written, clears the overflow bit to 0.
      
      
    PMCR_EL0.LC is used to control from which bit of PMCCNTR_EL0 (bit 31 or bit 63) an overflow is detected.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow clear bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values of each bit are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; has overflowed. When written, clears the PMEVCNTR&lt;x&gt; overflow bit to 0.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMOVSSET_EL0</spirit:name>
          <spirit:description>Performance Monitors Overflow Flag Status Set Register</spirit:description>
          <spirit:addressOffset>0xCC0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMOVSSET_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow bit. Possible values are:
      0
      
      When read, means the cycle counter has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter has overflowed. When written, sets the overflow bit to 1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow set bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; has overflowed. When written, sets the PMEVCNTR&lt;x&gt; overflow bit to 1.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR0</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000D3</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, least significant byte.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR1</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B9</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, most significant nibble.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR2</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Part major revision. Parts can also use this field to extend Part number to 16-bits.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR3</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>Part minor revision. Parts using PMPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR4</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 4</spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR5</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 5</spirit:description>
          <spirit:addressOffset>0xFD4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR5 -->
          <spirit:field>
            <spirit:name>RESERVED_PMPIDR5_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR6</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 6</spirit:description>
          <spirit:addressOffset>0xFD8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR6 -->
          <spirit:field>
            <spirit:name>RESERVED_PMPIDR6_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR7</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 7</spirit:description>
          <spirit:addressOffset>0xFDC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR7 -->
          <spirit:field>
            <spirit:name>RESERVED_PMPIDR7_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMSWINC_EL0</spirit:name>
          <spirit:description>Performance Monitors Software Increment Register</spirit:description>
          <spirit:addressOffset>0xCA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: PMSWINC_EL0 -->
          <spirit:field>
            <spirit:name>RESERVED_PMSWINC_EL0_31_6</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>26</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P_x</spirit:displayName>
            <spirit:description>Event counter software increment bit for PMEVCNTR&lt;x&gt;</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_PMU_CPU2</spirit:name>
        <spirit:displayName>APBADDR_PMU_2</spirit:displayName>
        <spirit:description>APBADDR_PMU_2</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">2293760</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_PMU_CPU2>  -->
        <spirit:register>
          <spirit:name>PMAUTHSTATUS</spirit:name>
          <spirit:description>Performance Monitors Authentication Status Register</spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000088</spirit:value>
            <spirit:mask>0xFFFFFFBB</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMAUTHSTATUS -->
          <spirit:field>
            <spirit:name>RES0_PMAUTHSTATUS_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNID</spirit:name>
            <spirit:displayName>SNID</spirit:displayName>
            <spirit:description>Holds the same value as DBGAUTHSTATUS_EL1.SNID.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMAUTHSTATUS_5_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>Holds the same value as DBGAUTHSTATUS_EL1.NSNID.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMAUTHSTATUS_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCCFILTR_EL0</spirit:name>
          <spirit:description>Performance Monitors Cycle Counter Filter Register</spirit:description>
          <spirit:addressOffset>0x47C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCCFILTR_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count cycles in EL1.
      
      
    
      1
      
      Do not count cycles in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count cycles in EL0.
      
      
    
      1
      
      Do not count cycles in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, cycles in Non-secure EL1 are counted.Otherwise, cycles in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, cycles in Non-secure EL0 are counted.Otherwise, cycles in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count cycles in EL2.
      
      
    
      1
      
      Count cycles in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, cycles in Secure EL3 are counted.Otherwise, cycles in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMCCFILTR_EL0_25_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>26</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCCNTR_EL0_31:0</spirit:name>
          <spirit:description>Performance Monitors Cycle Counter (low word)</spirit:description>
          <spirit:addressOffset>0x0F8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCCNTR_EL0_31:0 -->
          <spirit:field>
            <spirit:name>CCNT</spirit:name>
            <spirit:displayName>CCNT</spirit:displayName>
            <spirit:description>Cycle count. Depending on the values of PMCR_EL0.{LC,D}, the cycle count increments in one of the following ways:Every processor clock cycle.Every 64th processor clock cycle.The cycle count can be reset to zero by writing 1 to PMCR_EL0.C.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCCNTR_EL0_63:32</spirit:name>
          <spirit:description>Performance Monitors Cycle Counter (high word)</spirit:description>
          <spirit:addressOffset>0x0FC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCCNTR_EL0_63:32 -->
          <spirit:field>
            <spirit:name>CCNT</spirit:name>
            <spirit:displayName>CCNT</spirit:displayName>
            <spirit:description>Cycle count. Depending on the values of PMCR_EL0.{LC,D}, the cycle count increments in one of the following ways:Every processor clock cycle.Every 64th processor clock cycle.The cycle count can be reset to zero by writing 1 to PMCR_EL0.C.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCEID0_EL0</spirit:name>
          <spirit:description>Performance Monitors Common Event Identification Register 0</spirit:description>
          <spirit:addressOffset>0xE20</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="immediate">1744814079</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCEID0_EL0 -->
          <spirit:field>
            <spirit:name>CE_31:0</spirit:name>
            <spirit:displayName>CE[31:0]</spirit:displayName>
            <spirit:description>Common architectural and microarchitectural feature events that can be counted by the PMU event counters.For each bit described in the following table, the event is implemented if the bit is set to 1, or not implemented if the bit is set to 0.BitEvent numberEvent mnemonic310x01FL1D_CACHE_ALLOCATE300x01ECHAIN290x01DBUS_CYCLES280x01CTTBR_WRITE_RETIRED270x01BINST_SPEC260x01AMEMORY_ERROR250x019BUS_ACCESS240x018L2D_CACHE_WB230x017L2D_CACHE_REFILL220x016L2D_CACHE210x015L1D_CACHE_WB200x014L1I_CACHE190x013MEM_ACCESS180x012BR_PRED170x011CPU_CYCLES160x010BR_MIS_PRED150x00FUNALIGNED_LDST_RETIRED140x00EBR_RETURN_RETIRED130x00DBR_IMMED_RETIRED120x00CPC_WRITE_RETIRED110x00BCID_WRITE_RETIRED100x00AEXC_RETURN90x009EXC_TAKEN80x008INST_RETIRED70x007ST_RETIRED60x006LD_RETIRED50x005L1D_TLB_REFILL40x004L1D_CACHE30x003L1D_CACHE_REFILL20x002L1I_TLB_REFILL10x001L1I_CACHE_REFILL00x000SW_INCR</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCEID1_EL0</spirit:name>
          <spirit:description>Performance Monitors Common Event Identification Register 1</spirit:description>
          <spirit:addressOffset>0xE24</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCEID1_EL0 -->
          <spirit:field>
            <spirit:name>RES0_PMCEID1_EL0_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CE_32</spirit:name>
            <spirit:displayName>CE[32]</spirit:displayName>
            <spirit:description>Common architectural and microarchitectural feature events that can be counted by the PMU event counters.For the bit described in the following table, the event is implemented if the bit is set to 1, or not implemented if the bit is set to 0.BitEvent numberEvent mnemonic00x020L2D_CACHE_ALLOCATE</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCFGR</spirit:name>
          <spirit:description>Performance Monitors Configuration Register</spirit:description>
          <spirit:addressOffset>0xE00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0001FF06</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCFGR -->
          <spirit:field>
            <spirit:name>RES0_PMCFGR_31_20</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>UEN</spirit:name>
            <spirit:displayName>UEN</spirit:displayName>
            <spirit:description>User-mode Enable Register supported. PMUSERENR_EL0 is not visible in the external debug interface, so this bit is RES0.</spirit:description>
            <spirit:bitOffset>19</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>This feature is not supported, so this bit is RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NA</spirit:name>
            <spirit:displayName>NA</spirit:displayName>
            <spirit:description>This feature is not supported, so this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EX</spirit:name>
            <spirit:displayName>EX</spirit:displayName>
            <spirit:description>Export supported. Value is IMPLEMENTATION DEFINED.
      0
      
      PMCR_EL0.X is RES0.
      
      
    
      1
      
      PMCR_EL0.X is read/write.
      
      
    </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCD</spirit:name>
            <spirit:displayName>CCD</spirit:displayName>
            <spirit:description>Cycle counter has prescale. This is RES1 if AArch32 is supported at any EL, and RES0 otherwise.
      0
      
      PMCR_EL0.D is RES0.
      
      
    
      1
      
      PMCR_EL0.D is read/write.
      
      
    </spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CC</spirit:name>
            <spirit:displayName>CC</spirit:displayName>
            <spirit:description>Dedicated cycle counter (counter 31) supported. This bit is RES1.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of counters. This field determines the spacing of counters in the memory-map.In v8-A the counters are at doubleword-aligned addresses, and the largest counter is 64-bits, so this field is 0b111111.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>N</spirit:name>
            <spirit:displayName>N</spirit:displayName>
            <spirit:description>Number of counters implemented in addition to the cycle counter, PMCCNTR_EL0. The maximum number of event counters is 31, so bits[7:5] are always RES0.
      00000000
      
      Only PMCCNTR_EL0 implemented.
      
      
    
      00000001
      
      PMCCNTR_EL0 plus one event counter implemented.
      
      
    and so on up to 0b00011111, which indicates PMCCNTR_EL0 and 31 event counters implemented.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR0</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR1</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR1 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, debug component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR2</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCIDR3</spirit:name>
          <spirit:description>Performance Monitors Component Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCIDR3 -->
          <spirit:field>
            <spirit:name>RES0_PMCIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCNTENCLR_EL0</spirit:name>
          <spirit:description>Performance Monitors Count Enable Clear Register</spirit:description>
          <spirit:addressOffset>0xC20</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCNTENCLR_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 disable bit. Disables the cycle counter register. Possible values are:
      0
      
      When read, means the cycle counter is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter is enabled. When written, disables the cycle counter.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter disable bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values of each bit are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; is enabled. When written, disables PMEVCNTR&lt;x&gt;.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCNTENSET_EL0</spirit:name>
          <spirit:description>Performance Monitors Count Enable Set Register</spirit:description>
          <spirit:addressOffset>0xC00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCNTENSET_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 enable bit. Enables the cycle counter register. Possible values are:
      0
      
      When read, means the cycle counter is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter is enabled. When written, enables the cycle counter.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter enable bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values of each bit are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; event counter is enabled. When written, enables PMEVCNTR&lt;x&gt;.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMCR_EL0</spirit:name>
          <spirit:description>Performance Monitors Control Register</spirit:description>
          <spirit:addressOffset>0xE04</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMCR_EL0 -->
          <spirit:field>
            <spirit:name>RES0_PMCR_EL0_31_11</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RAZ/WI.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>21</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMCR_EL0_10_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LC</spirit:name>
            <spirit:displayName>LC</spirit:displayName>
            <spirit:description>Long cycle counter enable. Determines which PMCCNTR_EL0 bit generates an overflow recorded by PMOVSR[31].
      0
      
      Cycle counter overflow on increment that changes PMCCNTR_EL0[31] from 1 to 0.
      
      
    
      1
      
      Cycle counter overflow on increment that changes PMCCNTR_EL0[63] from 1 to 0.
      
      
    ARM deprecates use of PMCR_EL0.LC = 0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DP</spirit:name>
            <spirit:displayName>DP</spirit:displayName>
            <spirit:description>Disable cycle counter when event counting is prohibited. The possible values of this bit are:
      0
      
      PMCCNTR_EL0, if enabled, counts when event counting is prohibited.
      
      
    
      1
      
      PMCCNTR_EL0 does not count when event counting is prohibited.
      
      
    Event counting is prohibited when ProfilingProhibited(IsSecure(),PSTATE.EL) == TRUE.This bit is RW.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>X</spirit:name>
            <spirit:displayName>X</spirit:displayName>
            <spirit:description>Enable export of events in an IMPLEMENTATION DEFINED event stream. The possible values of this bit are:
      0
      
      Do not export events.
      
      
    
      1
      
      Export events where not prohibited.
      
      
    This bit is used to permit events to be exported to another debug device, such as an OPTIONAL trace extension, over an event bus. If the implementation does not include such an event bus, this bit is RAZ/WI.This bit does not affect the generation of Performance Monitors overflow interrupt requests or signaling to a cross-trigger interface (CTI) that can be implemented as signals exported from the processor.If the implementation does not include an exported event stream, this bit is RAZ/WI. Otherwise this bit is RW.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>D</spirit:name>
            <spirit:displayName>D</spirit:displayName>
            <spirit:description>Clock divider. The possible values of this bit are:
      0
      
      When enabled, PMCCNTR_EL0 counts every clock cycle.
      
      
    
      1
      
      When enabled, PMCCNTR_EL0 counts once every 64 clock cycles.
      
      
    This bit is RW.If PMCR_EL0.LC == 1, this bit is ignored and the cycle counter counts every clock cycle.ARM deprecates use of PMCR.D = 1.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>Cycle counter reset. This bit is WO. The effects of writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Reset PMCCNTR_EL0 to zero.
      
      
    This bit is always RAZ.Resetting PMCCNTR_EL0 does not clear the PMCCNTR_EL0 overflow bit to 0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>Event counter reset. This bit is WO. The effects of writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Reset all event counters, not including PMCCNTR_EL0, to zero.
      
      
    This bit is always RAZ.Resetting the event counters does not clear any overflow bits to 0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable. The possible values of this bit are:
      0
      
      All counters, including PMCCNTR_EL0, are disabled.
      
      
    
      1
      
      All counters are enabled by PMCNTENSET_EL0.
      
      
    This bit is RW.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVAFF0</spirit:name>
          <spirit:description>Performance Monitors Device Affinity Register 0</spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000002</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMDEVAFF0 -->
          <spirit:field>
            <spirit:name>PMDEVAFF0</spirit:name>
            <spirit:displayName>PMDEVAFF0</spirit:displayName>
            <spirit:description>MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVAFF1</spirit:name>
          <spirit:description>Performance Monitors Device Affinity Register 1</spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: PMDEVAFF1 -->
          <spirit:field>
            <spirit:name>PMDEVAFF1</spirit:name>
            <spirit:displayName>PMDEVAFF1</spirit:displayName>
            <spirit:description>MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVARCH</spirit:name>
          <spirit:description>Performance Monitors Device Architecture Register</spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47702a16</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For Performance Monitors, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For Performance Monitors, the revision defined by v8-A is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For Performance Monitors:Bits [15:12] are the architecture version, 0x2.Bits [11:0] are the architecture part number, 0xA16.This corresponds to Performance Monitors architecture version PMUv3.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMDEVTYPE</spirit:name>
          <spirit:description>Performance Monitors Device Type Register</spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000016</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_PMDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Subtype. Must read as 0x1 to indicate this is a processor component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAJOR</spirit:name>
            <spirit:displayName>MAJOR</spirit:displayName>
            <spirit:description>Major type. Must read as 0x6 to indicate this is a performance monitor component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR0_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 0</spirit:description>
          <spirit:addressOffset>0x000</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR0_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR0_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR0_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR1_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 1</spirit:description>
          <spirit:addressOffset>0x008</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR1_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR1_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR1_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR2_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 2</spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR2_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR2_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR2_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR3_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 3</spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR3_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR3_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR3_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR4_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 4</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR4_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR4_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR4_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVCNTR5_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Count Register 5</spirit:description>
          <spirit:addressOffset>0x028</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVCNTR5_EL0 -->
          <spirit:field>
            <spirit:name>PMEVCNTR5_EL0</spirit:name>
            <spirit:displayName>PMEVCNTR5_EL0</spirit:displayName>
            <spirit:description>Event counter n. Value of event counter n, where n is the number of this register and is a number from 0 to 30.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER0_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 0</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER0_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER0_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER1_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 1</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER1_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER1_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER2_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 2</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER2_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER2_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER3_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 3</spirit:description>
          <spirit:addressOffset>0x40c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER3_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER3_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER4_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 4</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER4_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER4_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMEVTYPER5_EL0</spirit:name>
          <spirit:description>Performance Monitors Event Type Register 5</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMEVTYPER5_EL0 -->
          <spirit:field>
            <spirit:name>P</spirit:name>
            <spirit:displayName>P</spirit:displayName>
            <spirit:description>EL1 modes filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:
      0
      
      Count events in EL1.
      
      
    
      1
      
      Do not count events in EL1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>U</spirit:name>
            <spirit:displayName>U</spirit:displayName>
            <spirit:description>EL0 filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:
      0
      
      Count events in EL0.
      
      
    
      1
      
      Do not count events in EL0.
      
      
    </spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSK</spirit:name>
            <spirit:displayName>NSK</spirit:displayName>
            <spirit:description>Non-secure kernel modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Non-secure EL1 are counted.Otherwise, events in Non-secure EL1 are not counted.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSU</spirit:name>
            <spirit:displayName>NSU</spirit:displayName>
            <spirit:description>Non-secure user modes filtering bit. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of U, events in Non-secure EL0 are counted.Otherwise, events in Non-secure EL0 are not counted.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSH</spirit:name>
            <spirit:displayName>NSH</spirit:displayName>
            <spirit:description>Non-secure Hyp modes filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.
      0
      
      Do not count events in EL2.
      
      
    
      1
      
      Count events in EL2.
      
      
    </spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>M</spirit:name>
            <spirit:displayName>M</spirit:displayName>
            <spirit:description>Secure EL3 filtering bit. Most applications can ignore this bit and set the value to zero. If EL3 is not implemented, this bit is RES0.If the value of this bit is equal to the value of P, events in Secure EL3 are counted.Otherwise, events in Secure EL3 are not counted.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_PMEVTYPER5_EL0_25_10</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>evtCount</spirit:name>
            <spirit:displayName>evtCount</spirit:displayName>
            <spirit:description>Event to count. The event number of the event that is counted by event counter PMEVCNTR&lt;n&gt;_EL0.Software must program this field with an event defined by the processor or a common event defined by the architecture.If evtCount is programmed to an event that is reserved or not implemented, the behavior depends on the event type.For common architectural and microarchitectural events:No events are counted.The value read back on evtCount is the value written.For IMPLEMENTATION DEFINED events:It is UNPREDICTABLE what event, if any, is counted. UNPREDICTABLE in this case means the event must not expose privileged information.The value read back on evtCount is an UNKNOWN value with the same effect.ARM recommends that the behavior across a family of implementations is defined such that if a given implementation does not include an event from a set of common IMPLEMENTATION DEFINED events, then no event is counted and the value read back on evtCount is the value written.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMINTENCLR_EL1</spirit:name>
          <spirit:description>Performance Monitors Interrupt Enable Clear Register</spirit:description>
          <spirit:addressOffset>0xC60</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMINTENCLR_EL1 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow interrupt request disable bit. Possible values are:
      0
      
      When read, means the cycle counter overflow interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter overflow interrupt request is enabled. When written, disables the cycle count overflow interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow interrupt request disable bit for PMEVCNTR&lt;x&gt;_EL0.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values are:
      0
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is enabled. When written, disables the PMEVCNTR&lt;x&gt;_EL0 interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMINTENSET_EL1</spirit:name>
          <spirit:description>Performance Monitors Interrupt Enable Set Register</spirit:description>
          <spirit:addressOffset>0xC40</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMINTENSET_EL1 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow interrupt request enable bit. Possible values are:
      0
      
      When read, means the cycle counter overflow interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter overflow interrupt request is enabled. When written, enables the cycle count overflow interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow interrupt request enable bit for PMEVCNTR&lt;x&gt;_EL0.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values are:
      0
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is disabled. When written, has no effect.
      
      
    
      1
      
      When read, means that the PMEVCNTR&lt;x&gt;_EL0 event counter interrupt request is enabled. When written, enables the PMEVCNTR&lt;x&gt;_EL0 interrupt request.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMITCTRL</spirit:name>
          <spirit:description>Performance Monitors Integration mode Control Register</spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMITCTRL -->
          <spirit:field>
            <spirit:name>RES0_PMITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IME</spirit:name>
            <spirit:displayName>IME</spirit:displayName>
            <spirit:description>Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.
      0
      
      Normal operation.
      
      
    
      1
      
      Integration mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMLAR</spirit:name>
          <spirit:description>Performance Monitors Lock Access Register</spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: PMLAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMLSR</spirit:name>
          <spirit:description>Performance Monitors Lock Status Register</spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMLSR -->
          <spirit:field>
            <spirit:name>RES0_PMLSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:
      0
      
      Software lock not implemented or not memory-mapped access.
      
      
    
      1
      
      Software lock implemented and memory-mapped access.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMOVSCLR_EL0</spirit:name>
          <spirit:description>Performance Monitors Overflow Flag Status Clear Register</spirit:description>
          <spirit:addressOffset>0xC80</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMOVSCLR_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow bit. Possible values are:
      0
      
      When read, means the cycle counter has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter has overflowed. When written, clears the overflow bit to 0.
      
      
    PMCR_EL0.LC is used to control from which bit of PMCCNTR_EL0 (bit 31 or bit 63) an overflow is detected.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow clear bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values of each bit are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; has overflowed. When written, clears the PMEVCNTR&lt;x&gt; overflow bit to 0.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMOVSSET_EL0</spirit:name>
          <spirit:description>Performance Monitors Overflow Flag Status Set Register</spirit:description>
          <spirit:addressOffset>0xCC0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMOVSSET_EL0 -->
          <spirit:field>
            <spirit:name>C</spirit:name>
            <spirit:displayName>C</spirit:displayName>
            <spirit:description>PMCCNTR_EL0 overflow bit. Possible values are:
      0
      
      When read, means the cycle counter has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means the cycle counter has overflowed. When written, sets the overflow bit to 1.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P&lt;x&gt;</spirit:displayName>
            <spirit:description>Event counter overflow set bit for PMEVCNTR&lt;x&gt;.N is the value in PMCR_EL0.N. Bits [30:N] are RAZ/WI.Possible values are:
      0
      
      When read, means that PMEVCNTR&lt;x&gt; has not overflowed. When written, has no effect.
      
      
    
      1
      
      When read, means that PMEVCNTR&lt;x&gt; has overflowed. When written, sets the PMEVCNTR&lt;x&gt; overflow bit to 1.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR0</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000D3</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, least significant byte.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR1</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B9</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, most significant nibble.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR2</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Part major revision. Parts can also use this field to extend Part number to 16-bits.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR3</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>Part minor revision. Parts using PMPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR4</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 4</spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_PMPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR5</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 5</spirit:description>
          <spirit:addressOffset>0xFD4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR5 -->
          <spirit:field>
            <spirit:name>RESERVED_PMPIDR5_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR6</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 6</spirit:description>
          <spirit:addressOffset>0xFD8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR6 -->
          <spirit:field>
            <spirit:name>RESERVED_PMPIDR6_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMPIDR7</spirit:name>
          <spirit:description>Performance Monitors Peripheral Identification Register 7</spirit:description>
          <spirit:addressOffset>0xFDC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: PMPIDR7 -->
          <spirit:field>
            <spirit:name>RESERVED_PMPIDR7_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>PMSWINC_EL0</spirit:name>
          <spirit:description>Performance Monitors Software Increment Register</spirit:description>
          <spirit:addressOffset>0xCA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: PMSWINC_EL0 -->
          <spirit:field>
            <spirit:name>RESERVED_PMSWINC_EL0_31_6</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>26</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>P_x</spirit:name>
            <spirit:displayName>P_x</spirit:displayName>
            <spirit:description>Event counter software increment bit for PMEVCNTR&lt;x&gt;</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      
      <spirit:addressBlock>
        <spirit:name>APBADDR_CTI_CPU3</spirit:name>
        <spirit:displayName>APBADDR_CTI_3</spirit:displayName>
        <spirit:description>APBADDR_CTI_3</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">3276800</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_CTI_CPU3>  -->
        <spirit:register>
          <spirit:name>ASICCTL</spirit:name>
          <spirit:description>CTI External Multiplexor Control register</spirit:description>
          <spirit:addressOffset>0x144</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ASICCTL -->
          <spirit:field>
            <spirit:name>RES0_ASICCTL_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ASICCTL</spirit:name>
            <spirit:displayName>ASICCTL</spirit:displayName>
            <spirit:description>IMPLEMENTATION DEFINED ASIC control. Provides a control for external multiplexing of additional triggers into the CTI.If external multiplexing of trigger signals is implemented then the number of multiplexed signals on each trigger must be reflected in CTIDEVID.EXTMUXNUM.If CTIDEVID.EXTMUXNUM is zero, this field is RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAPPCLEAR</spirit:name>
          <spirit:description>CTI Application Trigger Clear Register</spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTIAPPCLEAR -->
          <spirit:field>
            <spirit:name>RESERVED_CTIAPPCLEAR_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTIAPPCLEARx</spirit:name>
            <spirit:displayName>CTIAPPCLEARx</spirit:displayName>
            <spirit:description>Application trigger &lt;x&gt; disable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAPPPULSE</spirit:name>
          <spirit:description>CTI Application Pulse Register</spirit:description>
          <spirit:addressOffset>0x01C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTIAPPPULSE -->
          <spirit:field>
            <spirit:name>RESERVED_CTIAPPPULSE_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTIAPPPULSEx</spirit:name>
            <spirit:displayName>CTIAPPPULSEx</spirit:displayName>
            <spirit:description>Generate event pulse on ECT channel &lt;x&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAPPSET</spirit:name>
          <spirit:description>CTI Application Trigger Set Register</spirit:description>
          <spirit:addressOffset>0x014</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIAPPSET -->
          <spirit:field>
            <spirit:name>RESERVED_CTIAPPSET_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTIAPPSETx</spirit:name>
            <spirit:displayName>CTIAPPSETx</spirit:displayName>
            <spirit:description>Application trigger &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAUTHSTATUS</spirit:name>
          <spirit:description>CTI Authentication Status Register</spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000A</spirit:value>
            <spirit:mask>0xFFFFFFAA</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIAUTHSTATUS -->
          <spirit:field>
            <spirit:name>RES0_CTIAUTHSTATUS_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>If EL3 is not implemented and the processor is Secure, holds the same value as DBGAUTHSTATUS_EL1.SNID.Otherwise, holds the same value as DBGAUTHSTATUS_EL1.NSNID.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSID</spirit:name>
            <spirit:displayName>NSID</spirit:displayName>
            <spirit:description>If EL3 is not implemented and the processor is Secure, holds the same value as DBGAUTHSTATUS_EL1.SID.Otherwise, holds the same value as DBGAUTHSTATUS_EL1.NSID.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICHINSTATUS</spirit:name>
          <spirit:description>CTI Channel In Status Register</spirit:description>
          <spirit:addressOffset>0x138</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICHINSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTICHINSTATUS_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CHINn</spirit:name>
            <spirit:displayName>CHINn</spirit:displayName>
            <spirit:description>Provides the raw status of the ECT channel inputs to the CTI</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICHOUTSTATUS</spirit:name>
          <spirit:description>CTI Channel Out Status Register</spirit:description>
          <spirit:addressOffset>0x13C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICHOUTSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTICHOUTSTATUS_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CHOUTn</spirit:name>
            <spirit:displayName>CHOUTn</spirit:displayName>
            <spirit:description>Provides the status of the ECT channel outputs from the CTI</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR0</spirit:name>
          <spirit:description>CTI Component Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR0 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR1</spirit:name>
          <spirit:description>CTI Component Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR1 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, debug component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR2</spirit:name>
          <spirit:description>CTI Component Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR2 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR3</spirit:name>
          <spirit:description>CTI Component Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR3 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICLAIMCLR</spirit:name>
          <spirit:description>CTI Claim Clear</spirit:description>
          <spirit:addressOffset>0xFA4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICLAIMCLR -->
          <spirit:field>
            <spirit:name>RESERVED_CTICLAIMCLR_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIMx</spirit:name>
            <spirit:displayName>CLAIMx</spirit:displayName>
            <spirit:description>Clear CLAIM tag</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICLAIMSET</spirit:name>
          <spirit:description>CTI Claim Set</spirit:description>
          <spirit:addressOffset>0xFA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000f</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICLAIMSET -->
          <spirit:field>
            <spirit:name>RESERVED_CTICLAIMSET_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIMx</spirit:name>
            <spirit:displayName>CLAIMx</spirit:displayName>
            <spirit:description>CLAIM tag set bit</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICONTROL</spirit:name>
          <spirit:description>CTI Control Register</spirit:description>
          <spirit:addressOffset>0x000</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICONTROL -->
          <spirit:field>
            <spirit:name>RES0_CTICONTROL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GLBEN</spirit:name>
            <spirit:displayName>GLBEN</spirit:displayName>
            <spirit:description>Enables or disables the CTI mapping functions. Possible values of this field are:
      0
      
      CTI mapping functions disabled.
      
      
    
      1
      
      CTI mapping functions enabled.
      
      
    When the mapping functions are disabled, no new events are signaled on either output triggers or output channels. If a previously asserted output trigger has not been acknowledged, it remains asserted after the mapping functions are disabled. All output triggers are disabled by CTI reset.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVAFF0</spirit:name>
          <spirit:description>CTI Device Affinity Register 0</spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000003</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVAFF0 -->
          <spirit:field>
            <spirit:name>CTIDEVAFF0</spirit:name>
            <spirit:displayName>CTIDEVAFF0</spirit:displayName>
            <spirit:description>MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVAFF1</spirit:name>
          <spirit:description>CTI Device Affinity Register 1</spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVAFF1 -->
          <spirit:field>
            <spirit:name>CTIDEVAFF1</spirit:name>
            <spirit:displayName>CTIDEVAFF1</spirit:displayName>
            <spirit:description>MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVARCH</spirit:name>
          <spirit:description>CTI Device Architecture Register</spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47701A14</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For CTI, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For CTI, the revision defined by v8-A is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For CTI:Bits [15:12] are the architecture version, 0x1.Bits [11:0] are the architecture part number, 0xA14.This corresponds to CTI architecture version CTIv2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVID</spirit:name>
          <spirit:description>CTI Device ID Register 0</spirit:description>
          <spirit:addressOffset>0xFC8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x01040800</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVID -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_31_26</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INOUT</spirit:name>
            <spirit:displayName>INOUT</spirit:displayName>
            <spirit:description>Input/output options. Indicates presence of the input gate. If the CTM is not implemented, this field is RAZ.
      00
      
      CTIGATE does not mask propagation of input events from external channels.
      
      
    
      01
      
      CTIGATE masks propagation of input events from external channels.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_23_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMCHAN</spirit:name>
            <spirit:displayName>NUMCHAN</spirit:displayName>
            <spirit:description>Number of ECT channels implemented. IMPLEMENTATION DEFINED. For v8-A, valid values are:
      000011
      
      3 channels (0..2) implemented.
      
      
    
      000100
      
      4 channels (0..3) implemented.
      
      
    
      000101
      
      5 channels (0..4) implemented.
      
      
    
      000110
      
      6 channels (0..5) implemented.
      
      
    and so on up to 0b100000, 32 channels (0..31) implemented.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_15_14</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMTRIG</spirit:name>
            <spirit:displayName>NUMTRIG</spirit:displayName>
            <spirit:description>Number of triggers implemented. IMPLEMENTATION DEFINED. This is one more than the index of the largest trigger, rather than the actual number of triggers.For v8-A, valid values are:
      000011
      
      Up to 3 triggers (0..2) implemented.
      
      
    
      001000
      
      Up to 8 triggers (0..7) implemented.
      
      
    
      001001
      
      Up to 9 triggers (0..8) implemented.
      
      
    
      001010
      
      Up to 10 triggers (0..9) implemented.
      
      
    and so on up to 0b100000, 32 triggers (0..31) implemented.All other values are reserved. If the Trace Extension is implemented, this field must be at least 001000. There is no guarantee that any of the implemented triggers, including the highest numbered, are connected to any components.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_7_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXTMUXNUM</spirit:name>
            <spirit:displayName>EXTMUXNUM</spirit:displayName>
            <spirit:description>Maximum number of external triggers available for multiplexing into the CTI. This relates only to additional external triggers outside those defined for v8-A.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVID1</spirit:name>
          <spirit:description>CTI Device ID Register 1</spirit:description>
          <spirit:addressOffset>0xFC4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVID1 -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVID1_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVID2</spirit:name>
          <spirit:description>CTI Device ID Register 2</spirit:description>
          <spirit:addressOffset>0xFC0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVID2 -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVID2_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVTYPE</spirit:name>
          <spirit:description>CTI Device Type Register</spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000014</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Subtype. Must read as 0x1 to indicate this is a processor component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAJOR</spirit:name>
            <spirit:displayName>MAJOR</spirit:displayName>
            <spirit:description>Major type. Must read as 0x4 to indicate this is a cross-trigger component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIGATE</spirit:name>
          <spirit:description>CTI Channel Gate Enable Register</spirit:description>
          <spirit:addressOffset>0x140</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000F</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIGATE -->
          <spirit:field>
            <spirit:name>RESERVED_CTIGATE_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GATEx</spirit:name>
            <spirit:displayName>GATEx</spirit:displayName>
            <spirit:description>Determines whether events on channels propagate through the CTM to other ECT components or from the CTM into the CTI</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN0</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 0</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN0 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN0_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 0 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN1</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 1</spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN1 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN1_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 1 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN2</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 2</spirit:description>
          <spirit:addressOffset>0x028</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN2 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN2_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 2 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN3</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 3</spirit:description>
          <spirit:addressOffset>0x02c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN3 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN3_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 3 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN4</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 4</spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN4 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN4_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 4 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN5</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 5</spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN5 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN5_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 5 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN6</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 6</spirit:description>
          <spirit:addressOffset>0x038</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN6 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN6_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 6 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN7</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 7</spirit:description>
          <spirit:addressOffset>0x03c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN7 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN7_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 7 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINTACK</spirit:name>
          <spirit:description>CTI Output Trigger Acknowledge Register</spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTIINTACK -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINTACK_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ACK_n</spirit:name>
            <spirit:displayName>ACK_n</spirit:displayName>
            <spirit:description>Can be used to create soft acknowledges for output triggers</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIITCTRL</spirit:name>
          <spirit:description>CTI Integration mode Control Register</spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIITCTRL -->
          <spirit:field>
            <spirit:name>RES0_CTIITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IME</spirit:name>
            <spirit:displayName>IME</spirit:displayName>
            <spirit:description>Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.
      0
      
      Normal operation.
      
      
    
      1
      
      Integration mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTILAR</spirit:name>
          <spirit:description>CTI Lock Access Register</spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTILAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTILSR</spirit:name>
          <spirit:description>CTI Lock Status Register</spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFC</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTILSR -->
          <spirit:field>
            <spirit:name>RES0_CTILSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:
      0
      
      Software lock not implemented or not memory-mapped access.
      
      
    
      1
      
      Software lock implemented and memory-mapped access.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN0</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 0</spirit:description>
          <spirit:addressOffset>0x0A0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN0 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN0_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 0 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN1</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 1</spirit:description>
          <spirit:addressOffset>0x0A4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN1 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN1_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 1 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN2</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 2</spirit:description>
          <spirit:addressOffset>0x0A8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN2 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN2_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 2 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN3</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 3</spirit:description>
          <spirit:addressOffset>0x0AC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN3 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN3_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 3 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN4</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 4</spirit:description>
          <spirit:addressOffset>0x0B0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN4 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN4_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 4 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN5</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 5</spirit:description>
          <spirit:addressOffset>0x0B4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN5 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN5_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 5 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN6</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 6</spirit:description>
          <spirit:addressOffset>0x0B8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN6 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN6_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 6 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN7</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 7</spirit:description>
          <spirit:addressOffset>0x0BC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN7 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN7_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 7 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR0</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000A8</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, least significant byte.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR1</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B9</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, most significant nibble.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR2</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Part major revision. Parts can also use this field to extend Part number to 16-bits.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR3</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>Part minor revision. Parts using CTIPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR4</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 4</spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR5</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 5</spirit:description>
          <spirit:addressOffset>0xFD4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR5 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIPIDR5_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR6</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 6</spirit:description>
          <spirit:addressOffset>0xFD8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR6 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIPIDR6_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR7</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 7</spirit:description>
          <spirit:addressOffset>0xFDC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR7 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIPIDR7_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTITRIGINSTATUS</spirit:name>
          <spirit:description>CTI Trigger In Status Register</spirit:description>
          <spirit:addressOffset>0x130</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTITRIGINSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTITRIGINSTATUS_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRINn</spirit:name>
            <spirit:displayName>TRINn</spirit:displayName>
            <spirit:description>Provides the status of the trigger inputs</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTITRIGOUTSTATUS</spirit:name>
          <spirit:description>CTI Trigger Out Status Register</spirit:description>
          <spirit:addressOffset>0x134</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTITRIGOUTSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTITRIGOUTSTATUS_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TROUTn</spirit:name>
            <spirit:displayName>TROUTn</spirit:displayName>
            <spirit:description>Provides the status of the trigger outputs</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_ROMV8</spirit:name>
        <spirit:displayName>APBADDR_ROMV8</spirit:displayName>
        <spirit:description>APBADDR_ROMV8</spirit:description>
        <spirit:baseAddress>0x00000</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_ROMV8>  -->
        <spirit:register>
          <spirit:name>ROMENTRY0</spirit:name>
          <spirit:description>ROM Table Entry Register 0 (CPU 0 Debug Component)</spirit:description>
          <spirit:addressOffset>0x000</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00010003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY1</spirit:name>
          <spirit:description>ROM Table Entry Register 1 (CPU 0 CTI Component)</spirit:description>
          <spirit:addressOffset>0x004</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00020003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY10</spirit:name>
          <spirit:description>ROM Table Entry Register 10 (CPU 2 PMU Component)</spirit:description>
          <spirit:addressOffset>0x028</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00230003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY11</spirit:name>
          <spirit:description>ROM Table Entry Register 11 (CPU 2 ETM Component)</spirit:description>
          <spirit:addressOffset>0x02c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00240003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY12</spirit:name>
          <spirit:description>ROM Table Entry Register 12 (CPU 3 Debug Component)</spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00310003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY13</spirit:name>
          <spirit:description>ROM Table Entry Register 13 (CPU 3 CTI Component)</spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00320003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY14</spirit:name>
          <spirit:description>ROM Table Entry Register 14 (CPU 3 PMU Component)</spirit:description>
          <spirit:addressOffset>0x038</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00330003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY15</spirit:name>
          <spirit:description>ROM Table Entry Register 15 (CPU 3 ETM Component)</spirit:description>
          <spirit:addressOffset>0x03c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00340003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY2</spirit:name>
          <spirit:description>ROM Table Entry Register 2 (CPU 0 PMU Component)</spirit:description>
          <spirit:addressOffset>0x008</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00030003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY3</spirit:name>
          <spirit:description>ROM Table Entry Register 3 (CPU 0 ETM Component)</spirit:description>
          <spirit:addressOffset>0x00c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00040003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY4</spirit:name>
          <spirit:description>ROM Table Entry Register 4 (CPU 1 Debug Component)</spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00110003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY5</spirit:name>
          <spirit:description>ROM Table Entry Register 5 (CPU 1 CTI Component)</spirit:description>
          <spirit:addressOffset>0x014</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00120003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY6</spirit:name>
          <spirit:description>ROM Table Entry Register 6 (CPU 1 PMU Component)</spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00130003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY7</spirit:name>
          <spirit:description>ROM Table Entry Register 7 (CPU 1 ETM Component)</spirit:description>
          <spirit:addressOffset>0x01c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00140003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY8</spirit:name>
          <spirit:description>ROM Table Entry Register 8 (CPU 2 Debug Component)</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00210003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ROMENTRY9</spirit:name>
          <spirit:description>ROM Table Entry Register 9 (CPU 2 CTI Component)</spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00220003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ROM_COMPONID0_VAL</spirit:name>
          <spirit:description>ROM Component ID 0</spirit:description>
          <spirit:addressOffset>0xff0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROM_COMPONID1_VAL</spirit:name>
          <spirit:description>ROM Component ID 1</spirit:description>
          <spirit:addressOffset>0xff4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x10</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROM_COMPONID2_VAL</spirit:name>
          <spirit:description>ROM Component ID 2</spirit:description>
          <spirit:addressOffset>0xff8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x05</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROM_COMPONID3_VAL</spirit:name>
          <spirit:description>ROM Component ID 3</spirit:description>
          <spirit:addressOffset>0xffc</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0xB1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROM_PERIPHID0_VAL</spirit:name>
          <spirit:description>ROM Peripheral ID 0</spirit:description>
          <spirit:addressOffset>0xfe0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0xA1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROM_PERIPHID1_VAL</spirit:name>
          <spirit:description>ROM Peripheral ID 1</spirit:description>
          <spirit:addressOffset>0xfe4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0xB4</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROM_PERIPHID2_VAL</spirit:name>
          <spirit:description>ROM Peripheral ID 2</spirit:description>
          <spirit:addressOffset>0xfe8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x04B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROM_PERIPHID3_VAL</spirit:name>
          <spirit:description>ROM Peripheral ID 3</spirit:description>
          <spirit:addressOffset>0xfec</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROM_PERIPHID4_VAL</spirit:name>
          <spirit:description>ROM Peripheral ID 4</spirit:description>
          <spirit:addressOffset>0xfd0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x04</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROM_PERIPHID5_VAL</spirit:name>
          <spirit:description>ROM Peripheral ID 5</spirit:description>
          <spirit:addressOffset>0xfd4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROM_PERIPHID6_VAL</spirit:name>
          <spirit:description>ROM Peripheral ID 6</spirit:description>
          <spirit:addressOffset>0xfd8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>ROM_PERIPHID7_VAL</spirit:name>
          <spirit:description>ROM Peripheral ID 7</spirit:description>
          <spirit:addressOffset>0xfdc</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_ETM_CPU1</spirit:name>
        <spirit:displayName>APBADDR_ETM_1</spirit:displayName>
        <spirit:description>APBADDR_ETM_1</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">1310720</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_ETM_CPU1>  -->
        <spirit:register>
          <spirit:name>TRCACATR0</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 0</spirit:description>
          <spirit:addressOffset>0x480</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR0_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR0_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR1</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 1</spirit:description>
          <spirit:addressOffset>0x488</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR1_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR1_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR2</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 2</spirit:description>
          <spirit:addressOffset>0x490</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR2_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR2_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR3</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 3</spirit:description>
          <spirit:addressOffset>0x498</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR3_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR3_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR4</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 4</spirit:description>
          <spirit:addressOffset>0x4a0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR4 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR4_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR4_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR5</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 5</spirit:description>
          <spirit:addressOffset>0x4a8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR5 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR5_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR5_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR6</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 6</spirit:description>
          <spirit:addressOffset>0x4b0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR6 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR6_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR6_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR7</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 7</spirit:description>
          <spirit:addressOffset>0x4B8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR7 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR7_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR7_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR0_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 0 (low word)</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR0_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR0_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 0 (high word)</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR0_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR1_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 1 (low word)</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR1_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR1_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 1 (high word)</spirit:description>
          <spirit:addressOffset>0x40c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR1_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR2_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 2 (low word)</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR2_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR2_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 2 (high word)</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR2_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR3_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 3 (low word)</spirit:description>
          <spirit:addressOffset>0x418</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR3_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR3_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 3 (high word)</spirit:description>
          <spirit:addressOffset>0x41c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR3_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR4_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 4 (low word)</spirit:description>
          <spirit:addressOffset>0x420</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR4_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR4_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 4 (high word)</spirit:description>
          <spirit:addressOffset>0x424</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR4_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR5_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 5 (low word)</spirit:description>
          <spirit:addressOffset>0x428</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR5_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR5_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 5 (high word)</spirit:description>
          <spirit:addressOffset>0x42c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR5_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR6_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 6 (low word)</spirit:description>
          <spirit:addressOffset>0x430</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR6_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR6_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 6 (high word)</spirit:description>
          <spirit:addressOffset>0x434</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR6_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR7_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 7 (low word)</spirit:description>
          <spirit:addressOffset>0x438</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR7_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR7_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 7 (high word)</spirit:description>
          <spirit:addressOffset>0x43c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR7_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCAUTHSTATUS</spirit:name>
          <spirit:description>Authentication Status Register </spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000088</spirit:value>
            <spirit:mask>0xFFFFFFBB</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCAUTHSTATUS -->
          <spirit:field>
            <spirit:name>RES0_TRCAUTHSTATUS_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNID</spirit:name>
            <spirit:displayName>SNID</spirit:displayName>
            <spirit:description>Indicates whether the system enables the trace unit to support Secure non-invasive debug:
      00
      
      The trace unit does not implement support for Secure non-invasive debug.
      
      
    
      01
      
      Reserved.
      
      
    
      10
      
      Secure non-invasive debug is disabled.
      
      
    
      11
      
      Secure non-invasive debug is enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SID</spirit:name>
            <spirit:displayName>SID</spirit:displayName>
            <spirit:description>Indicates whether the trace unit supports Secure invasive debug:
      00
      
      The trace unit does not support Secure invasive debug.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>Indicates whether the system enables the trace unit to support Non-secure non-invasive debug:
      00
      
      The trace unit does not implement support for Non-secure non-invasive debug.
      
      
    
      01
      
      Reserved.
      
      
    
      10
      
      Non-secure non-invasive debug is disabled.
      
      
    
      11
      
      Non-secure non-invasive debug is enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSID</spirit:name>
            <spirit:displayName>NSID</spirit:displayName>
            <spirit:description>Indicates whether the trace unit supports Non-secure invasive debug:
      00
      
      The trace unit does not support Non-secure invasive debug.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCAUXCTLR</spirit:name>
          <spirit:description>Auxiliary Control Register </spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCAUXCTLR -->
          <spirit:field>
            <spirit:name>AFREADY</spirit:name>
            <spirit:displayName>Always respond to AFREADY immediately</spirit:displayName>
            <spirit:description>Always respond to AFREADY immediately. Does not have any interaction with FIFO draining even in WFI state.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IDLEACK</spirit:name>
            <spirit:displayName>Force idle-drain acknowledge</spirit:displayName>
            <spirit:description>Force idle-drain acknowledge high CPU does not wait for trace to drain before entering WFX state. When this bit is set to 1 trace unit behavior deviates from architecturally-specified behavior.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OVFLW</spirit:name>
            <spirit:displayName>Overflow if synchronization is not completed</spirit:displayName>
            <spirit:description>Force an overflow if synchronization is not completed when second synchronization becomes due. When this bit is set to 1 the trace unit behavior deviates from architecturally-specified behavior.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SYNCDELAY</spirit:name>
            <spirit:displayName>Delay periodic synchronization</spirit:displayName>
            <spirit:description>Delay periodic synchronization if FIFO is more than half-full.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TSNODELAY</spirit:name>
            <spirit:displayName>Do not delay timestamp insertion</spirit:displayName>
            <spirit:description>Do not delay timestamp insertion based on FIFO depth.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AUTHNOFLUSH</spirit:name>
            <spirit:displayName>De-assertion of authentication inputs</spirit:displayName>
            <spirit:description>Do not flush trace on de-assertion of authentication inputs. When this bit is set to 1 the trace unit behavior deviates from architecturally-specified behavior.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCAUXCTLR_6_6</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COREIFEN</spirit:name>
            <spirit:displayName>Core interface enabled</spirit:displayName>
            <spirit:description>Keep core interface enabled regardless of trace enable register state</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCAUXCTLR_31_8</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCBBCTLR</spirit:name>
          <spirit:description>Branch Broadcast Control Register </spirit:description>
          <spirit:addressOffset>0x03C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCBBCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCBBCTLR_31_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>23</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MODE</spirit:name>
            <spirit:displayName>MODE</spirit:displayName>
            <spirit:description>Mode bit:
      0
      
      Exclude mode. Branch broadcasting is not enabled in the address range that RANGE defines. If RANGE==0 then branch broadcasting is enabled for the entire memory map.
      
      
    
      1
      
      Include mode. Branch broadcasting is enabled in the address range that RANGE defines. If RANGE==0 then the branch broadcasting behavior is UNPREDICTABLE.
      
      
    </spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RANGE</spirit:name>
            <spirit:displayName>RANGE</spirit:displayName>
            <spirit:description>Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each bit represents an address range comparator pair, so bit[n] controls the selection of address range comparator pair n. If bit[n] is:
      0
      
      The address range that address range comparator pair n defines is not selected.
      
      
    
      1
      
      The address range that address range comparator pair n defines is selected.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCCCTLR</spirit:name>
          <spirit:description>Cycle Count Control Register </spirit:description>
          <spirit:addressOffset>0x038</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFF000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCCCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCCCCTLR_31_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>THRESHOLD</spirit:name>
            <spirit:displayName>THRESHOLD</spirit:displayName>
            <spirit:description>Sets the threshold value for instruction trace cycle counting.The minimum threshold value that can be programmed into THRESHOLD is given in TRCIDR3.CCITMIN.Writing a value of zero might cause UNPREDICTABLE behaviour.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDCCTLR0</spirit:name>
          <spirit:description>Context ID Comparator Control Register 0 </spirit:description>
          <spirit:addressOffset>0x680</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDCCTLR0 -->
          <spirit:field>
            <spirit:name>COMP_n</spirit:name>
            <spirit:displayName>COMP&lt;n&gt;</spirit:displayName>
            <spirit:description>Controls the mask value that the trace unit applies to TRCCIDCVRn. Each bit in this field corresponds to a byte in TRCCIDCVRn. When a bit is:
      0
      
      The trace unit includes the relevant byte in TRCCIDCVRn when it performs the Context ID comparison.
      
      
    
      1
      
      The trace unit ignores the relevant byte in TRCCIDCVRn when it performs the Context ID comparison.
      
      
    Supported only if TRCIDR4.NUMCIDC &gt; n, otherwise the field is RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDCVR0</spirit:name>
          <spirit:description>Context ID Comparator Value Register 0 </spirit:description>
          <spirit:addressOffset>0x600</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCCIDCVR0 -->
          <spirit:field>
            <spirit:name>VALUE</spirit:name>
            <spirit:displayName>VALUE</spirit:displayName>
            <spirit:description>Context ID value. The implemented width of this field is IMPLEMENTATION DEFINED and is set by TRCIDR2.CIDSIZE. Unimplemented bits are RAZ/WI.After a processor reset, the ETM architecture assumes that the Context ID is zero until the processor updates the Context ID.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR0</spirit:name>
          <spirit:description>Component Identification Register 0 </spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR1</spirit:name>
          <spirit:description>Component Identification Register 1 </spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, to indicate that the ETM is a debug component, with CoreSight architecture compliant management registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR2</spirit:name>
          <spirit:description>Component Identification Register 2 </spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR3</spirit:name>
          <spirit:description>Component Identification Register 3 </spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCLAIMCLR</spirit:name>
          <spirit:description>Claim Tag Clear Register </spirit:description>
          <spirit:addressOffset>0xFA4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCLAIMCLR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCCLAIMCLR_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLR</spirit:name>
            <spirit:displayName>CLR</spirit:displayName>
            <spirit:description>Clears bits in the claim tag and determines the current value of the claim tag.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCLAIMSET</spirit:name>
          <spirit:description>Claim Tag Set Register </spirit:description>
          <spirit:addressOffset>0xFA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000F</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCLAIMSET -->
          <spirit:field>
            <spirit:name>RESERVED_TRCCLAIMSET_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SET</spirit:name>
            <spirit:displayName>SET</spirit:displayName>
            <spirit:description>Sets bits in the claim tag and determines the number of claim tag bits implemented.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTCTLR0</spirit:name>
          <spirit:description>Counter Control Register 0 </spirit:description>
          <spirit:addressOffset>0x150</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTCTLR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTCTLR0_31_18</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTCHAIN_n</spirit:name>
            <spirit:displayName>CNTCHAIN&lt;n&gt;</spirit:displayName>
            <spirit:description>For TRCCNTCTLR3 and TRCCNTCTLR1, controls whether counter &lt;n&gt; decrements when a reload event occurs for counter &lt;n-1&gt;:
      0
      
      
      
      
    
      1
      
      
      
      
    For TRCCNTCTLR2 and TRCCNTCTLR0, this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDSELF_n</spirit:name>
            <spirit:displayName>RLDSELF&lt;n&gt;</spirit:displayName>
            <spirit:description>Controls whether a reload event occurs for counter &lt;n&gt;, when counter &lt;n&gt; reaches zero:
      0
      
      The trace unit does not generate a reload event.
      
      
    
      1
      
      The trace unit generates a reload event for counter &lt;n&gt;, provided that the event resource that CNTEVENT&lt;n&gt; specifies is active.
      
      
    </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDEVENT_n</spirit:name>
            <spirit:displayName>RLDEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes a reload event for counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTEVENT_n</spirit:name>
            <spirit:displayName>CNTEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes counter &lt;n&gt; to decrement.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTCTLR1</spirit:name>
          <spirit:description>Counter Control Register 1 </spirit:description>
          <spirit:addressOffset>0x154</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFD7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTCTLR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTCTLR1_31_18</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTCHAIN_n</spirit:name>
            <spirit:displayName>CNTCHAIN&lt;n&gt;</spirit:displayName>
            <spirit:description>For TRCCNTCTLR3 and TRCCNTCTLR1, controls whether counter &lt;n&gt; decrements when a reload event occurs for counter &lt;n-1&gt;:
      0
      
      
      
      
    
      1
      
      
      
      
    For TRCCNTCTLR2 and TRCCNTCTLR0, this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDSELF_n</spirit:name>
            <spirit:displayName>RLDSELF&lt;n&gt;</spirit:displayName>
            <spirit:description>Controls whether a reload event occurs for counter &lt;n&gt;, when counter &lt;n&gt; reaches zero:
      0
      
      The trace unit does not generate a reload event.
      
      
    
      1
      
      The trace unit generates a reload event for counter &lt;n&gt;, provided that the event resource that CNTEVENT&lt;n&gt; specifies is active.
      
      
    </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDEVENT_n</spirit:name>
            <spirit:displayName>RLDEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes a reload event for counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTEVENT_n</spirit:name>
            <spirit:displayName>CNTEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes counter &lt;n&gt; to decrement.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTRLDVR0</spirit:name>
          <spirit:description>Counter Reload Value Registers 0</spirit:description>
          <spirit:addressOffset>0x140</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTRLDVR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTRLDVR0_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the reload value for counter &lt;n&gt;. When a reload event occurs for counter &lt;n&gt; then the trace unit copies the VALUE&lt;n&gt; field into counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTRLDVR1</spirit:name>
          <spirit:description>Counter Reload Value Registers 1</spirit:description>
          <spirit:addressOffset>0x144</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTRLDVR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTRLDVR1_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the reload value for counter &lt;n&gt;. When a reload event occurs for counter &lt;n&gt; then the trace unit copies the VALUE&lt;n&gt; field into counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTVR0</spirit:name>
          <spirit:description>Counter Value Registers 0</spirit:description>
          <spirit:addressOffset>0x160</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTVR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTVR0_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the count value of counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTVR1</spirit:name>
          <spirit:description>Counter Value Registers 1</spirit:description>
          <spirit:addressOffset>0x164</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTVR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTVR1_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the count value of counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCONFIGR</spirit:name>
          <spirit:description>Trace Configuration Register </spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000001</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCONFIGR -->
          <spirit:field>
            <spirit:name>RES0_TRCCONFIGR_31_18</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DV</spirit:name>
            <spirit:displayName>DV</spirit:displayName>
            <spirit:description>Data value tracing bit:
      0
      
      Data value tracing is disabled.
      
      
    
      1
      
      Data value tracing is enabled when INSTP0 is not 0b00.
      
      
    TRCIDR0.TRCDATA indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DA</spirit:name>
            <spirit:displayName>DA</spirit:displayName>
            <spirit:description>Data address tracing bit:
      0
      
      Data address tracing is disabled.
      
      
    
      1
      
      Data address tracing is enabled when INSTP0 is not 0b00.
      
      
    TRCIDR0.TRCDATA indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCCONFIGR_15_15</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>QE</spirit:name>
            <spirit:displayName>QE</spirit:displayName>
            <spirit:description>Q element enable field:
      00
      
      Q elements are disabled.
      
      
    
      01
      
      Q elements with instruction counts are enabled. Q elements without instruction counts are disabled.
      
      
    
      11
      
      Q elements with and without instruction counts are enabled.
      
      
    The value 0b10 is reserved.TRCIDR0.QSUPP indicates which values of this field are implemented.TRCCONFIGR.QE must be set to 0b00 if any of the following are true:TRCCONFIGR.INSTP0 is not 0b00.TRCCONFIGR.COND is not 0b000.TRCCONFIGR.BB is not 0.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RS</spirit:name>
            <spirit:displayName>RS</spirit:displayName>
            <spirit:description>Return stack enable bit.
      0
      
      Return stack is disabled.
      
      
    
      1
      
      Return stack is enabled.
      
      
    TRCIDR0.RETSTACK indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TS</spirit:name>
            <spirit:displayName>TS</spirit:displayName>
            <spirit:description>Global timestamp tracing bit:
      0
      
      Global timestamp tracing is disabled.
      
      
    
      1
      
      Global timestamp tracing is enabled. TRCTSCTLR controls the insertion of timestamps in the trace.
      
      
    TRCIDR0.TSSIZE indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COND</spirit:name>
            <spirit:displayName>COND</spirit:displayName>
            <spirit:description>Conditional instruction tracing bit. The permitted values are:
      000
      
      Conditional instruction tracing is disabled.
      
      
    
      001
      
      Conditional load instructions are traced.
      
      
    
      010
      
      Conditional store instructions are traced.
      
      
    
      011
      
      Conditional load and store instructions are traced.
      
      
    
      111
      
      All conditional instructions are traced.
      
      
    All other values are reserved.TRCIDR0.TRCCOND indicates whether this field is supported. If it is not supported then this field is RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VMID</spirit:name>
            <spirit:displayName>VMID</spirit:displayName>
            <spirit:description>VMID tracing bit:
      0
      
      VMID tracing is disabled.
      
      
    
      1
      
      VMID tracing is enabled.
      
      
    TRCIDR2.VMIDSIZE indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CID</spirit:name>
            <spirit:displayName>CID</spirit:displayName>
            <spirit:description>Context ID tracing bit:
      0
      
      Context ID tracing is disabled.
      
      
    
      1
      
      Context ID tracing is enabled.
      
      
    TRCIDR2.CIDSIZE indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCCONFIGR_5_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCI</spirit:name>
            <spirit:displayName>CCI</spirit:displayName>
            <spirit:description>Cycle counting instruction trace bit:
      0
      
      Cycle counting in the instruction trace is disabled.
      
      
    
      1
      
      Cycle counting in the instruction trace is enabled. TRCCCCTLR controls the threshold value for cycle counting.
      
      
    TRCIDR0.TRCCCI indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BB</spirit:name>
            <spirit:displayName>BB</spirit:displayName>
            <spirit:description>Branch broadcast mode bit:
      0
      
      Branch broadcast mode is disabled.
      
      
    
      1
      
      Branch broadcast mode is enabled. TRCBBCTLR controls which regions of memory are enabled to use branch broadcasting.
      
      
    TRCIDR0.TRCBB indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INSTP0</spirit:name>
            <spirit:displayName>INSTP0</spirit:displayName>
            <spirit:description>Instruction P0 bit. This field controls whether load and store instructions are traced as P0 instructions:
      00
      
      Do not trace load and store instructions as P0 instructions.
      
      
    
      01
      
      Trace load instructions as P0 instructions.
      
      
    
      10
      
      Trace store instructions as P0 instructions.
      
      
    
      11
      
      Trace load and store instructions as P0 instructions.
      
      
    TRCIDR0.INSTP0 indicates whether this field is supported. If it is not supported then this field is RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES1_TRCCONFIGR_0_0</spirit:name>
            <spirit:displayName>1</spirit:displayName>
            <spirit:description>Reserved, RES1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVAFF0</spirit:name>
          <spirit:description>Device Affinity Register 0 </spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000001</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVAFF0 -->
          <spirit:field>
            <spirit:name>MPIDR_EL1_31:0</spirit:name>
            <spirit:displayName>MPIDR_EL1[31:0]</spirit:displayName>
            <spirit:description>Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVAFF1</spirit:name>
          <spirit:description>Device Affinity Register 1 </spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVAFF1 -->
          <spirit:field>
            <spirit:name>MPIDR_EL1_63:32</spirit:name>
            <spirit:displayName>MPIDR_EL1[63:32]</spirit:displayName>
            <spirit:description>Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVARCH</spirit:name>
          <spirit:description>Device Architecture Register </spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47704A13</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For trace, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is RAO.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For trace, the revision defined by ETMv4 is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For trace, bits [15:12] are the architecture version, 0x4; bits [11:0] are the architecture part number, 0xA13.This corresponds to trace architecture version ETMv4.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVID</spirit:name>
          <spirit:description>Device ID Register </spirit:description>
          <spirit:addressOffset>0xFC8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCDEVID -->
          <spirit:field>
            <spirit:name>DEVID</spirit:name>
            <spirit:displayName>DEVID</spirit:displayName>
            <spirit:description>Indicates the capabilities of the trace unit. The implemented width of this field and its bit assignments are IMPLEMENTATION DEFINED. Unimplemented bits are RAZ/WI.If a component is configurable then ARM recommends that this field can also indicate which configuration options are implemented that differ from the standard configuration.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVTYPE</spirit:name>
          <spirit:description>Device Type Register </spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000013</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_TRCDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Returns 0x1, to indicate that the ETM generates processor trace.All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAIN</spirit:name>
            <spirit:displayName>MAIN</spirit:displayName>
            <spirit:description>Returns 0x3, to indicate that the ETM is a trace source.All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCEVENTCTL0R</spirit:name>
          <spirit:description>Event Control 0 Register </spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0x70707070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCEVENTCTL0R -->
          <spirit:field>
            <spirit:name>TYPE3</spirit:name>
            <spirit:displayName>TYPE3</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 3</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_30_28</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL3</spirit:name>
            <spirit:displayName>SEL3</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE3</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE2</spirit:name>
            <spirit:displayName>TYPE2</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 2</spirit:description>
            <spirit:bitOffset>23</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_22_20</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL2</spirit:name>
            <spirit:displayName>SEL2</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE2</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE1</spirit:name>
            <spirit:displayName>TYPE1</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 1</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_14_12</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL1</spirit:name>
            <spirit:displayName>SEL1</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE1</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE0</spirit:name>
            <spirit:displayName>TYPE0</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 0</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_6_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL0</spirit:name>
            <spirit:displayName>SEL0</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCEVENTCTL1R</spirit:name>
          <spirit:description>Event Control 1 Register </spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFE7F0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCEVENTCTL1R -->
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL1R_31_13</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>19</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LPOVERRIDE</spirit:name>
            <spirit:displayName>LPOVERRIDE</spirit:displayName>
            <spirit:description>Low power state behavior override</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATB</spirit:name>
            <spirit:displayName>ATB</spirit:displayName>
            <spirit:description>ATB trigger enable</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL1R_10_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EN</spirit:name>
            <spirit:displayName>EN</spirit:displayName>
            <spirit:description>One bit per event to enable generation of an event element in the instruction trace stream when the selected event occurs</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCEXTINSELR</spirit:name>
          <spirit:description>External Input Select Register </spirit:description>
          <spirit:addressOffset>0x120</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0x80808080</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCEXTINSELR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_31_29</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL3</spirit:name>
            <spirit:displayName>SEL3</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 3.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_23_21</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL2</spirit:name>
            <spirit:displayName>SEL2</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 2</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_15_13</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL1</spirit:name>
            <spirit:displayName>SEL1</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 1</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_7_5</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL0</spirit:name>
            <spirit:displayName>SEL0</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR0</spirit:name>
          <spirit:description>ID Register 0 </spirit:description>
          <spirit:addressOffset>0x1E0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x28000EA1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_31_30</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COMMOPT</spirit:name>
            <spirit:displayName>COMMOPT</spirit:displayName>
            <spirit:description>Conditional instruction tracing support bit. Indicates if the trace unit supports conditional instruction tracing:
      0
      
      Conditional instruction tracing is not supported.
      
      
    
      1
      
      Conditional instruction tracing is supported, so TRCCONFIGR.COND is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TSSIZE</spirit:name>
            <spirit:displayName>TSSIZE</spirit:displayName>
            <spirit:description>Global timestamp size field. The permitted values are:
      00000
      
      Global timestamping is not implemented.
      
      
    
      00110
      
      Implementation supports a maximum global timestamp of 48bits.
      
      
    
      01000
      
      Implementation supports a maximum global timestamp of 64bits.
      
      
    All other values are reserved.When global timestamping is implemented then TRCCONFIGR.TS and TRCTSCTLR are supported.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_23_17</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>QSUPP</spirit:name>
            <spirit:displayName>QSUPP</spirit:displayName>
            <spirit:description>Q element support field. The permitted values are:
      00
      
      Q element support is not implemented. TRCCONFIGR.QE is RES0.
      
      
    
      01
      
      Q element support is implemented, and only supports Q elements with instruction counts. TRCCONFIGR.QE can only take the values 0b00 or 0b01.
      
      
    
      10
      
      Q element support is implemented, and only supports Q elements without instruction counts. TRCCONFIGR.QE can only take the values 0b00 or 0b11.
      
      
    
      11
      
      Q element support is implemented, and supports both Q elements with instruction counts and Q elements without instruction counts. TRCCONFIGR.QE is fully implemented.
      
      
    </spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>QFILT</spirit:name>
            <spirit:displayName>QFILT</spirit:displayName>
            <spirit:description>Q element filtering support field. The permitted values are:
      0
      
      Q element filtering is not implemented.
      
      
    
      1
      
      Q element filtering is implemented. TRCQCTLR is implemented.
      
      
    When QSUPP==0b00, this field is RES0.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONDTYPE</spirit:name>
            <spirit:displayName>CONDTYPE</spirit:displayName>
            <spirit:description>Conditional tracing field. The permitted values are:
      00
      
      The trace unit indicates only if a conditional instruction is a pass or fail.
      
      
    
      01
      
      The trace unit provides the Current Program Status Register (CPSR) status, for a conditional instruction.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMEVENT</spirit:name>
            <spirit:displayName>NUMEVENT</spirit:displayName>
            <spirit:description>Number of events field. Indicates how many events the trace unit supports:
      00
      
      The trace unit supports 1 event.
      
      
    
      01
      
      The trace unit supports 2 events.
      
      
    
      10
      
      The trace unit supports 3 events.
      
      
    
      11
      
      The trace unit supports 4 events.
      
      
    This field controls how many fields are supported in TRCEVENTCTL0R, and indicates the size of TRCEVENTCTL1R.INSTEN.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RETSTACK</spirit:name>
            <spirit:displayName>RETSTACK</spirit:displayName>
            <spirit:description>Return stack bit. Indicates if the implementation supports a return stack:
      0
      
      Return stack is not implemented.
      
      
    
      1
      
      Return stack is implemented, so TRCCONFIGR.RS is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_8_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCCCI</spirit:name>
            <spirit:displayName>TRCCCI</spirit:displayName>
            <spirit:description>Cycle counting instruction bit. Indicates if the trace unit supports cycle counting for instructions:
      0
      
      Cycle counting in the instruction trace is not implemented.
      
      
    
      1
      
      Cycle counting in the instruction trace is implemented, so TRCCONFIGR.CCI and TRCCCCTLR are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCCOND</spirit:name>
            <spirit:displayName>TRCCOND</spirit:displayName>
            <spirit:description>Conditional instruction tracing support bit. Indicates if the trace unit supports conditional instruction tracing:
      0
      
      Conditional instruction tracing is not supported.
      
      
    
      1
      
      Conditional instruction tracing is supported, so TRCCONFIGR.COND is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCBB</spirit:name>
            <spirit:displayName>TRCBB</spirit:displayName>
            <spirit:description>Branch broadcast tracing support bit. Indicates if the trace unit supports branch broadcast tracing:
      0
      
      Branch broadcast tracing is not supported.
      
      
    
      1
      
      Branch broadcast tracing is supported, so TRCCONFIGR.BB and TRCBBCTLR are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCDATA</spirit:name>
            <spirit:displayName>TRCDATA</spirit:displayName>
            <spirit:description>Conditional tracing field. The permitted values are:
      00
      
      Data tracing is not supported.
      
      
    
      11
      
      Tracing of data addresses and data values is supported, so TRCCONFIGR.DA, TRCCONFIGR.DV, TRCSTALLCTLR.DATADISCARD, TRCSTALLCTLR.INSTPRIORITY, TRCSTALLCTLR.DSTALL, and TRCEVENTCTL1R.DATAEN are supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INSTP0</spirit:name>
            <spirit:displayName>INSTP0</spirit:displayName>
            <spirit:description>P0 tracing support field. The permitted values are:
      00
      
      Tracing of load and store instructions as P0 elements is not supported.
      
      
    
      11
      
      Tracing of load and store instructions as P0 elements is supported, so TRCCONFIGR.INSTP0 is supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_0_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR1</spirit:name>
          <spirit:description>ID Register 1 </spirit:description>
          <spirit:addressOffset>0x1E4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x4100F404</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR1 -->
          <spirit:field>
            <spirit:name>DESIGNER</spirit:name>
            <spirit:displayName>DESIGNER</spirit:displayName>
            <spirit:description>Indicates which company designed the trace unit. The permitted values are:
      01000001
      
      ARM Limited.
      
      
    
      01000100
      
      Digital Equipment Corporation.
      
      
    
      01001101
      
      Motorola, Freescale Semiconductor Inc.
      
      
    
      01010001
      
      QUALCOMM Inc.
      
      
    
      01010110
      
      Marvell Semiconductor Inc.
      
      
    
      01101001
      
      Intel Corporation.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR1_23_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES1_TRCIDR1_15_12</spirit:name>
            <spirit:displayName>1</spirit:displayName>
            <spirit:description>Reserved, RES1.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCARCHMAJ</spirit:name>
            <spirit:displayName>TRCARCHMAJ</spirit:displayName>
            <spirit:description>Indicates the major version of the ETM architecture. The permitted value is:
      100
      
      ETMv4.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCARCHMIN</spirit:name>
            <spirit:displayName>TRCARCHMIN</spirit:displayName>
            <spirit:description>Indicates the minor version of the ETM architecture. The permitted value is:
      0
      
      ETMv4 minor version 0.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Returns an IMPLEMENTATION DEFINED value that identifies the revision of the trace registers and the OS Save and Restore registers.ARM recommends:That the initial implementation sets REVISION==0x0 and the field then increments for any subsequent implementations. However, it is acceptable to omit some values or use another scheme to identify the revision number.That TRCPIDR2.REVISION==TRCIDR1.REVISION. However, in situations where it is difficult to align these fields, such as with a metal layer fix, then it is acceptable to change the REVISION fields independently.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR10</spirit:name>
          <spirit:description>ID Register 10 </spirit:description>
          <spirit:addressOffset>0x188</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR10 -->
          <spirit:field>
            <spirit:name>NUMP1KEY</spirit:name>
            <spirit:displayName>NUMP1KEY</spirit:displayName>
            <spirit:description>Indicates the number of P1 right-hand keys that the trace unit can use. The number includes normal and special keys.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR11</spirit:name>
          <spirit:description>ID Register 11 </spirit:description>
          <spirit:addressOffset>0x18C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR11 -->
          <spirit:field>
            <spirit:name>NUMP1SPC</spirit:name>
            <spirit:displayName>NUMP1SPC</spirit:displayName>
            <spirit:description>Indicates the number of special P1 right-hand keys that the trace unit can use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR12</spirit:name>
          <spirit:description>ID Register 12 </spirit:description>
          <spirit:addressOffset>0x190</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR12 -->
          <spirit:field>
            <spirit:name>NUMCONDKEY</spirit:name>
            <spirit:displayName>NUMCONDKEY</spirit:displayName>
            <spirit:description>Indicates the number of conditional instruction right-hand keys that the trace unit can use. The number includes normal and special keys.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR13</spirit:name>
          <spirit:description>ID Register 13 </spirit:description>
          <spirit:addressOffset>0x194</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR13 -->
          <spirit:field>
            <spirit:name>NUMCONDSPC</spirit:name>
            <spirit:displayName>NUMCONDSPC</spirit:displayName>
            <spirit:description>Indicates the number of special conditional instruction right-hand keys that the trace unit can use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR2</spirit:name>
          <spirit:description>ID Register 2 </spirit:description>
          <spirit:addressOffset>0x1E8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000488</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCIDR2_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCSIZE</spirit:name>
            <spirit:displayName>CCSIZE</spirit:displayName>
            <spirit:description>Indicates the size of the cycle counter in bits minus 12.
      0000
      
      The cycle counter is 12 bits in length.
      
      
    
      0001
      
      The cycle counter is 13 bits in length.
      
      
    and so on up to 0b1000, indicating the cycle counter is 20 bits in length.All other values are reserved.If cycle counting is not implemented, as indicated by TRCIDR0.TRCCCI, this field is 0b0000.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DVSIZE</spirit:name>
            <spirit:displayName>DVSIZE</spirit:displayName>
            <spirit:description>Indicates the data value size in bytes. The permitted values are:
      00000
      
      Data value tracing is not supported. Therefore, an implementation must also set TRCIDR0.TRCDATA==0b00.
      
      
    
      00100
      
      Maximum of 32-bit data value size.
      
      
    
      01000
      
      Maximum of 64-bit data value size.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DASIZE</spirit:name>
            <spirit:displayName>DASIZE</spirit:displayName>
            <spirit:description>Indicates the data address size in bytes. The permitted values are:
      00000
      
      Data address tracing is not supported. Therefore, an implementation must also set TRCIDR0.TRCDATA==0b00.
      
      
    
      00100
      
      Maximum of 32-bit data address size.
      
      
    
      01000
      
      Maximum of 64-bit data address size.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VMIDSIZE</spirit:name>
            <spirit:displayName>VMIDSIZE</spirit:displayName>
            <spirit:description>Indicates the VMID size. The permitted values are:
      00000
      
      VMID tracing is not supported.
      
      
    
      00001
      
      Maximum of 8-bit VMID size, so TRCCONFIGR.VMID is supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CIDSIZE</spirit:name>
            <spirit:displayName>CIDSIZE</spirit:displayName>
            <spirit:description>Indicates the Context ID size. The permitted values are:
      00000
      
      Context ID tracing is not supported.
      
      
    
      00100
      
      Maximum of 32-bit Context ID size, so TRCCONFIGR.CID is supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IASIZE</spirit:name>
            <spirit:displayName>IASIZE</spirit:displayName>
            <spirit:description>Indicates the instruction address size. The permitted values are:
      00100
      
      Maximum of 32-bit address size.
      
      
    
      01000
      
      Maximum of 64-bit address size.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR3</spirit:name>
          <spirit:description>ID Register 3 </spirit:description>
          <spirit:addressOffset>0x1EC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0D7B0004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR3 -->
          <spirit:field>
            <spirit:name>NOOVERFLOW</spirit:name>
            <spirit:displayName>NOOVERFLOW</spirit:displayName>
            <spirit:description>Indicates if TRCSTALLCTLR.NOOVERFLOW is supported:
      0
      
      TRCSTALLCTLR.NOOVERFLOW is not supported, or STALLCTL==0.
      
      
    
      1
      
      TRCSTALLCTLR.NOOVERFLOW is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMPROC</spirit:name>
            <spirit:displayName>NUMPROC</spirit:displayName>
            <spirit:description>Indicates the number of processors available for tracing. The possible values are:
      000
      
      The trace unit can trace one processor.
      
      
    
      001
      
      The trace unit can trace two processors.
      
      
    
      010
      
      The trace unit can trace three processors.
      
      
    and so on up to 0b111, which indicates the trace unit can trace eight processors.This field sets the maximum value of TRCPROCSELR.PROCSEL.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SYSSTALL</spirit:name>
            <spirit:displayName>SYSSTALL</spirit:displayName>
            <spirit:description>Indicates if the implementation can support stall control:
      0
      
      The system does not support stall control of the processor.
      
      
    
      1
      
      The system can support stall control of the processor.
      
      
    The system supports stalling of the processor only when SYSSTALL==1 and STALLCTL==1.</spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STALLCTL</spirit:name>
            <spirit:displayName>STALLCTL</spirit:displayName>
            <spirit:description>Indicates if TRCSTALLCTLR is supported:
      0
      
      TRCSTALLCTLR is not supported.
      
      
    
      1
      
      TRCSTALLCTLR is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SYNCPR</spirit:name>
            <spirit:displayName>SYNCPR</spirit:displayName>
            <spirit:description>Indicates if an implementation has a fixed synchronization period:
      0
      
      TRCSYNCPR is read-write so software can change the synchronization period.
      
      
    
      1
      
      TRCSYNCPR is read-only so the synchronization period is fixed.
      
      
    </spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCERR</spirit:name>
            <spirit:displayName>TRCERR</spirit:displayName>
            <spirit:description>Indicates if TRCVICTLR.TRCERR is supported:
      0
      
      TRCVICTLR.TRCERR is not supported
      
      
    
      1
      
      TRCVICTLR.TRCERR is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit indicates whether instruction tracing is supported for the corresponding exception level:
      0
      
      In Non-secure state, exception level n is not supported so the corresponding bits in TRCACATRn.EXLEVEL_NS and TRCVICTLR.EXLEVEL_NS are not supported.
      
      
    
      1
      
      In Non-secure state, exception level n is supported so the corresponding bits in TRCACATRn.EXLEVEL_NS and TRCVICTLR.EXLEVEL_NS are supported.
      
      
    The exception levels are:Bit[20]Exception level 0.Bit[21]Exception level 1.Bit[22]Exception level 2.Bit[23]SBZ. EXLEVEL_NS[3] is never implemented.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit indicates whether instruction tracing is supported for the corresponding exception level:
      0
      
      In Secure state, exception level n is not supported so the corresponding bits in TRCACATRn.EXLEVEL_S and TRCVICTLR.EXLEVEL_S are not supported.
      
      
    
      1
      
      In Secure state, exception level n is supported so the corresponding bits in TRCACATRn.EXLEVEL_S and TRCVICTLR.EXLEVEL_S are supported.
      
      
    The exception levels are:Bit[16]Exception level 0.Bit[17]Exception level 1.Bit[18]SBZ. EXLEVEL_S[2] is never implemented.Bit[19]Exception level 3.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR3_15_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCITMIN</spirit:name>
            <spirit:displayName>CCITMIN</spirit:displayName>
            <spirit:description>Indicates the minimum value that can be programmed in TRCCCCTLR.THRESHOLD.When cycle counting in the instruction trace is supported, that is TRCIDR0.TRCCCI==1, then the minimum value of this field is 0x001, otherwise it is 0x000.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR4</spirit:name>
          <spirit:description>ID Register 4 </spirit:description>
          <spirit:addressOffset>0x1F0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x11170004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR4 -->
          <spirit:field>
            <spirit:name>NUMVMIDC</spirit:name>
            <spirit:displayName>NUMVMIDC</spirit:displayName>
            <spirit:description>Indicates the number of VMID comparators that are available for tracing. The permitted values are:
      0000
      
      No VMID comparators are available.
      
      
    
      0001
      
      The implementation has one VMID comparator.
      
      
    
      0010
      
      The implementation has two VMID comparators.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight VMID comparators.All other values are reserved.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMCIDC</spirit:name>
            <spirit:displayName>NUMCIDC</spirit:displayName>
            <spirit:description>Indicates the number of Context ID comparators that are available for tracing. The permitted values are:
      0000
      
      No Context ID comparators are available.
      
      
    
      0001
      
      The implementation has one Context ID comparator.
      
      
    
      0010
      
      The implementation has two Context ID comparators.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight Context ID comparators.All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMSSCC</spirit:name>
            <spirit:displayName>NUMSSCC</spirit:displayName>
            <spirit:description>Indicates the number of single-shot comparator controls that are available for tracing. The permitted values are:
      0000
      
      No single-shot comparator controls are available.
      
      
    
      0001
      
      The implementation has one single-shot comparator control.
      
      
    
      0010
      
      The implementation has two single-shot comparator controls.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight single-shot comparator controls.All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMRSPAIR</spirit:name>
            <spirit:displayName>NUMRSPAIR</spirit:displayName>
            <spirit:description>Indicates the number of resource selection pairs that are available for tracing. The permitted values are:
      0000
      
      The implementation has one resource selection pair.
      
      
    
      0001
      
      The implementation has two resource selection pairs.
      
      
    
      0010
      
      The implementation has three resource selection pairs.
      
      
    and so on up to 0b1111, which indicates that the implementation has 16 resource selection pairs.Implementations always have at least one resource selection pair so that they can support the FALSE and TRUE resource selectors, 0 and 1.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMPC</spirit:name>
            <spirit:displayName>NUMPC</spirit:displayName>
            <spirit:description>Indicates the number of processor comparator inputs that are available for tracing. The permitted values are:
      0000
      
      No processor comparator inputs are available.
      
      
    
      0001
      
      The implementation has one processor comparator input.
      
      
    
      0010
      
      The implementation has two processor comparator inputs.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight processor comparator inputs.All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR4_11_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUPPDAC</spirit:name>
            <spirit:displayName>SUPPDAC</spirit:displayName>
            <spirit:description>Indicates if the implementation can support data address comparisons:
      0
      
      The implementation does not support data address comparisons.
      
      
    
      1
      
      The implementation can support data address comparisons
      
      
    </spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMDVC</spirit:name>
            <spirit:displayName>NUMDVC</spirit:displayName>
            <spirit:description>Indicates the number of data value comparators that are available for tracing. The permitted values are:
      0000
      
      No data value comparators are available.
      
      
    
      0001
      
      The implementation has one data value comparator.
      
      
    
      0010
      
      The implementation has two data value comparators.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight data value comparators.All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMACPAIRS</spirit:name>
            <spirit:displayName>NUMACPAIRS</spirit:displayName>
            <spirit:description>Indicates the number of address comparator pairs that are available for tracing. The permitted values are:
      0000
      
      No address comparator pairs are available.
      
      
    
      0001
      
      The implementation has one address comparator pair.
      
      
    
      0010
      
      The implementation has two address comparator pairs.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight address comparator pairs.All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR5</spirit:name>
          <spirit:description>ID Register 5 </spirit:description>
          <spirit:addressOffset>0x1F4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x28C7081E</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR5 -->
          <spirit:field>
            <spirit:name>REDFUNCNTR</spirit:name>
            <spirit:displayName>REDFUNCNTR</spirit:displayName>
            <spirit:description>Indicates if the reduced function counter is implemented:
      0
      
      The reduced function counter is not supported.
      
      
    
      1
      
      Counter 0 is implemented as a reduced function counter.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMCNTR</spirit:name>
            <spirit:displayName>NUMCNTR</spirit:displayName>
            <spirit:description>Indicates the number of counters that are available for tracing. The permitted values are:
      000
      
      No counters are available.
      
      
    
      001
      
      The implementation has one counter.
      
      
    
      010
      
      The implementation has two counters.
      
      
    
      011
      
      The implementation has three counters.
      
      
    
      100
      
      The implementation has four counters.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMSEQSTATE</spirit:name>
            <spirit:displayName>NUMSEQSTATE</spirit:displayName>
            <spirit:description>Indicates the number of sequencer states that are implemented. The permitted values are:
      000
      
      No sequencer states are implemented.
      
      
    
      100
      
      The implementation has four sequencer states.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR5_24_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LPOVERRIDE</spirit:name>
            <spirit:displayName>LPOVERRIDE</spirit:displayName>
            <spirit:description>Indicates if the implementation can support low-power state override:
      0
      
      The implementation does not support low-power state override.
      
      
    
      1
      
      The implementation supports low-power state override, and the TRCEVENTCTL1R.LPOVERRIDE field is implemented.
      
      
    The trace unit must support low-power state override if it can enter a low-power mode where the resources and event trace generation are disabled.</spirit:description>
            <spirit:bitOffset>23</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATBTRIG</spirit:name>
            <spirit:displayName>ATBTRIG</spirit:displayName>
            <spirit:description>Indicates if the implementation can support ATB triggers:
      0
      
      The implementation does not support ATB triggers.
      
      
    
      1
      
      The implementation supports ATB triggers, and the TRCEVENTCTL1R.ATBTRIG field is implemented.
      
      
    </spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRACEIDSIZE</spirit:name>
            <spirit:displayName>TRACEIDSIZE</spirit:displayName>
            <spirit:description>Indicates the trace ID width. The permitted value is:
      111
      
      The implementation supports a 7-bit trace ID. This sets the width of the TRCTRACEIDR.TRACEID field.
      
      
    All other values are reserved.The CoreSight ATB requires a 7-bit trace ID width.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR5_15_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMEXTINSEL</spirit:name>
            <spirit:displayName>NUMEXTINSEL</spirit:displayName>
            <spirit:description>Indicates how many external input select resources are implemented. The permitted values are:
      000
      
      No external input select resources are available. If NUMEXTINSEL is zero, NUMEXTIN must also be zero.
      
      
    
      001
      
      The implementation has one external input select resource.
      
      
    
      010
      
      The implementation has two external input select resources.
      
      
    
      011
      
      The implementation has three external input select resources.
      
      
    
      100
      
      The implementation has four external input select resources.
      
      
    All other values are reserved.See TRCEXTINSELR for how to select an input select resource.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMEXTIN</spirit:name>
            <spirit:displayName>NUMEXTIN</spirit:displayName>
            <spirit:description>Indicates how many external inputs are implemented. The permitted values are:
      000000000
      
      No external inputs are available. If NUMEXTIN is zero, NUMEXTINSEL must also be zero.
      
      
    
      000000001
      
      The implementation has one external input.
      
      
    
      000000010
      
      The implementation has two external inputs.
      
      
    and so on up to 0b100000000, which indicates that the implementation has 256 external inputs.All other values &gt;0b100000000 are reserved.See TRCEXTINSELR for how to select an external input.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>9</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR8</spirit:name>
          <spirit:description>ID Register 8 </spirit:description>
          <spirit:addressOffset>0x180</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR8 -->
          <spirit:field>
            <spirit:name>MAXSPEC</spirit:name>
            <spirit:displayName>MAXSPEC</spirit:displayName>
            <spirit:description>Indicates the maximum speculation depth of the instruction trace stream. This is the maximum number of P0 elements in the trace stream that can be speculative at any time.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR9</spirit:name>
          <spirit:description>ID Register 9 </spirit:description>
          <spirit:addressOffset>0x184</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR9 -->
          <spirit:field>
            <spirit:name>NUMP0KEY</spirit:name>
            <spirit:displayName>NUMP0KEY</spirit:displayName>
            <spirit:description>Indicates the number of P0 right-hand keys that the trace unit can use. A value of 0 or 1 indicates one P0 key.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIMSPEC0</spirit:name>
          <spirit:description>Implementation Specific Register 0 </spirit:description>
          <spirit:addressOffset>0x1C0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCIMSPEC0 -->
          <spirit:field>
            <spirit:name>RES0_TRCIMSPEC0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EN</spirit:name>
            <spirit:displayName>EN</spirit:displayName>
            <spirit:description>If SUPPORT is not 0b0000, controls whether the IMPLEMENTATION DEFINED features are enabled. The permitted values are:
      0000
      
      The IMPLEMENTATION DEFINED features are not enabled. The trace unit must behave as if the IMPLEMENTATION DEFINED features are not supported.
      
      
    and any other value, which indicates that the trace unit behavior is IMPLEMENTATION DEFINED.If SUPPORT is 0b0000, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUPPORT</spirit:name>
            <spirit:displayName>SUPPORT</spirit:displayName>
            <spirit:description>Indicates whether the implementation supports IMPLEMENTATION DEFINED features. The permitted values are:
      0000
      
      No IMPLEMENTATION DEFINED features are supported. The EN field is RES0.
      
      
    and any other value, which indicates that IMPLEMENTATION DEFINED features are supported. Use of these values requires written permission from ARM.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITATBIDR</spirit:name>
          <spirit:description>Integration ATB Identification Register </spirit:description>
          <spirit:addressOffset>0xEE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCITATBIDR -->
          <spirit:field>
            <spirit:name>ID</spirit:name>
            <spirit:displayName>ID</spirit:displayName>
            <spirit:description>Drives the ATIDMn[6:0] output pins</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCITATBIDR_31_7</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>25</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITCTRL</spirit:name>
          <spirit:description>Integration Mode Control Register </spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCITCTRL -->
          <spirit:field>
            <spirit:name>RES0_TRCITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ITEN</spirit:name>
            <spirit:displayName>ITEN</spirit:displayName>
            <spirit:description>Integration mode enable bit:
      0
      
      The trace unit is not in integration mode.
      
      
    
      1
      
      The trace unit is in integration mode. This mode enables a debug agent to perform topology detection, and System-on-Chip (SoC) test software to perform integration testing.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITIATBINR</spirit:name>
          <spirit:description>Integration Instruction ATB In Register </spirit:description>
          <spirit:addressOffset>0xEF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCITIATBINR -->
          <spirit:field>
            <spirit:name>ATREADYM</spirit:name>
            <spirit:displayName>ATREADYM</spirit:displayName>
            <spirit:description>Returns the value of the ATREADYMn input pin</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AFVALIDM</spirit:name>
            <spirit:displayName>AFVALIDM</spirit:displayName>
            <spirit:description>Returns the value of the AFVALIDMn input pin</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCITIATBINR_31_2</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved. Read undefined.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITIATBOUTR</spirit:name>
          <spirit:description>Integration Instruction ATB Out Register </spirit:description>
          <spirit:addressOffset>0xEFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCITIATBOUTR -->
          <spirit:field>
            <spirit:name>ATVALID</spirit:name>
            <spirit:displayName>ATVALID</spirit:displayName>
            <spirit:description>Drives the ATVALIDMn output pin</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AFREADY</spirit:name>
            <spirit:displayName>AFREADY</spirit:displayName>
            <spirit:description>Drives the AFREADYMn output pin</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCITIATBOUTR_7_2</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved. Read undefined.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BYTES</spirit:name>
            <spirit:displayName>BYTES</spirit:displayName>
            <spirit:description>Drives the ATBYTESMn[1:0] output pins</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCITIATBOUTR_31_10</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved. Read undefined.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>22</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITIDATAR</spirit:name>
          <spirit:description>Integration Instruction ATB Data Register </spirit:description>
          <spirit:addressOffset>0xEEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCITIDATAR -->
          <spirit:field>
            <spirit:name>ATDATAM_0</spirit:name>
            <spirit:displayName>ATDATAM_0</spirit:displayName>
            <spirit:description>Drives the ATDATAM[0] output</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_7</spirit:name>
            <spirit:displayName>ATDATAM_7</spirit:displayName>
            <spirit:description>Drives the ATDATAM[7] output</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_15</spirit:name>
            <spirit:displayName>ATDATAM_15</spirit:displayName>
            <spirit:description>Drives the ATDATAM[15] output</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_23</spirit:name>
            <spirit:displayName>ATDATAM_23</spirit:displayName>
            <spirit:description>Drives the ATDATAM[23] output</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_31</spirit:name>
            <spirit:displayName>ATDATAM_31</spirit:displayName>
            <spirit:description>Drives the ATDATAM[31] output</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCITIDATAR_31_5</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>27</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCLAR</spirit:name>
          <spirit:description>Software Lock Access Register </spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCLAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Writing the key value 0xC5ACCE55 to this field clears the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register sets the lock, disabling write accesses to this component's registers through a memory mapped interface.Software can use the Software Lock to prevent accidental modification of the trace unit registers by software being debugged. For example, software that accidentally initializes an incorrect region of memory might disable the trace unit and make it impossible to trace the software.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCLSR</spirit:name>
          <spirit:description>Software Lock Status Register </spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCLSR -->
          <spirit:field>
            <spirit:name>RES0_TRCLSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. Possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. RAO.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCOSLAR</spirit:name>
          <spirit:description>OS Lock Access Register </spirit:description>
          <spirit:addressOffset>0x300</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCOSLAR -->
          <spirit:field>
            <spirit:name>RES0_TRCOSLAR_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LOCK</spirit:name>
            <spirit:displayName>LOCK</spirit:displayName>
            <spirit:description>OS Lock control bit:
      0
      
      Unlocks the OS Lock.
      
      
    
      1
      
      Locks the OS Lock. This setting disables the trace unit.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCOSLSR</spirit:name>
          <spirit:description>OS Lock Status Register </spirit:description>
          <spirit:addressOffset>0x304</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000A</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCOSLSR -->
          <spirit:field>
            <spirit:name>RES0_TRCOSLSR_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>Indicates whether the OS Lock is implemented.This bit is RES1, which indicates that the OS Lock is always implemented.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BIT32</spirit:name>
            <spirit:displayName>32BIT</spirit:displayName>
            <spirit:description>This bit is RES0, which indicates that software must perform a 32-bit write to update the TRCOSLAR.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LOCKED</spirit:name>
            <spirit:displayName>LOCKED</spirit:displayName>
            <spirit:description>OS Lock status bit:
      0
      
      The OS Lock is unlocked.
      
      
    
      1
      
      The OS Lock is locked.
      
      
    When the trace unit core power domain is powered down the value is UNKNOWN. The TRCPDSR indicates if the trace unit core power domain is powered down.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCOSLSR_0_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPDCR</spirit:name>
          <spirit:description>Power Down Control Register </spirit:description>
          <spirit:addressOffset>0x310</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPDCR -->
          <spirit:field>
            <spirit:name>RES0_TRCPDCR_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PU</spirit:name>
            <spirit:displayName>PU</spirit:displayName>
            <spirit:description>Powerup request bit:
      0
      
      The system can remove power from the trace unit. The TRCPDSR indicates if the trace unit is powered down.
      
      
    
      1
      
      The system must provide power to the trace unit.
      
      
    Typically, a trace unit drives a signal representing the value of this bit to a power controller to request that the trace unit core power domain is powered up. However, if the trace unit and the processor are in the same power domain then the implementation might combine the PU status with a signal from the processor.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCPDCR_2_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPDSR</spirit:name>
          <spirit:description>Power Down Status Register </spirit:description>
          <spirit:addressOffset>0x314</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCPDSR -->
          <spirit:field>
            <spirit:name>RES0_TRCPDSR_31_6</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>26</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LOCKED</spirit:name>
            <spirit:displayName>LOCKED</spirit:displayName>
            <spirit:description>OS Lock status bit:
      0
      
      The OS Lock is unlocked.
      
      
    
      1
      
      The OS Lock is locked.
      
      
    The value is UNKNOWN when the trace unit core power domain is powered down, that is, when POWER==0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCPDSR_4_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STICKYPD</spirit:name>
            <spirit:displayName>STICKYPD</spirit:displayName>
            <spirit:description>Sticky powerdown status bit. Indicates whether the trace register state is valid:
      0
      
      If POWER==1 then the state of TRCOSLSR and the trace registers are valid. If POWER==0 then it is UNKNOWN whether the state of TRCOSLSR and the trace registers are valid.
      
      
    
      1
      
      The state of TRCOSLSR and the trace registers might not be valid. The trace unit sets this bit to 1 if either the trace unit is reset, or the power to the trace unit core power domain is removed and the trace register state is not valid.
      
      
    After this register is read, if the Software Lock is unlocked and the trace unit core power domain is powered up, then the trace unit sets this bit to 0. The TRCLAR controls whether the Software Lock is locked.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>POWER</spirit:name>
            <spirit:displayName>POWER</spirit:displayName>
            <spirit:description>Power status bit:
      0
      
      The trace unit core power domain is not powered. The trace registers are not accessible and they all return an error response.
      
      
    
      1
      
      The trace unit core power domain is powered. The trace registers are accessible.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR0</spirit:name>
          <spirit:description>Peripheral Identification Register 0 </spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000005D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, bits[7:0].</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR1</spirit:name>
          <spirit:description>Peripheral Identification Register 1 </spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B9</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, bits[3:0] of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, bits[11:8].</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR2</spirit:name>
          <spirit:description>Peripheral Identification Register 2 </spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>The IMPLEMENTATION DEFINED revision number for the ETM implementation. See also TRCIDR1.REVISION.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR3</spirit:name>
          <spirit:description>Peripheral Identification Register 3 </spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>The IMPLEMENTATION DEFINED manufacturing revision number for the implementation. After silicon is available, if metal fixes are necessary, the manufacturer can alter the top metal layer so that this field can indicate any post-fab silicon changes.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR4</spirit:name>
          <spirit:description>Peripheral Identification Register 4 </spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RES0. This indicates that the ETM memory map occupies 4KB.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR5</spirit:name>
          <spirit:description>Peripheral Identification Register 5</spirit:description>
          <spirit:addressOffset>0xFD4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR5 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR5_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCPIDR5_7_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>RES0, reserved for future use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR6</spirit:name>
          <spirit:description>Peripheral Identification Register 6</spirit:description>
          <spirit:addressOffset>0xFD8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR6 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR6_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCPIDR6_7_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>RES0, reserved for future use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR7</spirit:name>
          <spirit:description>Peripheral Identification Register 7</spirit:description>
          <spirit:addressOffset>0xFDC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR7 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR7_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCPIDR7_7_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>RES0, reserved for future use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPRGCTLR</spirit:name>
          <spirit:description>Programming Control Register</spirit:description>
          <spirit:addressOffset>0x004</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPRGCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCPRGCTLR_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EN</spirit:name>
            <spirit:displayName>EN</spirit:displayName>
            <spirit:description>Trace unit enable bit. Possible values are:
      0
      
      The trace unit is disabled. All trace resources are inactive and no trace is generated.
      
      
    
      1
      
      The trace unit is enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR10</spirit:name>
          <spirit:description>Resource Selection Control Registers 10</spirit:description>
          <spirit:addressOffset>0x228</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR10 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR10_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR11</spirit:name>
          <spirit:description>Resource Selection Control Registers 11</spirit:description>
          <spirit:addressOffset>0x22c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR11 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR11_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR12</spirit:name>
          <spirit:description>Resource Selection Control Registers 12</spirit:description>
          <spirit:addressOffset>0x230</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR12 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR12_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR13</spirit:name>
          <spirit:description>Resource Selection Control Registers 13</spirit:description>
          <spirit:addressOffset>0x234</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR13 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR13_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR14</spirit:name>
          <spirit:description>Resource Selection Control Registers 14</spirit:description>
          <spirit:addressOffset>0x238</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR14 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR14_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR15</spirit:name>
          <spirit:description>Resource Selection Control Registers 15</spirit:description>
          <spirit:addressOffset>0x23c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR15 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR15_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR2</spirit:name>
          <spirit:description>Resource Selection Control Registers 2</spirit:description>
          <spirit:addressOffset>0x208</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR2_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR3</spirit:name>
          <spirit:description>Resource Selection Control Registers 3</spirit:description>
          <spirit:addressOffset>0x20c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR3_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR4</spirit:name>
          <spirit:description>Resource Selection Control Registers 4</spirit:description>
          <spirit:addressOffset>0x210</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR4 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR4_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR5</spirit:name>
          <spirit:description>Resource Selection Control Registers 5</spirit:description>
          <spirit:addressOffset>0x214</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR5 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR5_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR6</spirit:name>
          <spirit:description>Resource Selection Control Registers 6</spirit:description>
          <spirit:addressOffset>0x218</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR6 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR6_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR7</spirit:name>
          <spirit:description>Resource Selection Control Registers 7</spirit:description>
          <spirit:addressOffset>0x21c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR7 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR7_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR8</spirit:name>
          <spirit:description>Resource Selection Control Registers 8</spirit:description>
          <spirit:addressOffset>0x220</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR8 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR8_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR9</spirit:name>
          <spirit:description>Resource Selection Control Registers 9</spirit:description>
          <spirit:addressOffset>0x224</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR9 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR9_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQEVR0</spirit:name>
          <spirit:description>Sequencer State Transition Control Registers 0</spirit:description>
          <spirit:addressOffset>0x100</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQEVR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQEVR0_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>B_n</spirit:name>
            <spirit:displayName>B&lt;n&gt;</spirit:displayName>
            <spirit:description>Backward field. Contains an event number. When the event occurs then the sequencer state moves from state n+1 to state n.For example, for TRCSEQEVR2, if B2==0x14 then when event 0x14 occurs, the sequencer moves from state 3 to state 2.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_n</spirit:name>
            <spirit:displayName>F&lt;n&gt;</spirit:displayName>
            <spirit:description>Forward field. Contains an event number. When the event occurs then the sequencer state moves from state n to state n+1.For example, for TRCSEQEVR1, if F1==0x12 then when event 0x12 occurs, the sequencer moves from state 1 to state 2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQEVR1</spirit:name>
          <spirit:description>Sequencer State Transition Control Registers 1</spirit:description>
          <spirit:addressOffset>0x104</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQEVR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQEVR1_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>B_n</spirit:name>
            <spirit:displayName>B&lt;n&gt;</spirit:displayName>
            <spirit:description>Backward field. Contains an event number. When the event occurs then the sequencer state moves from state n+1 to state n.For example, for TRCSEQEVR2, if B2==0x14 then when event 0x14 occurs, the sequencer moves from state 3 to state 2.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_n</spirit:name>
            <spirit:displayName>F&lt;n&gt;</spirit:displayName>
            <spirit:description>Forward field. Contains an event number. When the event occurs then the sequencer state moves from state n to state n+1.For example, for TRCSEQEVR1, if F1==0x12 then when event 0x12 occurs, the sequencer moves from state 1 to state 2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQEVR2</spirit:name>
          <spirit:description>Sequencer State Transition Control Registers 2</spirit:description>
          <spirit:addressOffset>0x108</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQEVR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQEVR2_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>B_n</spirit:name>
            <spirit:displayName>B&lt;n&gt;</spirit:displayName>
            <spirit:description>Backward field. Contains an event number. When the event occurs then the sequencer state moves from state n+1 to state n.For example, for TRCSEQEVR2, if B2==0x14 then when event 0x14 occurs, the sequencer moves from state 3 to state 2.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_n</spirit:name>
            <spirit:displayName>F&lt;n&gt;</spirit:displayName>
            <spirit:description>Forward field. Contains an event number. When the event occurs then the sequencer state moves from state n to state n+1.For example, for TRCSEQEVR1, if F1==0x12 then when event 0x12 occurs, the sequencer moves from state 1 to state 2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQRSTEVR</spirit:name>
          <spirit:description>Sequencer Reset Control Register </spirit:description>
          <spirit:addressOffset>0x118</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF70</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQRSTEVR -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQRSTEVR_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RST</spirit:name>
            <spirit:displayName>RST</spirit:displayName>
            <spirit:description>Contains an event number. When the event occurs then the sequencer state moves to state 0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQSTR</spirit:name>
          <spirit:description>Sequencer State Register </spirit:description>
          <spirit:addressOffset>0x11C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQSTR -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQSTR_31_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STATE</spirit:name>
            <spirit:displayName>STATE</spirit:displayName>
            <spirit:description>Sets or returns the state of the sequencer:
      00
      
      State 0.
      
      
    
      01
      
      State 1.
      
      
    
      10
      
      State 2.
      
      
    
      11
      
      State 3.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSSCCR0</spirit:name>
          <spirit:description>Single-Shot Comparator Control Register 0 </spirit:description>
          <spirit:addressOffset>0x280</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSSCCR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCSSCCR0_31_25</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RST</spirit:name>
            <spirit:displayName>RST</spirit:displayName>
            <spirit:description>Controls whether the single-shot comparator resource is reset when it fires.
      0
      
      When the single-shot comparator resource fires, it is not reset.
      
      
    
      1
      
      When the single-shot comparator resource fires, it is reset. This enables the single-shot comparator resource to fire multiple times.
      
      
    </spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARC</spirit:name>
            <spirit:displayName>ARC</spirit:displayName>
            <spirit:description>Selects one or more address range comparators for single-shot control.Each bit represents an address range comparator pair, so bit[n-16] controls the selection of address range comparator pair n-16. If bit[n-16] is:
      0
      
      The address range comparator pair n-16 is not selected for single-shot control.
      
      
    
      1
      
      The address range comparator pair n-16 is selected for single-shot control.
      
      
    The width of this field is IMPLEMENTATION DEFINED. The field contains a number of implemented bits equal to TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SAC</spirit:name>
            <spirit:displayName>SAC</spirit:displayName>
            <spirit:description>Selects one or more single address comparators for single-shot control.Each bit represents a single address comparator, so bit[n] controls the selection of single address comparator n. If bit[n] is:
      0
      
      The single address comparator n, is not selected for single-shot control.
      
      
    
      1
      
      The single address comparator n, is selected for single-shot control.
      
      
    The width of this field is IMPLEMENTATION DEFINED. The field contains a number of implemented bits equal to 2 x TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSSCSR0</spirit:name>
          <spirit:description>Single-Shot Comparator Status Register 0 </spirit:description>
          <spirit:addressOffset>0x2A0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000001</spirit:value>
            <spirit:mask>0x7FFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSSCSR0 -->
          <spirit:field>
            <spirit:name>STATUS</spirit:name>
            <spirit:displayName>STATUS</spirit:displayName>
            <spirit:description>Single-shot status bit. Indicates if any of the comparators that TRCSSCCRn.SAC or TRCSSCCRn.ARC selects have matched:
      0
      
      No match has occurred.
      
      
    
      1
      
      One or more matches has occurred. If TRCSSCCRn.RST==0 then there is only one match and no more matches are possible, and software must reset this bit to 0 to re-enable the single-shot control.
      
      
    STATUS must be written to set an initial state when configuring the trace unit, if the single-shot comparator is to be used.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCSSCSR0_30_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DV</spirit:name>
            <spirit:displayName>DV</spirit:displayName>
            <spirit:description>Data value comparator support bit. Indicates if the trace unit supports data address with data value comparisons:
      0
      
      Single-shot data address with data value comparisons are not supported.
      
      
    
      1
      
      Single-shot data address with data value comparisons are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DA</spirit:name>
            <spirit:displayName>DA</spirit:displayName>
            <spirit:description>Data address comparator support bit. Indicates if the trace unit supports data address comparisons:
      0
      
      Single-shot data address comparisons are not supported.
      
      
    
      1
      
      Single-shot data address comparisons are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INST</spirit:name>
            <spirit:displayName>INST</spirit:displayName>
            <spirit:description>Instruction address comparator support bit. Indicates if the trace unit supports instruction address comparisons:
      0
      
      Single-shot instruction address comparisons are not supported.
      
      
    
      1
      
      Single-shot instruction address comparisons are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSTALLCTLR</spirit:name>
          <spirit:description>Stall Control Register </spirit:description>
          <spirit:addressOffset>0x02C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSTALLCTLR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCSTALLCTLR_31_9</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>23</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ISTALL</spirit:name>
            <spirit:displayName>Instruction stall bit</spirit:displayName>
            <spirit:description>Controls if the trace unit can stall the processor when the instruction trace buffer space is less than LEVEL</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCSTALLCTLR_7_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LEVEL</spirit:name>
            <spirit:displayName>Threshold level field</spirit:displayName>
            <spirit:description>The field can support 4 monotonic levels from 0b00 to 0b11</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCSTALLCTLR_1_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSTATR</spirit:name>
          <spirit:description>Status Register </spirit:description>
          <spirit:addressOffset>0x00C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCSTATR -->
          <spirit:field>
            <spirit:name>RES0_TRCSTATR_31_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMSTABLE</spirit:name>
            <spirit:displayName>PMSTABLE</spirit:displayName>
            <spirit:description>Programmer's model stable bit:
      0
      
      The programmer's model is not stable.
      
      
    
      1
      
      The programmer's model is stable. When polled, the trace unit trace registers return stable data.
      
      
    The programmer's model is stable when all of the following are true:TRCPRGCTLR.EN==0 or the OS Lock is locked.Reads from trace unit registers return stable data.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IDLE</spirit:name>
            <spirit:displayName>IDLE</spirit:displayName>
            <spirit:description>Idle status bit:
      0
      
      The trace unit is not idle.
      
      
    
      1
      
      The trace unit is idle.
      
      
    The trace unit is idle when all of the following are true:TRCPRGCTLR.EN==0 or the OS Lock is locked.The trace unit is drained of any trace.With the exception of the programming interfaces, all external interfaces on the trace unit are quiescent.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSYNCPR</spirit:name>
          <spirit:description>Synchronization Period Register </spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFE0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSYNCPR -->
          <spirit:field>
            <spirit:name>RES0_TRCSYNCPR_31_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>27</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PERIOD</spirit:name>
            <spirit:displayName>PERIOD</spirit:displayName>
            <spirit:description>Controls how many bytes of trace, the sum of instruction and data, that a trace unit can generate before a periodic trace synchronization request occurs. The number of bytes is always a power of two and the permitted values are:
      00000
      
      Periodic trace synchronization requests are disabled. This setting does not disable other types of trace synchronization request.
      
      
    
      01000
      
      Periodic trace synchronization request occurs after 2^8, or 256, bytes of trace.
      
      
    
      01001
      
      Periodic trace synchronization request occurs after 2^9, or 512, bytes of trace.
      
      
    
      01010
      
      Periodic trace synchronization request occurs after 2^10, or 1024, bytes of trace.
      
      
    and so on up to 0b10100, for which the request occurs after 2^20, or 1048576, bytes of trace.Values between 0b00001 and 0b001111 are reserved, as are values from 0b10101 onwards.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCTRACEIDR</spirit:name>
          <spirit:description>Trace ID Register </spirit:description>
          <spirit:addressOffset>0x040</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCTRACEIDR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCTRACEIDR_31_7</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>25</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRACEID</spirit:name>
            <spirit:displayName>TRACEID</spirit:displayName>
            <spirit:description>Trace ID value. When only instruction tracing is enabled this provides the trace ID.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCTSCTLR</spirit:name>
          <spirit:description>Global Timestamp Control Register </spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF70</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCTSCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCTSCTLR_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EVENT</spirit:name>
            <spirit:displayName>EVENT</spirit:displayName>
            <spirit:description>An event selector. When the selected event is triggered, the trace unit inserts a global timestamp into the trace streams.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVICTLR</spirit:name>
          <spirit:description>ViewInst Main Control Register </spirit:description>
          <spirit:addressOffset>0x080</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFF84F370</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVICTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCVICTLR_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level:
      0
      
      The trace unit generates instruction trace, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not generate instruction trace, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[20]Exception level 0.Bit[21]Exception level 1.Bit[22]Exception level 2.Bit[23]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. If instruction tracing is not implemented for a given exception level, the corresponding bit in this field is not implemented. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level:
      0
      
      The trace unit generates instruction trace, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not generate instruction trace, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[16]Exception level 0.Bit[17]Exception level 1.Bit[18]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[19]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. If instruction tracing is not implemented for a given exception level, the corresponding bit in this field is not implemented. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCVICTLR_15_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCERR</spirit:name>
            <spirit:displayName>TRCERR</spirit:displayName>
            <spirit:description>If TRCIDR3.TRCERR==1, this bit controls whether a trace unit must trace a system error exception:
      0
      
      The trace unit does not trace a system error exception unless it traces the exception or instruction immediately prior to the system error exception.
      
      
    
      1
      
      The trace unit always traces a system error exception.
      
      
    If TRCIDR3.TRCERR==0, this bit is RES0.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCRESET</spirit:name>
            <spirit:displayName>TRCRESET</spirit:displayName>
            <spirit:description>Controls whether a trace unit must trace a Reset exception:
      0
      
      The trace unit does not trace a Reset exception unless it traces the exception or instruction immediately prior to the Reset exception.
      
      
    
      1
      
      The trace unit always traces a Reset exception.
      
      
    </spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSSTATUS</spirit:name>
            <spirit:displayName>SSSTATUS</spirit:displayName>
            <spirit:description>IF TRCIDR4.NUMACPAIRS&gt;0 or TRCIDR.NUMPC&gt;0, this bit returns the status of the start-stop logic:
      0
      
      The start-stop logic is in the stopped state.
      
      
    
      1
      
      The start-stop logic is in the started state.
      
      
    The bit only returns stable data when TRCSTATR.PMSTABLE==1.Before software enables the trace unit, TRCPRGCTLR.EN==1, it must write to this bit to set the initial state of the start-stop logic. If the start-stop logic is not used then set this bit to 1. ARM recommends that the value of this bit is set before each trace run begins.If TRCIDR4.NUMACPAIRS==0 and TRCIDR4.NUMPC==0, this bit is RES0, indicating that the start-stop logic is not implemented.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCVICTLR_8_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EVENT</spirit:name>
            <spirit:displayName>EVENT</spirit:displayName>
            <spirit:description>An event selector. [TODO: Add the bit assignments for EVENT fields into the descriptions directly?]</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVIIECTLR</spirit:name>
          <spirit:description>ViewInst Include-Exclude Control Register </spirit:description>
          <spirit:addressOffset>0x084</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFF0FFF0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVIIECTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCVIIECTLR_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXCLUDE</spirit:name>
            <spirit:displayName>EXCLUDE</spirit:displayName>
            <spirit:description>
      0
      
      
      
      
    
      1
      
      
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCVIIECTLR_15_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INCLUDE</spirit:name>
            <spirit:displayName>INCLUDE</spirit:displayName>
            <spirit:description>Include range field. Selects which address range comparator pairs are in use with ViewInst include control. Each bit represents an address range comparator pair, so bit[m] controls the selection of address range comparator pair m. If bit[m] is:
      0
      
      The address range that address range comparator pair m defines is not selected for ViewInst include control.
      
      
    
      1
      
      The address range that address range comparator pair m defines is selected for ViewInst include control.
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.Selecting no include comparators indicates that all instructions are included by default. The exclude control then indicates which ranges are excluded.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVISSCTLR</spirit:name>
          <spirit:description>ViewInst Start-Stop Control Register </spirit:description>
          <spirit:addressOffset>0x088</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFF00FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVISSCTLR -->
          <spirit:field>
            <spirit:name>STOP</spirit:name>
            <spirit:displayName>STOP</spirit:displayName>
            <spirit:description>Selects which single address comparators are in use with ViewInst start-stop control, for the purpose of stopping trace. Each bit represents a single address comparator, so bit[m] controls the selection of single address comparator m-16. If bit[m] is:
      0
      
      The single address comparator m-16 is not selected as a stop resource.
      
      
    
      1
      
      The single address comparator m-16 is selected as a stop resource.
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of 2 x TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>START</spirit:name>
            <spirit:displayName>START</spirit:displayName>
            <spirit:description>Selects which single address comparators are in use with ViewInst start-stop control, for the purpose of starting trace. Each bit represents a single address comparator, so bit[n] controls the selection of single address comparator n. If bit[n] is:
      0
      
      The single address comparator n is not selected as a start resource.
      
      
    
      1
      
      The single address comparator n is selected as a start resource.
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of 2 x TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVMIDCVR0</spirit:name>
          <spirit:description>VMID Comparator Value Register 0 </spirit:description>
          <spirit:addressOffset>0x640</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVMIDCVR0 -->
          <spirit:field>
            <spirit:name>RESERVED_TRCVMIDCVR0_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE</spirit:name>
            <spirit:displayName>VALUE</spirit:displayName>
            <spirit:description>Contains a VMID value.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_DBG_CPU3</spirit:name>
        <spirit:displayName>APBADDR_DBG_3</spirit:displayName>
        <spirit:description>APBADDR_DBG_3</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">3211264</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_DBG_CPU3>  -->
        <spirit:register>
          <spirit:name>DBGAUTHSTATUS_EL1</spirit:name>
          <spirit:description>Debug Authentication Status register</spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000AA</spirit:value>
            <spirit:mask>0xFFFFFFAA</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: DBGAUTHSTATUS_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGAUTHSTATUS_EL1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNID</spirit:name>
            <spirit:displayName>SNID</spirit:displayName>
            <spirit:description>Secure non-invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Non-secure.
      
      
    
      10
      
      Implemented and disabled. ExternalSecureNoninvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalSecureNoninvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SID</spirit:name>
            <spirit:displayName>SID</spirit:displayName>
            <spirit:description>Secure invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Non-secure.
      
      
    
      10
      
      Implemented and disabled. ExternalSecureInvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalSecureInvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>Non-secure non-invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Secure.
      
      
    
      10
      
      Implemented and disabled. ExternalNoninvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalNoninvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSID</spirit:name>
            <spirit:displayName>NSID</spirit:displayName>
            <spirit:description>Non-secure invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Secure.
      
      
    
      10
      
      Implemented and disabled. ExternalInvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalInvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR0_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 0</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR0_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR0_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR0_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR0_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR1_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 1</spirit:description>
          <spirit:addressOffset>0x418</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR1_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR1_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR1_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR1_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR2_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 2</spirit:description>
          <spirit:addressOffset>0x428</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR2_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR2_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR2_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR2_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR3_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 3</spirit:description>
          <spirit:addressOffset>0x438</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR3_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR3_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR3_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR3_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR4_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 4</spirit:description>
          <spirit:addressOffset>0x448</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR4_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR4_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR4_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR4_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR5_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 5</spirit:description>
          <spirit:addressOffset>0x458</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR5_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR5_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR5_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR5_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR0_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR0_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR0_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR0_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR0_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR0_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR0_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR0_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR1_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR1_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR1_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR1_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR1_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR1_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR1_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR1_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR2_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR2_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x420</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR2_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR2_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR2_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR2_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR2_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x424</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR2_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR2_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR2_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR3_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR3_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x430</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR3_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR3_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR3_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR3_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR3_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x434</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR3_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR3_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR3_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR4_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR4_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x440</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR4_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR4_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR4_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR4_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR4_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x444</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR4_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR4_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR4_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR5_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR5_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x450</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR5_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR5_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR5_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR5_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR5_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x454</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR5_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR5_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR5_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGCLAIMCLR_EL1</spirit:name>
          <spirit:description>Debug Claim Tag Clear Register</spirit:description>
          <spirit:addressOffset>0xFA4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: DBGCLAIMCLR_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGCLAIMCLR_EL1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RAZ/SBZ. Software can rely on these bits reading as zero, and must use a should-be-zero policy on writes. Implementations must ignore writes.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIM</spirit:name>
            <spirit:displayName>CLAIM</spirit:displayName>
            <spirit:description>Claim clear bits. Reading this field returns the current value of the CLAIM bits.Writing a 1 to one of these bits clears the corresponding CLAIM bit to 0. This is an indirect write to the CLAIM bits.A single write operation can clear multiple bits to 0. Writing 0 to one of these bits has no effect.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGCLAIMSET_EL1</spirit:name>
          <spirit:description>Debug Claim Tag Set Register</spirit:description>
          <spirit:addressOffset>0xFA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000FF</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: DBGCLAIMSET_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGCLAIMSET_EL1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RAZ/SBZ. Software can rely on these bits reading as zero, and must use a should-be-zero policy on writes. Implementations must ignore writes.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIM</spirit:name>
            <spirit:displayName>CLAIM</spirit:displayName>
            <spirit:description>Claim set bits. RAO.Writing a 1 to one of these bits sets the corresponding CLAIM bit to 1. This is an indirect write to the CLAIM bits.A single write operation can set multiple bits to 1. Writing 0 to one of these bits has no effect.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGDTRRX_EL0</spirit:name>
          <spirit:description>Debug Data Transfer Register Receive</spirit:description>
          <spirit:addressOffset>0x080</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGDTRRX_EL0 -->
          <spirit:field>
            <spirit:name>DBGDTRRX_EL0</spirit:name>
            <spirit:displayName>DBGDTRRX_EL0</spirit:displayName>
            <spirit:description>Update DTRRX. Writes to this register update the value in DTRRX and set RXfull to 1.Reads of this register return the last value written to DTRRX and do not change RXfull.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGDTRTX_EL0</spirit:name>
          <spirit:description>Debug Data Transfer Register Transmit</spirit:description>
          <spirit:addressOffset>0x08C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGDTRTX_EL0 -->
          <spirit:field>
            <spirit:name>DBGDTRTX_EL0</spirit:name>
            <spirit:displayName>DBGDTRTX_EL0</spirit:displayName>
            <spirit:description>Return DTRTX. Reads of this register return the value in DTRTX and clear TXfull to 0.Writes of this register update the value in DTRTX and do not change TXfull.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR0_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 0</spirit:description>
          <spirit:addressOffset>0x808</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR0_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR0_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR0_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR1_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 1</spirit:description>
          <spirit:addressOffset>0x818</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR1_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR1_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR1_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR2_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 2</spirit:description>
          <spirit:addressOffset>0x828</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR2_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR2_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR2_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR3_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 3</spirit:description>
          <spirit:addressOffset>0x838</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR3_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR3_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR3_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR0_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 0</spirit:description>
          <spirit:addressOffset>0x800</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR0_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR0_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 0</spirit:description>
          <spirit:addressOffset>0x804</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR1_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 1</spirit:description>
          <spirit:addressOffset>0x810</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR1_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR1_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 1</spirit:description>
          <spirit:addressOffset>0x814</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR2_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 2</spirit:description>
          <spirit:addressOffset>0x820</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR2_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR2_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR2_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 2</spirit:description>
          <spirit:addressOffset>0x824</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR2_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR3_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 3</spirit:description>
          <spirit:addressOffset>0x830</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR3_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR3_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR3_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 3</spirit:description>
          <spirit:addressOffset>0x834</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR3_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDACR</spirit:name>
          <spirit:description>External Debug Auxiliary Control Register</spirit:description>
          <spirit:addressOffset>0x094</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: EDACR -->
          <spirit:field>
            <spirit:name>RES0_EDACR_31_0</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR0</spirit:name>
          <spirit:description>External Debug Component Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR1</spirit:name>
          <spirit:description>External Debug Component Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR1 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, debug component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR2</spirit:name>
          <spirit:description>External Debug Component Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR3</spirit:name>
          <spirit:description>External Debug Component Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR3 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDSR</spirit:name>
          <spirit:description>External Debug Context ID Sample Register</spirit:description>
          <spirit:addressOffset>0x0A4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDCIDSR -->
          <spirit:field>
            <spirit:name>CONTEXTIDR</spirit:name>
            <spirit:displayName>CONTEXTIDR</spirit:displayName>
            <spirit:description>The sampled value of CONTEXTIDR_EL1, captured on reading the low half of EDPCSR.If EL3 is implemented and using AArch32 then CONTEXTIDR is a Banked register, and EDCIDSR samples the current Banked copy of CONTEXTIDR.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVAFF0</spirit:name>
          <spirit:description>External Debug Device Affinity Register 0</spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000003</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVAFF0 -->
          <spirit:field>
            <spirit:name>EDDEVAFF0</spirit:name>
            <spirit:displayName>EDDEVAFF0</spirit:displayName>
            <spirit:description>MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVAFF1</spirit:name>
          <spirit:description>External Debug Device Affinity Register 1</spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVAFF1 -->
          <spirit:field>
            <spirit:name>EDDEVAFF1</spirit:name>
            <spirit:displayName>EDDEVAFF1</spirit:displayName>
            <spirit:description>MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVARCH</spirit:name>
          <spirit:description>External Debug Device Architecture Register</spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47706A15</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For debug, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For debug, the revision defined by v8-A is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For debug:Bits [15:12] are the architecture version, 0x6.Bits [11:0] are the architecture part number, 0xA15.This corresponds to debug architecture version v8-A.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVID</spirit:name>
          <spirit:description>External Debug Device ID Register 0</spirit:description>
          <spirit:addressOffset>0xFC8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVID -->
          <spirit:field>
            <spirit:name>RES0_EDDEVID_31_28</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AuxRegs</spirit:name>
            <spirit:displayName>AuxRegs</spirit:displayName>
            <spirit:description>Indicates support for Auxiliary registers. Permitted values for this field are:
      0000
      
      None supported.
      
      
    
      0001
      
      Support for External Debug Auxiliary Control Register, EDACR.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDDEVID_23_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PCSample</spirit:name>
            <spirit:displayName>PCSample</spirit:displayName>
            <spirit:description>Indicates the level of Sample-based profiling support using external debug registers 40 through 43. Permitted values of this field in v8-A are:
      0000
      
      Architecture-defined form of Sample-based profiling not implemented.
      
      
    
      0010
      
      EDPCSR and EDCIDSR are implemented (only permitted if EL3 and EL2 are not implemented).
      
      
    
      0011
      
      EDPCSR, EDCIDSR, and EDVIDSR are implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVID1</spirit:name>
          <spirit:description>External Debug Device ID Register 1</spirit:description>
          <spirit:addressOffset>0xFC4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000002</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVID1 -->
          <spirit:field>
            <spirit:name>RES0_EDDEVID1_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PCSROffset</spirit:name>
            <spirit:displayName>PCSROffset</spirit:displayName>
            <spirit:description>This field indicates the offset applied to PC samples returned by reads of EDPCSR. Permitted values of this field in v8-A are:
      0000
      
      EDPCSR not implemented.
      
      
    
      0010
      
      EDPCSR implemented, and samples have no offset applied and do not sample the instruction set state in AArch32 state.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVID2</spirit:name>
          <spirit:description>External Debug Device ID Register 2</spirit:description>
          <spirit:addressOffset>0xFC0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVID2 -->
          <spirit:field>
            <spirit:name>RES0_EDDEVID2_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVTYPE</spirit:name>
          <spirit:description>External Debug Device Type Register</spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000015</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_EDDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Subtype. Must read as 0x1 to indicate this is a processor component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAJOR</spirit:name>
            <spirit:displayName>MAJOR</spirit:displayName>
            <spirit:description>Major type. Must read as 0x5 to indicate this is a debug logic component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDECCR</spirit:name>
          <spirit:description>External Debug Exception Catch Control Register</spirit:description>
          <spirit:addressOffset>0x098</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDECCR -->
          <spirit:field>
            <spirit:name>RES0_EDECCR_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSE</spirit:name>
            <spirit:displayName>NSE</spirit:displayName>
            <spirit:description>Coarse-grained Non-secure exception catch. Possible values of this field are:
      0000
      
      Exception catch debug event disabled for Non-secure exception levels.
      
      
    
      0010
      
      Exception catch debug event enabled for Non-secure EL1.
      
      
    
      0100
      
      Exception catch debug event enabled for Non-secure EL2.
      
      
    
      0110
      
      Exception catch debug event enabled for Non-secure EL1 and EL2.
      
      
    All other values are reserved. Bits [7,4] are reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SE</spirit:name>
            <spirit:displayName>SE</spirit:displayName>
            <spirit:description>Coarse-grained Secure exception catch. Possible values of this field are:
      0000
      
      Exception catch debug event disabled for Secure exception levels.
      
      
    
      0010
      
      Exception catch debug event enabled for Secure EL1.
      
      
    
      1000
      
      Exception catch debug event enabled for Secure EL3.
      
      
    
      1010
      
      Exception catch debug event enabled for Secure EL1 and EL3.
      
      
    All other values are reserved. Bits [2,0] are reserved. RES0. Ignored if ExternalSecureInvasiveDebugEnabled() == FALSE.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDECR</spirit:name>
          <spirit:description>External Debug Execution Control Register</spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDECR -->
          <spirit:field>
            <spirit:name>RES0_EDECR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SS</spirit:name>
            <spirit:displayName>SS</spirit:displayName>
            <spirit:description>Halting step enable. Possible values of this field are:
      0
      
      Halting step debug event disabled.
      
      
    
      1
      
      Halting step debug event enabled.
      
      
    If the value of EDECR.SS is changed when the processor is in Non-debug state, the resulting value of EDECR.SS is UNKNOWN.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RCE</spirit:name>
            <spirit:displayName>RCE</spirit:displayName>
            <spirit:description>Reset catch enable. Possible values of this field are:
      0
      
      Reset catch debug event disabled.
      
      
    
      1
      
      Reset catch debug event enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSUCE</spirit:name>
            <spirit:displayName>OSUCE</spirit:displayName>
            <spirit:description>OS unlock catch enabled. Possible values of this field are:
      0
      
      OS unlock catch debug event disabled.
      
      
    
      1
      
      OS unlock catch debug event enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDESR</spirit:name>
          <spirit:description>External Debug Event Status Register</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF9</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDESR -->
          <spirit:field>
            <spirit:name>RES0_EDESR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SS</spirit:name>
            <spirit:displayName>SS</spirit:displayName>
            <spirit:description>Halting step debug event pending. Possible values of this field are:
      0
      
      Reading this means that a Halting step debug event is not pending. Writing this means no action.
      
      
    
      1
      
      Reading this means that a Halting step debug event is pending. Writing this clears the pending Halting step debug event.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RC</spirit:name>
            <spirit:displayName>RC</spirit:displayName>
            <spirit:description>Reset catch debug event pending. Possible values of this field are:
      0
      
      Reading this means that a Reset catch debug event is not pending. Writing this means no action.
      
      
    
      1
      
      Reading this means that a Reset catch debug event is pending. Writing this clears the pending Reset catch debug event.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSUC</spirit:name>
            <spirit:displayName>OSUC</spirit:displayName>
            <spirit:description>OS unlock debug event pending. Possible values of this field are:
      0
      
      Reading this means that an OS unlock catch debug event is not pending. Writing this means no action.
      
      
    
      1
      
      Reading this means that an OS unlock catch debug event is pending. Writing this clears the pending OS unlock catch debug event.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDITCTRL</spirit:name>
          <spirit:description>External Debug Integration mode Control Register</spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDITCTRL -->
          <spirit:field>
            <spirit:name>RES0_EDITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IME</spirit:name>
            <spirit:displayName>IME</spirit:displayName>
            <spirit:description>Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.
      0
      
      Normal operation.
      
      
    
      1
      
      Integration mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDITR</spirit:name>
          <spirit:description>External Debug Instruction Transfer Register</spirit:description>
          <spirit:addressOffset>0x084</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: EDITR -->
          <spirit:field>
            <spirit:name>EDITR</spirit:name>
            <spirit:displayName>EDITR</spirit:displayName>
            <spirit:description>Used in Debug state for passing instructions to the processor for execution</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDLAR</spirit:name>
          <spirit:description>External Debug Lock Access Register</spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: EDLAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDLSR</spirit:name>
          <spirit:description>External Debug Lock Status Register</spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF8</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDLSR -->
          <spirit:field>
            <spirit:name>RES0_EDLSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:
      0
      
      Software lock not implemented or not memory-mapped access.
      
      
    
      1
      
      Software lock implemented and memory-mapped access.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPCSR_31:0</spirit:name>
          <spirit:description>External Debug Program Counter Sample Register (low word)</spirit:description>
          <spirit:addressOffset>0x0A0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDPCSR_31:0 -->
          <spirit:field>
            <spirit:name>EDPCSR_31:0</spirit:name>
            <spirit:displayName>EDPCSR_31:0</spirit:displayName>
            <spirit:description>PC Sample low word, EDPCSRlo. Bits [31:0] of the sampled instruction address value. Reading EDPCSRlo has the side-effect of updating EDCIDSR, EDVIDSR, and EDPCSRhi. However:If the processor is in Debug state, or Sample-based profiling is prohibited, EDPCSRlo reads as 0xFFFFFFFF and EDCIDSR, EDVIDSR, and EDPCSRhi become UNKNOWN.If the processor is in Reset state, the sampled value is unknown and EDCIDSR, EDVIDSR and EDPCSRhi become UNKNOWN.If no instruction has been retired since the processor left Reset state, Debug state, or a state where Non-invasive debug is not permitted, the sampled value is UNKNOWN and EDCIDSR, EDVIDSR, and EDPCSRhi become UNKNOWN.For a read of EDPCSRlo from the memory-mapped interface, if EDLSR.SLK == 1, meaning the Software Lock is locked, then the access has no side-effects. That is, EDCIDSR, EDVIDSR, and EDPCSRhi are unchanged.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPCSR_63:32</spirit:name>
          <spirit:description>External Debug Program Counter Sample Register (high word)</spirit:description>
          <spirit:addressOffset>0x0AC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDPCSR_63:32 -->
          <spirit:field>
            <spirit:name>EDPCSR_63:32</spirit:name>
            <spirit:displayName>EDPCSR_63:32</spirit:displayName>
            <spirit:description>PC Sample high word, EDPCSRhi. If EDVIDSR.HV == 0 then this field is RAZ, otherwise bits [63:32] of the sampled PC.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR0</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, least significant byte.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR1</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000BD</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, most significant nibble.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR2</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Part major revision. Parts can also use this field to extend Part number to 16-bits.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR3</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>Part minor revision. Parts using EDPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR4</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 4</spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPRCR</spirit:name>
          <spirit:description>External Debug Power/Reset Control Register</spirit:description>
          <spirit:addressOffset>0x310</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF6</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPRCR -->
          <spirit:field>
            <spirit:name>RES0_EDPRCR_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COREPURQ</spirit:name>
            <spirit:displayName>COREPURQ</spirit:displayName>
            <spirit:description>Core powerup request. Allows a debugger to request that the power controller power up the core, enabling access to the debug register in the Core power domain. The actions on writing to this bit are:
      0
      
      No effect.
      
      
    
      1
      
      Request the power controller to powerup the core.
      
      
    In an implementation that includes the recommended external debug interface, this bit drives the DBGPWRUPREQ signal.This bit can be read and written when the Core power domain is powered off.The power controller must not allow the Core power domain to switch off while this bit is one.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDPRCR_2_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CWRR</spirit:name>
            <spirit:displayName>CWRR</spirit:displayName>
            <spirit:description>Warm reset request. Write only bit that reads as zero. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Request Warm reset.
      
      
    The processor ignores writes to this bit if any of the following are the case:ExternalInvasiveDebugEnabled() == FALSE, EL3 is not implemented, and the processor is Non-secure.ExternalSecureInvasiveDebugEnabled() == FALSE and one of the following is true:EL3 is implemented.The processor is Secure.The Core power domain is either completely off or in a low-power state where the Core power domain registers cannot be accessed.DoubleLockStatus() == TRUE (OS Double Lock is set).OSLSR.OSLK == 1 (OS lock is locked).In an implementation that includes the recommended external debug interface, this bit drives the DBGRSTREQ signal.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CORENPDRQ</spirit:name>
            <spirit:displayName>CORENPDRQ</spirit:displayName>
            <spirit:description>Core no powerdown request. Requests emulation of powerdown. Possible values of this bit are:
      0
      
      On a powerdown request, the system powers down the Core power domain.
      
      
    
      1
      
      On a powerdown request, the system emulates powerdown of the Core power domain. In this emulation mode the Core power domain is not actually powered down.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPRSR</spirit:name>
          <spirit:description>External Debug Processor Status Register</spirit:description>
          <spirit:addressOffset>0x314</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFF543</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPRSR -->
          <spirit:field>
            <spirit:name>RES0_EDPRSR_31_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SDR</spirit:name>
            <spirit:displayName>SDR</spirit:displayName>
            <spirit:description>Sticky debug restart. Set to 1 when the processor exits Debug state and cleared to 0 following reads of EDPRSR.
      0
      
      The processor has not restarted since EDPRSR was last read.
      
      
    
      1
      
      The processor has restarted since EDPRSR was last read.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 when following a read of EDPRSR.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SPMAD</spirit:name>
            <spirit:displayName>SPMAD</spirit:displayName>
            <spirit:description>Sticky EPMAD error. Set to 1 if an access returns an error because AllowExternalPMUAccess() == FALSE.
      0
      
      No accesses to the external performance monitors registers have failed since EDPRSR was last read.
      
      
    
      1
      
      At least one access to the external performance monitors registers has failed since EDPRSR was last read.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 when following a read of EDPRSR.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EPMAD</spirit:name>
            <spirit:displayName>EPMAD</spirit:displayName>
            <spirit:description>External performance monitors access disable status.
      0
      
      External performance monitors access enabled.
      
      
    
      1
      
      External performance monitors access disabled.
      
      
    If external performance monitors access is not implemented, EPMAD is RAO. This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SDAD</spirit:name>
            <spirit:displayName>SDAD</spirit:displayName>
            <spirit:description>Sticky EDAD error. Set to 1 if an access returns an error because AllowExternalDebugAccess() == FALSE.
      0
      
      No accesses to the external debug registers have failed since EDPRSR was last read.
      
      
    
      1
      
      At least one access to the external debug registers has failed since EDPRSR was last read.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 following a read of EDPRSR.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EDAD</spirit:name>
            <spirit:displayName>EDAD</spirit:displayName>
            <spirit:description>External debug access disable status.
      0
      
      External debug access enabled.
      
      
    
      1
      
      External debug access disabled.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DLK</spirit:name>
            <spirit:displayName>DLK</spirit:displayName>
            <spirit:description>OS Double Lock status bit.
      0
      
      OSDLR_EL1.DLK == 0 or EDPRCR.CORENPDRQ == 1 or the processor is in Debug state.
      
      
    
      1
      
      OSDLR_EL1.DLK == 1 and EDPRCR.CORENPDRQ == 0 and the processor is in Non-debug state.
      
      
    This bit is UNKNOWN on reads if EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSLK</spirit:name>
            <spirit:displayName>OSLK</spirit:displayName>
            <spirit:description>OS lock status bit. A read of this bit returns the value of OSLSR_EL1.OSLK.This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1 or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HALTED</spirit:name>
            <spirit:displayName>HALTED</spirit:displayName>
            <spirit:description>Halted status bit. Possible values are:
      0
      
      EDSCR.STATUS is 0b000010 (processor in Non-debug state).
      
      
    
      1
      
      EDSCR.STATUS is not 0b000010.
      
      
    This bit is UNKNOWN on reads if EDPRSR.PU is 0. </spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SR</spirit:name>
            <spirit:displayName>SR</spirit:displayName>
            <spirit:description>Sticky core reset status bit. Possible values are:
      0
      
      The non-debug logic of the processor is not in reset state and has not been reset since the last time EDPRSR was read.
      
      
    
      1
      
      The non-debug logic of the processor is in reset state or has been reset since the last time EDPRSR was read.
      
      
    This bit is UNKNOWN on reads if EDPRSR.DLK is 1 or EDPRSR.PU is 0.This bit clears to 0 following a read of EDPRSR if the non-debug logic of the processor is not in reset state.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>R</spirit:name>
            <spirit:displayName>R</spirit:displayName>
            <spirit:description>Core reset status bit. Possible values are:
      0
      
      The non-debug logic of the processor is not in reset state.
      
      
    
      1
      
      The non-debug logic of the processor is in reset state.
      
      
    This bit is UNKNOWN on reads if either EDPRSR.DLK is 1 or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SPD</spirit:name>
            <spirit:displayName>SPD</spirit:displayName>
            <spirit:description>Sticky core power-down status bit.This bit is set to 1 on Cold reset to indicate the state of the debug registers has been lost. Since a Cold reset is required on powering up the processor, this usually indicates the Core power domain has been completely powered off.Possible values are:
      0
      
      If the Core power domain is off (EDPRSR.PU is 0), it is not known whether the state of the debug registers in the Core power domain is lost. Otherwise, the Core power domain is on, and the state of the debug registers in the Core power domain has not been lost.
      
      
    
      1
      
      The state of the debug registers in the Core power domain is lost.
      
      
    This bit is UNKNOWN on reads if both EDPRSR.DLK and EDPRSR.PU are 1.This bit clears to 0 following a read of EDPRSR if the processor is not in the powered down state. There are two logical power off states for the Core power domain:RetentionThe states of the debug registers, including EDPRSR.SPD, in the Core power domain is preserved, and restored on leaving retention state.Power-downThe states of the debug registers in the Core power domain is lost, and a Cold reset is asserted on leaving power-down state.In these states, it is IMPLEMENTATION DEFINED whether:EDPRSR.SPD shows whether the state of the debug registers in the Core power domain has been lost since the last time EDPRSR was read when the Core power domain was on.EDPRSR.SPD reads-as-zero.EDPRSR.SPD is not cleared following a read of EDPRSR in these states.This means it is IMPLEMENTATION DEFINED whether a processor implements EDPRSR.SPD as:Fixed RAZ when in one or both of the retention and power-down states.Retaining its previous value when in the retention state.Fixed RAO in the power-down state.Note that this definition does not allow EDPRSR.SPD to be fixed RAO in the low-power retention state, as the state of the debug registers in the Core power domain is not lost by entering this state. However, the bit can be read as 1 in this state if the state of the registers was lost before entering this state (i.e. EDPRSR has not been read since the last Cold reset).ARM recommends that an implementation make EDPRSR.SPD fixed RAO when in the power-down state, particularly if it does not support a low-power retention state.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PU</spirit:name>
            <spirit:displayName>PU</spirit:displayName>
            <spirit:description>Core power-up status bit. Indicates whether the Core power domain debug registers can be accessed:
      0
      
      Core is in a low-power or power-down state where the debug registers cannot be accessed.
      
      
    
      1
      
      Core is in a power-up state where the debug registers can be accessed.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDRCR</spirit:name>
          <spirit:description>External Debug Reserve Control Register</spirit:description>
          <spirit:addressOffset>0x090</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDRCR -->
          <spirit:field>
            <spirit:name>RES0_EDRCR_31_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>27</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CBRRQ</spirit:name>
            <spirit:displayName>CBRRQ</spirit:displayName>
            <spirit:description>Allow imprecise entry to Debug state. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Allow imprecise entry to Debug state, for example by canceling pending bus accesses.
      
      
    Setting this bit to 1 allows a debugger to request imprecise entry to Debug state. An External Debug Request debug event must be pending before the debugger sets this bit to 1.This feature is optional. If this feature is not implemented, writes to this bit are ignored.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSPA</spirit:name>
            <spirit:displayName>CSPA</spirit:displayName>
            <spirit:description>Clear Sticky Pipeline Advance. This bit is used to clear the EDSCR.PipeAdv bit to 0. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Clear the EDSCR.PipeAdv bit to 0.
      
      
    </spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSE</spirit:name>
            <spirit:displayName>CSE</spirit:displayName>
            <spirit:description>Clear Sticky Error. Used to clear the EDSCR cumulative error bits to 0. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Clear the EDSCR.{TXU, RXO, ERR} bits, and, if the processor is in Debug state, the EDSCR.ITO bit, to 0.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDRCR_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDSCR</spirit:name>
          <spirit:description>External Debug Status and Control Register</spirit:description>
          <spirit:addressOffset>0x088</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xECFAC040</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDSCR -->
          <spirit:field>
            <spirit:name>RES0_EDSCR_31_31</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXfull</spirit:name>
            <spirit:displayName>RXfull</spirit:displayName>
            <spirit:description>DTRRX full. This bit is RO.</spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXfull</spirit:name>
            <spirit:displayName>TXfull</spirit:displayName>
            <spirit:description>DTRTX full. This bit is RO.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ITO</spirit:name>
            <spirit:displayName>ITO</spirit:displayName>
            <spirit:description>EDITR overrun. This bit is RO.If the processor is not in Debug state, this bit is UNKNOWN. ITO is set to 0 on entry to Debug state.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXO</spirit:name>
            <spirit:displayName>RXO</spirit:displayName>
            <spirit:description>DTRRX overrun. This bit is RO.</spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXU</spirit:name>
            <spirit:displayName>TXU</spirit:displayName>
            <spirit:description>DTRTX underrun. This bit is RO.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PipeAdv</spirit:name>
            <spirit:displayName>PipeAdv</spirit:displayName>
            <spirit:description>Pipeline advance. Read-only. Set to 1 every time the processor pipeline retires one or more instructions. Cleared to 0 by a write to EDRCR.CSPA.The architecture does not define precisely when this bit is set to 1. It requires only that this happen periodically in Non-debug state to indicate that software execution is progressing.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ITE</spirit:name>
            <spirit:displayName>ITE</spirit:displayName>
            <spirit:description>ITR empty. This bit is RO.If the processor is not in Debug state, this bit is UNKNOWN. It is always valid in Debug state.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INTdis</spirit:name>
            <spirit:displayName>INTdis</spirit:displayName>
            <spirit:description>Interrupt disable. Disables taking interrupts (including virtual interrupts and System Error interrupts) in Non-Debug state.If external invasive debug is disabled, the value of this field is ignored.If external invasive debug is enabled, the possible values of this field are:
      00
      
      Do not disable interrupts
      
      
    
      01
      
      Disable interrupts targeting Non-secure EL1.
      
      
    
      10
      
      Disable interrupts targeting only Non-secure EL1 and Non-secure EL2. If external secure invasive debug is enabled, also disable interrupts targeting Secure EL1.
      
      
    
      11
      
      Disable interrupts targeting only Non-secure EL1 and Non-secure EL2. If external secure invasive debug is enabled, also disable all other interrupts.
      
      
    The value of INTdis does not affect whether an interrupt is a WFI wake-up event, but can mask an interrupt as a WFE wake-up event.If EL3 and EL2 are not implemented, INTdis[0] is RO and reads the same value as INTdis[1], meaning only the values 0b00 and 0b11 can be selected.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TDA</spirit:name>
            <spirit:displayName>TDA</spirit:displayName>
            <spirit:description>Trap debug registers accesses.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MA</spirit:name>
            <spirit:displayName>MA</spirit:displayName>
            <spirit:description>Memory access mode. Controls use of memory-access mode for accessing EDITR and the DCC. This bit is ignored if in Non-debug state and set to zero on entry to Debug state.Possible values of this field are:
      0
      
      Normal access mode
      
      
    
      1
      
      Memory access mode.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDSCR_19_19</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>19</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NS</spirit:name>
            <spirit:displayName>NS</spirit:displayName>
            <spirit:description>Non-secure status. Read-only. When in Debug state, gives the current security state:
      0
      
      Secure state, IsSecure() == TRUE
      
      
    
      1
      
      Non-secure state, IsSecure() == FALSE.
      
      
    In Non-debug state, this bit is UNKNOWN.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDSCR_17_17</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SDD</spirit:name>
            <spirit:displayName>SDD</spirit:displayName>
            <spirit:description>Secure debug disabled. This bit is RO.On entry to Debug state:If entering in Secure state, SDD is set to 0.If entering in Non-secure state, SDD is set to the inverse of ExternalSecureInvasiveDebugEnabled().In Debug state, the value of the SDD bit does not change, even if ExternalSecureInvasiveDebugEnabled() changes.In Non-debug state:SDD returns the inverse of ExternalSecureInvasiveDebugEnabled(). If the authentication signals that control ExternalSecureInvasiveDebugEnabled() change, a context synchronization operation is required to guarantee their effect.This bit is unaffected by the Security state of the processor.If EL3 is not implemented and the implementation is Non-secure, this bit is RES1.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDSCR_15_15</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HDE</spirit:name>
            <spirit:displayName>HDE</spirit:displayName>
            <spirit:description>Halting debug mode enable. Possible values of this bit are:
      0
      
      Halting debug mode disabled.
      
      
    
      1
      
      Halting debug mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RW</spirit:name>
            <spirit:displayName>RW</spirit:displayName>
            <spirit:description>Exception level register-width status. Read-only. In Debug state, each bit gives the current register width status of each EL:
      1111
      
      All exception levels are AArch64 state.
      
      
    
      1110
      
      EL0 is AArch32 state. All other exception levels are AArch64 state.
      
      
    
      1100
      
      EL0 and EL1 are AArch32 state. All other exception levels are AArch64 state. Never seen if EL2 is not implemented in the current security state.
      
      
    
      1000
      
      EL0, EL1, and, if implemented in the current security state, EL2 are AArch32 state. All other exception levels are AArch64 state.
      
      
    
      0000
      
      All exception levels are set to AArch32 state (32-bit configuration).
      
      
    However:If not at EL0: RW[0] == RW[1].If EL2 is not implemented in the current security state: RW[2] == RW[1].If EL3 is not implemented: RW[3] == RW[2].In Non-debug state, this field is RAO.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL</spirit:name>
            <spirit:displayName>EL</spirit:displayName>
            <spirit:description>Exception level. Read-only. In Debug state, this gives the current EL of the processor.In Non-debug state, this field is RAZ.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>A</spirit:name>
            <spirit:displayName>A</spirit:displayName>
            <spirit:description>System Error interrupt pending. Read-only. In Debug state, indicates whether a SError interrupt is pending:If HCR_EL2.{AMO, TGE} = {1, 0} and in Non-secure EL0 or EL1, a virtual SError interrupt.Otherwise, a physical SError interrupt.
      0
      
      No SError interrupt pending.
      
      
    
      1
      
      SError interrupt pending.
      
      
    A debugger can read EDSCR to check whether a SError interrupt is pending without having to execute further instructions. A pending SError might indicate data from target memory is corrupted.UNKNOWN in Non-debug state.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERR</spirit:name>
            <spirit:displayName>ERR</spirit:displayName>
            <spirit:description>Cumulative error flag. This field is RO. It is set to 1 following exceptions in Debug state and on any signaled overrun or underrun on the DTR or EDITR.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STATUS</spirit:name>
            <spirit:displayName>STATUS</spirit:displayName>
            <spirit:description>Debug status flags. This field is RO.The possible values of this field are:
      000010
      
      Processor is in Non-debug state.
      
      
    
      000001
      
      Processor is restarting (exiting Debug state).
      
      
    
      000111
      
      Breakpoint.
      
      
    
      010011
      
      External debug request.
      
      
    
      011011
      
      Halting step, normal.
      
      
    
      011111
      
      Halting step, exclusive.
      
      
    
      100011
      
      OS unlock catch.
      
      
    
      100111
      
      Reset catch.
      
      
    
      101011
      
      Watchpoint.
      
      
    
      101111
      
      HLT instruction.
      
      
    
      110011
      
      Software access to debug register.
      
      
    
      110111
      
      Exception catch.
      
      
    
      111011
      
      Halting step, no syndrome.
      
      
    All other values of STATUS are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDVIDSR</spirit:name>
          <spirit:description>External Debug Virtual Context Sample Register</spirit:description>
          <spirit:addressOffset>0x0A8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0x0FFFFF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDVIDSR -->
          <spirit:field>
            <spirit:name>NS</spirit:name>
            <spirit:displayName>NS</spirit:displayName>
            <spirit:description>Non-secure state sample. Indicates the security state associated with the most recent EDPCSR sample.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E2</spirit:name>
            <spirit:displayName>E2</spirit:displayName>
            <spirit:description>Exception level 2 status sample. Indicates whether the most recent EDPCSR sample was associated with EL2. If EDVIDSR.NS == 0, this bit is 0.</spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E3</spirit:name>
            <spirit:displayName>E3</spirit:displayName>
            <spirit:description>Exception level 3 status sample. Indicates whether the most recent EDPCSR sample was associated with AArch64 EL3. If EDVIDSR.NS == 1 or the processor was in AArch32 state when EDPCSR was read, this bit is 0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HV</spirit:name>
            <spirit:displayName>HV</spirit:displayName>
            <spirit:description>EDPCSR high half valid. Indicates whether bits [63:32] of the most recent EDPCSR sample are valid. If EDVIDSR.HV == 0, the value of EDPCSR[63:32] is RAZ.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDVIDSR_27_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VMID</spirit:name>
            <spirit:displayName>VMID</spirit:displayName>
            <spirit:description>VMID sample. The value of VTTBR_EL2.VMID associated with the most recent EDPCSR sample. If EDVIDSR.NS == 0 or EDVIDSR.E2 == 1, this field is RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDWAR_31:0</spirit:name>
          <spirit:description>External Debug Watchpoint Address Register (low word)</spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDWAR_31:0 -->
          <spirit:field>
            <spirit:name>EDWAR_31:0</spirit:name>
            <spirit:displayName>EDWAR_31:0</spirit:displayName>
            <spirit:description>Watchpoint address. The virtual data address being accessed when a watchpoint debug event was triggered and caused entry to Debug state.UNKNOWN if the processor is not in Debug state, or if Debug state was entered other than for a watchpoint debug event.The address must be within a naturally-aligned block of memory of power-of-two size no larger than the DC ZVA block size.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDWAR_63:32</spirit:name>
          <spirit:description>External Debug Watchpoint Address Register (high word)</spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDWAR_63:32 -->
          <spirit:field>
            <spirit:name>EDWAR_63:32</spirit:name>
            <spirit:displayName>EDWAR_63:32</spirit:displayName>
            <spirit:description>Watchpoint address. The virtual data address being accessed when a watchpoint debug event was triggered and caused entry to Debug state.UNKNOWN if the processor is not in Debug state, or if Debug state was entered other than for a watchpoint debug event.The address must be within a naturally-aligned block of memory of power-of-two size no larger than the DC ZVA block size.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR0_EL1_31:0</spirit:name>
          <spirit:description>Debug Feature Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD28</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x10305106</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>CTX_CMPs</spirit:name>
            <spirit:displayName>CTX_CMPs</spirit:displayName>
            <spirit:description>Number of breakpoints that are context-aware, minus 1. These are the highest numbered breakpoints.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR0_EL1_31:0_27_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WRPs</spirit:name>
            <spirit:displayName>WRPs</spirit:displayName>
            <spirit:description>Number of watchpoints, minus 1. The value of 0b0000 is reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR0_EL1_31:0_19_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BRPs</spirit:name>
            <spirit:displayName>BRPs</spirit:displayName>
            <spirit:description>Number of breakpoints, minus 1. The value of 0b0000 is reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMUVer</spirit:name>
            <spirit:displayName>PMUVer</spirit:displayName>
            <spirit:description>Performance Monitors extension version. Indicates whether system register interface to Performance Monitors extension is implemented. Permitted values are:
      0000
      
      Performance Monitors extension system registers not implemented.
      
      
    
      0001
      
      Performance Monitors extension system registers implemented, PMUv3.
      
      
    
      1111
      
      IMPLEMENTATION DEFINED form of performance monitors supported, PMUv3 not supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TraceVer</spirit:name>
            <spirit:displayName>TraceVer</spirit:displayName>
            <spirit:description>Trace extension. Indicates whether system register interface to Trace extension is implemented. Permitted values are:
      0000
      
      Trace extension system registers not implemented.
      
      
    
      0001
      
      Trace extension system registers implemented.
      
      
    All other values are reserved.A value of 0b0000 only indicates that no system register interface to the trace extension is implemented. A trace extension may nevertheless be implemented without a system register interface.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DebugVer</spirit:name>
            <spirit:displayName>DebugVer</spirit:displayName>
            <spirit:description>Debug architecture version. Indicates presence of v8-A debug architecture.
      0110
      
      v8-A debug architecture.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR0_EL1_63:32</spirit:name>
          <spirit:description>Debug Feature Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD2C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR1_EL1_31:0</spirit:name>
          <spirit:description>Auxiliary Feature Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD48</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR1_EL1_63:32</spirit:name>
          <spirit:description>Auxiliary Feature Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD4C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR0_EL1_31:0</spirit:name>
          <spirit:description>Instruction Set Attribute Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD30</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="immediate">65536</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR0_EL1_31:0_31_20</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRC32</spirit:name>
            <spirit:displayName>CRC32</spirit:displayName>
            <spirit:description>CRC32 instructions in AArch64. Possible values of this field are:
      0000
      
      No CRC32 instructions implemented.
      
      
    
      0001
      
      CRC32B, CRC32H, CRC32W, CRC32X, CRC32CB, CRC32CH, CRC32CW, and CRC32CX instructions implemented.
      
      
    All other values are reserved.This field must have the same value as ID_ISAR5.CRC32. The architecture requires that if CRC32 is supported in one Execution state, it must be supported in both Execution states.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SHA2</spirit:name>
            <spirit:displayName>SHA2</spirit:displayName>
            <spirit:description>SHA2 instructions in AArch64. Possible values of this field are:
      0000
      
      No SHA2 instructions implemented.
      
      
    
      0001
      
      SHA256H, SHA256H2, SHA256SU0, and SHA256SU1 instructions implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SHA1</spirit:name>
            <spirit:displayName>SHA1</spirit:displayName>
            <spirit:description>SHA1 instructions in AArch64. Possible values of this field are:
      0000
      
      No SHA1 instructions implemented.
      
      
    
      0001
      
      SHA1C, SHA1P, SHA1M, SHA1H, SHA1SU0, and SHA1SU1 instructions implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AES</spirit:name>
            <spirit:displayName>AES</spirit:displayName>
            <spirit:description>AES instructions in AArch64. Possible values of this field are:
      0000
      
      No AES instructions implemented.
      
      
    
      0001
      
      AESE, AESD, AESMC, and AESIMC instructions implemented.
      
      
    
      0010
      
      As for 0b0001, plus PMULL/PMULL2 instructions operating on 64-bit data quantities.
      
      
    </spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR0_EL1_31:0_3_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR0_EL1_63:32</spirit:name>
          <spirit:description>Instruction Set Attribute Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD34</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR1_EL1_31:0</spirit:name>
          <spirit:description>Instruction Set Attribute Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD50</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR1_EL1_63:32</spirit:name>
          <spirit:description>Instruction Set Attribute Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD54</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR0_EL1_31:0</spirit:name>
          <spirit:description>Memory Model Feature Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD38</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00001122</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>TGran4</spirit:name>
            <spirit:displayName>TGran4</spirit:displayName>
            <spirit:description>Support for 4 Kbyte memory translation granule size. Permitted values are:
      0000
      
      4 KB granule supported.
      
      
    
      1111
      
      4 KB granule not supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGran64</spirit:name>
            <spirit:displayName>TGran64</spirit:displayName>
            <spirit:description>Support for 64 Kbyte memory translation granule size. Permitted values are:
      0000
      
      64 KB granule supported.
      
      
    
      1111
      
      64 KB granule not supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGran16</spirit:name>
            <spirit:displayName>TGran16</spirit:displayName>
            <spirit:description>Support for 16 Kbyte memory translation granule size. Permitted values are:
      0000
      
      16 KB granule not supported.
      
      
    
      0001
      
      16 KB granule supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BigEndEL0</spirit:name>
            <spirit:displayName>BigEndEL0</spirit:displayName>
            <spirit:description>Mixed-endian support at EL0 only. Permitted values are:
      0000
      
      No mixed-endian support at EL0. The SCTLR_EL1.E0E bit has a fixed value.
      
      
    
      0001
      
      Mixed-endian support at EL0. The SCTLR_EL1.E0E bit can be configured.
      
      
    All other values are reserved.This field is invalid and is RES0 if the BigEnd field, bits [11:8], is not 0b0000.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNSMem</spirit:name>
            <spirit:displayName>SNSMem</spirit:displayName>
            <spirit:description>Secure versus Non-secure Memory distinction. Permitted values are:
      0000
      
      Does not support a distinction between Secure and Non-secure Memory.
      
      
    
      0001
      
      Does support a distinction between Secure and Non-secure Memory.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BigEnd</spirit:name>
            <spirit:displayName>BigEnd</spirit:displayName>
            <spirit:description>Mixed-endian configuration support. Permitted values are:
      0000
      
      No mixed-endian support. The SCTLR_ELx.EE bits have a fixed value. See the BigEndEL0 field, bits[19:16], for whether EL0 supports mixed-endian.
      
      
    
      0001
      
      Mixed-endian support. The SCTLR_ELx.EE and SCTLR_EL1.E0E bits can be configured.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ASIDBits</spirit:name>
            <spirit:displayName>ASIDBits</spirit:displayName>
            <spirit:description>Number of ASID bits. Permitted values are:
      0000
      
      8 bits.
      
      
    
      0010
      
      16 bits.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PARange</spirit:name>
            <spirit:displayName>PARange</spirit:displayName>
            <spirit:description>Physical Address range supported. Permitted values are:
      0000
      
      32 bits, 4 GB.
      
      
    
      0001
      
      36 bits, 64 GB.
      
      
    
      0010
      
      40 bits, 1 TB.
      
      
    
      0011
      
      42 bits, 4 TB.
      
      
    
      0100
      
      44 bits, 16 TB.
      
      
    
      0101
      
      48 bits, 256 TB.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR0_EL1_63:32</spirit:name>
          <spirit:description>Memory Model Feature Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD3C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64MMFR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR1_EL1_31:0</spirit:name>
          <spirit:description>Memory Model Feature Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD58</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64MMFR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR1_EL1_63:32</spirit:name>
          <spirit:description>Memory Model Feature Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD5C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64MMFR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR0_EL1_31:0</spirit:name>
          <spirit:description>Processor Feature Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD20</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="immediate">16785954</spirit:value>
            <spirit:mask>0xF0FFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR0_EL1_31:0_31_28</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GIC</spirit:name>
            <spirit:displayName>GIC</spirit:displayName>
            <spirit:description>GIC system register interface. Permitted values are:
      0000
      
      No GIC system registers are supported.
      
      
    
      0001
      
      GICv3 system registers are supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AdvSIMD</spirit:name>
            <spirit:displayName>AdvSIMD</spirit:displayName>
            <spirit:description>Advanced SIMD. Permitted values are:
      0000
      
      Advanced SIMD is implemented.
      
      
    
      1111
      
      Advanced SIMD is not implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>FP</spirit:name>
            <spirit:displayName>FP</spirit:displayName>
            <spirit:description>Floating-point. Permitted values are:
      0000
      
      Floating-point is implemented.
      
      
    
      1111
      
      Floating-point is not implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL3</spirit:name>
            <spirit:displayName>EL3</spirit:displayName>
            <spirit:description>EL3 exception level handling. Permitted values are:
      0000
      
      EL3 is not implemented.
      
      
    
      0001
      
      EL3 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL3 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL2</spirit:name>
            <spirit:displayName>EL2</spirit:displayName>
            <spirit:description>EL2 exception level handling. Permitted values are:
      0000
      
      EL2 is not implemented.
      
      
    
      0001
      
      EL2 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL2 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL1</spirit:name>
            <spirit:displayName>EL1</spirit:displayName>
            <spirit:description>EL1 exception level handling. Permitted values are:
      0000
      
      EL1 is not implemented.
      
      
    
      0001
      
      EL1 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL1 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL0</spirit:name>
            <spirit:displayName>EL0</spirit:displayName>
            <spirit:description>EL0 exception level handling. Permitted values are:
      0000
      
      EL0 is not implemented.
      
      
    
      0001
      
      EL0 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL0 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR0_EL1_63:32</spirit:name>
          <spirit:description>Processor Feature Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD24</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR1_EL1_31:0</spirit:name>
          <spirit:description>Processor Feature Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD40</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR1_EL1_63:32</spirit:name>
          <spirit:description>Processor Feature Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD44</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>MIDR_EL1</spirit:name>
          <spirit:description>Main ID Register</spirit:description>
          <spirit:addressOffset>0xD00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x410FD034</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: MIDR_EL1 -->
          <spirit:field>
            <spirit:name>Implementer</spirit:name>
            <spirit:displayName>Implementer</spirit:displayName>
            <spirit:description>The Implementer code. This field must hold an implementer code that has been assigned by ARM.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>Variant</spirit:name>
            <spirit:displayName>Variant</spirit:displayName>
            <spirit:description>An IMPLEMENTATION DEFINED variant number. Typically this field is used to distinguish between different product variants or major revisions of a product.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>Architecture</spirit:name>
            <spirit:displayName>Architecture</spirit:displayName>
            <spirit:description> </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PartNum</spirit:name>
            <spirit:displayName>PartNum</spirit:displayName>
            <spirit:description>An IMPLEMENTATION DEFINED primary part number for the device. On processors implemented by ARM if the top four bits of the primary part number are 0x0 or 0x7 the variant and architecture are encoded differently</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>Revision</spirit:name>
            <spirit:displayName>Revision</spirit:displayName>
            <spirit:description>An IMPLEMENTATION DEFINED revision number for the device</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>OSLAR_EL1</spirit:name>
          <spirit:description>OS Lock Access Register</spirit:description>
          <spirit:addressOffset>0x300</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFE</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: OSLAR_EL1 -->
          <spirit:field>
            <spirit:name>RES0_OSLAR_EL1_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSLK</spirit:name>
            <spirit:displayName>OSLK</spirit:displayName>
            <spirit:description>On writes to OSLAR_EL1, bit[0] is copied to the OS lock.Use EDPRSR.OSLK to check the current status of the lock.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_ETM_CPU2</spirit:name>
        <spirit:displayName>APBADDR_ETM_2</spirit:displayName>
        <spirit:description>APBADDR_ETM_2</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">2359296</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_ETM_CPU2>  -->
        <spirit:register>
          <spirit:name>TRCACATR0</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 0</spirit:description>
          <spirit:addressOffset>0x480</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR0_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR0_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR1</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 1</spirit:description>
          <spirit:addressOffset>0x488</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR1_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR1_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR2</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 2</spirit:description>
          <spirit:addressOffset>0x490</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR2_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR2_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR3</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 3</spirit:description>
          <spirit:addressOffset>0x498</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR3_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR3_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR4</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 4</spirit:description>
          <spirit:addressOffset>0x4a0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR4 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR4_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR4_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR5</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 5</spirit:description>
          <spirit:addressOffset>0x4a8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR5 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR5_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR5_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR6</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 6</spirit:description>
          <spirit:addressOffset>0x4b0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR6 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR6_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR6_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACATR7</spirit:name>
          <spirit:description>Address Comparator Access Type Registers 7</spirit:description>
          <spirit:addressOffset>0x4B8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF84F3</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCACATR7 -->
          <spirit:field>
            <spirit:name>RES0_TRCACATR7_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DTBM</spirit:name>
            <spirit:displayName>DTBM</spirit:displayName>
            <spirit:description>Controls whether data address comparisons use the data address [63:56] bits:
      0
      
      The trace unit ignores the data address [63:56] bits for data address comparisons.
      
      
    
      1
      
      The trace unit uses the data address [63:56] bits for data address comparisons.
      
      
    Supported only if TRCIDR2.DASIZE indicates that the data address size is 64 bits, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATARANGE</spirit:name>
            <spirit:displayName>DATARANGE</spirit:displayName>
            <spirit:description>Controls whether a data value comparison uses the single address comparator or the address range comparator:
      0
      
      The trace unit uses the single address comparator for data value comparisons. The behavior of the address range comparator is UNPREDICTABLE.
      
      
    
      1
      
      The trace unit uses the address range comparator for data value comparisons. The behavior of the single address comparators in this pair is UNPREDICTABLE.
      
      
    The trace unit ignores this field when DATAMATCH==0b00.Supported only if the corresponding data value comparator is supported, otherwise this bit is RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATASIZE</spirit:name>
            <spirit:displayName>DATASIZE</spirit:displayName>
            <spirit:description>Controls the width of the data value comparison:
      00
      
      Byte.
      
      
    
      01
      
      Halfword.
      
      
    
      10
      
      Word.
      
      
    
      11
      
      Doubleword.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.The doubleword width is supported only if TRCIDR2.DVSIZE indicates that 64-bit values are supported. If 64-bit values are not supported, 0b11 is reserved.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DATAMATCH</spirit:name>
            <spirit:displayName>DATAMATCH</spirit:displayName>
            <spirit:description>Controls how the trace unit performs a data value comparison:
      00
      
      The trace unit does not perform a data value comparison.
      
      
    
      01
      
      The trace unit performs a data value comparison and signals a match if both values are identical.
      
      
    
      10
      
      Reserved.
      
      
    
      11
      
      The trace unit performs a data value comparison and signals a match if both values are different.
      
      
    Supported only if the corresponding data value comparator is supported, otherwise this field is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[12]Exception level 0.Bit[13]Exception level 1.Bit[14]Exception level 2.Bit[15]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether a comparison can occur for the corresponding exception level:
      0
      
      The trace unit can perform a comparison, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not perform a comparison, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[8]Exception level 0.Bit[9]Exception level 1.Bit[10]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[11]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCACATR7_7_7</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXT</spirit:name>
            <spirit:displayName>CONTEXT</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMCIDFC &gt; 0 or TRCIDR4.NUMVMIDC &gt; 0, selects a Context ID comparator or VMID comparator:
      000
      
      Comparator 0.
      
      
    
      001
      
      Comparator 1.
      
      
    
      010
      
      Comparator 2.
      
      
    and so on up to 0b111, which indicates comparator 7.The implemented width of this field is determined by the size of whichever of TRCIDR4.NUMVMIDC and TRCIDR4.NUMCIDC is larger. If the largest field is one bit long, then this field implements one bit, bit[4]. If the largest field is four bits long, then this field implements two bits, bits[5:4]. Unimplemented bits within the field are RAZ/WI.If TRCIDR4.NUMCIDFC==0 and TRCIDR4.NUMVMIDC==0, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONTEXTTYPE</spirit:name>
            <spirit:displayName>CONTEXTTYPE</spirit:displayName>
            <spirit:description>If TRCIDR4.NUMVMIDC&gt;0 and TRCIDR4.NUMCIDC&gt;0, this field controls whether the trace unit performs a Context ID comparison, a virtual machine identifier (VMID) comparison, or both comparisons:
      00
      
      The trace unit does not perform a Context ID or VMID comparison.
      
      
    
      01
      
      The trace unit performs a Context ID comparison using the Context ID comparator that the CONTEXT field specifies, and signals a match if both the Context ID comparator matches and the address comparator match.
      
      
    
      10
      
      The trace unit performs a VMID comparison using the VMID comparator that the CONTEXT field specifies, and signals a match if both the VMID comparator and the address comparator match.
      
      
    
      11
      
      The trace unit performs a Context ID comparison and a VMID comparison using the comparators that the CONTEXT field specifies, and signals a match if the Context ID comparator matches, the VMID comparator matches, and the address comparator matches.
      
      
    If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC&gt;0, bit [3] is RES0 and bit[2] controls whether the trace unit performs a Context ID comparison, as with cases 0b00 and 0b01 above.If TRCIDR4.NUMVMIDC==0 and TRCIDR4.NUMCIDC==0, both bits are RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE</spirit:name>
            <spirit:displayName>TYPE</spirit:displayName>
            <spirit:description>Controls what type of comparison the trace unit performs:
      00
      
      Instruction address.
      
      
    
      01
      
      Data load address.
      
      
    
      10
      
      Data store address.
      
      
    
      11
      
      Data load address or data store address.
      
      
    If TRCIDR4.SUPPDAC does not indicate that data address comparisons are implemented, then this field is RES0. This means that any comparison performed by this address comparator is an instruction address comparison.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR0_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 0 (low word)</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR0_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR0_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 0 (high word)</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR0_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR1_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 1 (low word)</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR1_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR1_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 1 (high word)</spirit:description>
          <spirit:addressOffset>0x40c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR1_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR2_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 2 (low word)</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR2_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR2_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 2 (high word)</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR2_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR3_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 3 (low word)</spirit:description>
          <spirit:addressOffset>0x418</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR3_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR3_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 3 (high word)</spirit:description>
          <spirit:addressOffset>0x41c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR3_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR4_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 4 (low word)</spirit:description>
          <spirit:addressOffset>0x420</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR4_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR4_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 4 (high word)</spirit:description>
          <spirit:addressOffset>0x424</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR4_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR5_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 5 (low word)</spirit:description>
          <spirit:addressOffset>0x428</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR5_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR5_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 5 (high word)</spirit:description>
          <spirit:addressOffset>0x42c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR5_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR6_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 6 (low word)</spirit:description>
          <spirit:addressOffset>0x430</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR6_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR6_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 6 (high word)</spirit:description>
          <spirit:addressOffset>0x434</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR6_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR7_31:0</spirit:name>
          <spirit:description>Address Comparator Value Registers 7 (low word)</spirit:description>
          <spirit:addressOffset>0x438</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR7_31:0 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCACVR7_63:32</spirit:name>
          <spirit:description>Address Comparator Value Registers 7 (high word)</spirit:description>
          <spirit:addressOffset>0x43c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCACVR7_63:32 -->
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Address value.The address comparators can support implementations that use multiple address widths. When the trace unit compares the ADDRESS field with an address that has a width less than this field, then it must ignore those upper bits in the comparison. For example, in a system that supports both 32-bit and 64-bit addresses, when the processor is in 32-bit state the comparator must ignore the ADDRESS[63:32] bits.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCAUTHSTATUS</spirit:name>
          <spirit:description>Authentication Status Register </spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000088</spirit:value>
            <spirit:mask>0xFFFFFFBB</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCAUTHSTATUS -->
          <spirit:field>
            <spirit:name>RES0_TRCAUTHSTATUS_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNID</spirit:name>
            <spirit:displayName>SNID</spirit:displayName>
            <spirit:description>Indicates whether the system enables the trace unit to support Secure non-invasive debug:
      00
      
      The trace unit does not implement support for Secure non-invasive debug.
      
      
    
      01
      
      Reserved.
      
      
    
      10
      
      Secure non-invasive debug is disabled.
      
      
    
      11
      
      Secure non-invasive debug is enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SID</spirit:name>
            <spirit:displayName>SID</spirit:displayName>
            <spirit:description>Indicates whether the trace unit supports Secure invasive debug:
      00
      
      The trace unit does not support Secure invasive debug.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>Indicates whether the system enables the trace unit to support Non-secure non-invasive debug:
      00
      
      The trace unit does not implement support for Non-secure non-invasive debug.
      
      
    
      01
      
      Reserved.
      
      
    
      10
      
      Non-secure non-invasive debug is disabled.
      
      
    
      11
      
      Non-secure non-invasive debug is enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSID</spirit:name>
            <spirit:displayName>NSID</spirit:displayName>
            <spirit:description>Indicates whether the trace unit supports Non-secure invasive debug:
      00
      
      The trace unit does not support Non-secure invasive debug.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCAUXCTLR</spirit:name>
          <spirit:description>Auxiliary Control Register </spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCAUXCTLR -->
          <spirit:field>
            <spirit:name>AFREADY</spirit:name>
            <spirit:displayName>Always respond to AFREADY immediately</spirit:displayName>
            <spirit:description>Always respond to AFREADY immediately. Does not have any interaction with FIFO draining even in WFI state.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IDLEACK</spirit:name>
            <spirit:displayName>Force idle-drain acknowledge</spirit:displayName>
            <spirit:description>Force idle-drain acknowledge high CPU does not wait for trace to drain before entering WFX state. When this bit is set to 1 trace unit behavior deviates from architecturally-specified behavior.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OVFLW</spirit:name>
            <spirit:displayName>Overflow if synchronization is not completed</spirit:displayName>
            <spirit:description>Force an overflow if synchronization is not completed when second synchronization becomes due. When this bit is set to 1 the trace unit behavior deviates from architecturally-specified behavior.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SYNCDELAY</spirit:name>
            <spirit:displayName>Delay periodic synchronization</spirit:displayName>
            <spirit:description>Delay periodic synchronization if FIFO is more than half-full.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TSNODELAY</spirit:name>
            <spirit:displayName>Do not delay timestamp insertion</spirit:displayName>
            <spirit:description>Do not delay timestamp insertion based on FIFO depth.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AUTHNOFLUSH</spirit:name>
            <spirit:displayName>De-assertion of authentication inputs</spirit:displayName>
            <spirit:description>Do not flush trace on de-assertion of authentication inputs. When this bit is set to 1 the trace unit behavior deviates from architecturally-specified behavior.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCAUXCTLR_6_6</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COREIFEN</spirit:name>
            <spirit:displayName>Core interface enabled</spirit:displayName>
            <spirit:description>Keep core interface enabled regardless of trace enable register state</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCAUXCTLR_31_8</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCBBCTLR</spirit:name>
          <spirit:description>Branch Broadcast Control Register </spirit:description>
          <spirit:addressOffset>0x03C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCBBCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCBBCTLR_31_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>23</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MODE</spirit:name>
            <spirit:displayName>MODE</spirit:displayName>
            <spirit:description>Mode bit:
      0
      
      Exclude mode. Branch broadcasting is not enabled in the address range that RANGE defines. If RANGE==0 then branch broadcasting is enabled for the entire memory map.
      
      
    
      1
      
      Include mode. Branch broadcasting is enabled in the address range that RANGE defines. If RANGE==0 then the branch broadcasting behavior is UNPREDICTABLE.
      
      
    </spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RANGE</spirit:name>
            <spirit:displayName>RANGE</spirit:displayName>
            <spirit:description>Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each bit represents an address range comparator pair, so bit[n] controls the selection of address range comparator pair n. If bit[n] is:
      0
      
      The address range that address range comparator pair n defines is not selected.
      
      
    
      1
      
      The address range that address range comparator pair n defines is selected.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCCCTLR</spirit:name>
          <spirit:description>Cycle Count Control Register </spirit:description>
          <spirit:addressOffset>0x038</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFF000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCCCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCCCCTLR_31_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>THRESHOLD</spirit:name>
            <spirit:displayName>THRESHOLD</spirit:displayName>
            <spirit:description>Sets the threshold value for instruction trace cycle counting.The minimum threshold value that can be programmed into THRESHOLD is given in TRCIDR3.CCITMIN.Writing a value of zero might cause UNPREDICTABLE behaviour.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDCCTLR0</spirit:name>
          <spirit:description>Context ID Comparator Control Register 0 </spirit:description>
          <spirit:addressOffset>0x680</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDCCTLR0 -->
          <spirit:field>
            <spirit:name>COMP_n</spirit:name>
            <spirit:displayName>COMP&lt;n&gt;</spirit:displayName>
            <spirit:description>Controls the mask value that the trace unit applies to TRCCIDCVRn. Each bit in this field corresponds to a byte in TRCCIDCVRn. When a bit is:
      0
      
      The trace unit includes the relevant byte in TRCCIDCVRn when it performs the Context ID comparison.
      
      
    
      1
      
      The trace unit ignores the relevant byte in TRCCIDCVRn when it performs the Context ID comparison.
      
      
    Supported only if TRCIDR4.NUMCIDC &gt; n, otherwise the field is RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDCVR0</spirit:name>
          <spirit:description>Context ID Comparator Value Register 0 </spirit:description>
          <spirit:addressOffset>0x600</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCCIDCVR0 -->
          <spirit:field>
            <spirit:name>VALUE</spirit:name>
            <spirit:displayName>VALUE</spirit:displayName>
            <spirit:description>Context ID value. The implemented width of this field is IMPLEMENTATION DEFINED and is set by TRCIDR2.CIDSIZE. Unimplemented bits are RAZ/WI.After a processor reset, the ETM architecture assumes that the Context ID is zero until the processor updates the Context ID.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR0</spirit:name>
          <spirit:description>Component Identification Register 0 </spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR1</spirit:name>
          <spirit:description>Component Identification Register 1 </spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, to indicate that the ETM is a debug component, with CoreSight architecture compliant management registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR2</spirit:name>
          <spirit:description>Component Identification Register 2 </spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCIDR3</spirit:name>
          <spirit:description>Component Identification Register 3 </spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCIDR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCCIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCLAIMCLR</spirit:name>
          <spirit:description>Claim Tag Clear Register </spirit:description>
          <spirit:addressOffset>0xFA4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCLAIMCLR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCCLAIMCLR_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLR</spirit:name>
            <spirit:displayName>CLR</spirit:displayName>
            <spirit:description>Clears bits in the claim tag and determines the current value of the claim tag.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCLAIMSET</spirit:name>
          <spirit:description>Claim Tag Set Register </spirit:description>
          <spirit:addressOffset>0xFA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000F</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCLAIMSET -->
          <spirit:field>
            <spirit:name>RESERVED_TRCCLAIMSET_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SET</spirit:name>
            <spirit:displayName>SET</spirit:displayName>
            <spirit:description>Sets bits in the claim tag and determines the number of claim tag bits implemented.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTCTLR0</spirit:name>
          <spirit:description>Counter Control Register 0 </spirit:description>
          <spirit:addressOffset>0x150</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTCTLR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTCTLR0_31_18</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTCHAIN_n</spirit:name>
            <spirit:displayName>CNTCHAIN&lt;n&gt;</spirit:displayName>
            <spirit:description>For TRCCNTCTLR3 and TRCCNTCTLR1, controls whether counter &lt;n&gt; decrements when a reload event occurs for counter &lt;n-1&gt;:
      0
      
      
      
      
    
      1
      
      
      
      
    For TRCCNTCTLR2 and TRCCNTCTLR0, this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDSELF_n</spirit:name>
            <spirit:displayName>RLDSELF&lt;n&gt;</spirit:displayName>
            <spirit:description>Controls whether a reload event occurs for counter &lt;n&gt;, when counter &lt;n&gt; reaches zero:
      0
      
      The trace unit does not generate a reload event.
      
      
    
      1
      
      The trace unit generates a reload event for counter &lt;n&gt;, provided that the event resource that CNTEVENT&lt;n&gt; specifies is active.
      
      
    </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDEVENT_n</spirit:name>
            <spirit:displayName>RLDEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes a reload event for counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTEVENT_n</spirit:name>
            <spirit:displayName>CNTEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes counter &lt;n&gt; to decrement.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTCTLR1</spirit:name>
          <spirit:description>Counter Control Register 1 </spirit:description>
          <spirit:addressOffset>0x154</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFD7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTCTLR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTCTLR1_31_18</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTCHAIN_n</spirit:name>
            <spirit:displayName>CNTCHAIN&lt;n&gt;</spirit:displayName>
            <spirit:description>For TRCCNTCTLR3 and TRCCNTCTLR1, controls whether counter &lt;n&gt; decrements when a reload event occurs for counter &lt;n-1&gt;:
      0
      
      
      
      
    
      1
      
      
      
      
    For TRCCNTCTLR2 and TRCCNTCTLR0, this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDSELF_n</spirit:name>
            <spirit:displayName>RLDSELF&lt;n&gt;</spirit:displayName>
            <spirit:description>Controls whether a reload event occurs for counter &lt;n&gt;, when counter &lt;n&gt; reaches zero:
      0
      
      The trace unit does not generate a reload event.
      
      
    
      1
      
      The trace unit generates a reload event for counter &lt;n&gt;, provided that the event resource that CNTEVENT&lt;n&gt; specifies is active.
      
      
    </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RLDEVENT_n</spirit:name>
            <spirit:displayName>RLDEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes a reload event for counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CNTEVENT_n</spirit:name>
            <spirit:displayName>CNTEVENT&lt;n&gt;</spirit:displayName>
            <spirit:description>Selects an event, that when it occurs causes counter &lt;n&gt; to decrement.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTRLDVR0</spirit:name>
          <spirit:description>Counter Reload Value Registers 0</spirit:description>
          <spirit:addressOffset>0x140</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTRLDVR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTRLDVR0_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the reload value for counter &lt;n&gt;. When a reload event occurs for counter &lt;n&gt; then the trace unit copies the VALUE&lt;n&gt; field into counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTRLDVR1</spirit:name>
          <spirit:description>Counter Reload Value Registers 1</spirit:description>
          <spirit:addressOffset>0x144</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTRLDVR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTRLDVR1_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the reload value for counter &lt;n&gt;. When a reload event occurs for counter &lt;n&gt; then the trace unit copies the VALUE&lt;n&gt; field into counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTVR0</spirit:name>
          <spirit:description>Counter Value Registers 0</spirit:description>
          <spirit:addressOffset>0x160</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTVR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTVR0_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the count value of counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCNTVR1</spirit:name>
          <spirit:description>Counter Value Registers 1</spirit:description>
          <spirit:addressOffset>0x164</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF0000</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCNTVR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCCNTVR1_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE_n</spirit:name>
            <spirit:displayName>VALUE&lt;n&gt;</spirit:displayName>
            <spirit:description>Contains the count value of counter &lt;n&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCCONFIGR</spirit:name>
          <spirit:description>Trace Configuration Register </spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000001</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCCONFIGR -->
          <spirit:field>
            <spirit:name>RES0_TRCCONFIGR_31_18</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DV</spirit:name>
            <spirit:displayName>DV</spirit:displayName>
            <spirit:description>Data value tracing bit:
      0
      
      Data value tracing is disabled.
      
      
    
      1
      
      Data value tracing is enabled when INSTP0 is not 0b00.
      
      
    TRCIDR0.TRCDATA indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DA</spirit:name>
            <spirit:displayName>DA</spirit:displayName>
            <spirit:description>Data address tracing bit:
      0
      
      Data address tracing is disabled.
      
      
    
      1
      
      Data address tracing is enabled when INSTP0 is not 0b00.
      
      
    TRCIDR0.TRCDATA indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCCONFIGR_15_15</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>QE</spirit:name>
            <spirit:displayName>QE</spirit:displayName>
            <spirit:description>Q element enable field:
      00
      
      Q elements are disabled.
      
      
    
      01
      
      Q elements with instruction counts are enabled. Q elements without instruction counts are disabled.
      
      
    
      11
      
      Q elements with and without instruction counts are enabled.
      
      
    The value 0b10 is reserved.TRCIDR0.QSUPP indicates which values of this field are implemented.TRCCONFIGR.QE must be set to 0b00 if any of the following are true:TRCCONFIGR.INSTP0 is not 0b00.TRCCONFIGR.COND is not 0b000.TRCCONFIGR.BB is not 0.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RS</spirit:name>
            <spirit:displayName>RS</spirit:displayName>
            <spirit:description>Return stack enable bit.
      0
      
      Return stack is disabled.
      
      
    
      1
      
      Return stack is enabled.
      
      
    TRCIDR0.RETSTACK indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TS</spirit:name>
            <spirit:displayName>TS</spirit:displayName>
            <spirit:description>Global timestamp tracing bit:
      0
      
      Global timestamp tracing is disabled.
      
      
    
      1
      
      Global timestamp tracing is enabled. TRCTSCTLR controls the insertion of timestamps in the trace.
      
      
    TRCIDR0.TSSIZE indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COND</spirit:name>
            <spirit:displayName>COND</spirit:displayName>
            <spirit:description>Conditional instruction tracing bit. The permitted values are:
      000
      
      Conditional instruction tracing is disabled.
      
      
    
      001
      
      Conditional load instructions are traced.
      
      
    
      010
      
      Conditional store instructions are traced.
      
      
    
      011
      
      Conditional load and store instructions are traced.
      
      
    
      111
      
      All conditional instructions are traced.
      
      
    All other values are reserved.TRCIDR0.TRCCOND indicates whether this field is supported. If it is not supported then this field is RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VMID</spirit:name>
            <spirit:displayName>VMID</spirit:displayName>
            <spirit:description>VMID tracing bit:
      0
      
      VMID tracing is disabled.
      
      
    
      1
      
      VMID tracing is enabled.
      
      
    TRCIDR2.VMIDSIZE indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CID</spirit:name>
            <spirit:displayName>CID</spirit:displayName>
            <spirit:description>Context ID tracing bit:
      0
      
      Context ID tracing is disabled.
      
      
    
      1
      
      Context ID tracing is enabled.
      
      
    TRCIDR2.CIDSIZE indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCCONFIGR_5_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCI</spirit:name>
            <spirit:displayName>CCI</spirit:displayName>
            <spirit:description>Cycle counting instruction trace bit:
      0
      
      Cycle counting in the instruction trace is disabled.
      
      
    
      1
      
      Cycle counting in the instruction trace is enabled. TRCCCCTLR controls the threshold value for cycle counting.
      
      
    TRCIDR0.TRCCCI indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BB</spirit:name>
            <spirit:displayName>BB</spirit:displayName>
            <spirit:description>Branch broadcast mode bit:
      0
      
      Branch broadcast mode is disabled.
      
      
    
      1
      
      Branch broadcast mode is enabled. TRCBBCTLR controls which regions of memory are enabled to use branch broadcasting.
      
      
    TRCIDR0.TRCBB indicates whether this bit is supported. If it is not supported then this bit is RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INSTP0</spirit:name>
            <spirit:displayName>INSTP0</spirit:displayName>
            <spirit:description>Instruction P0 bit. This field controls whether load and store instructions are traced as P0 instructions:
      00
      
      Do not trace load and store instructions as P0 instructions.
      
      
    
      01
      
      Trace load instructions as P0 instructions.
      
      
    
      10
      
      Trace store instructions as P0 instructions.
      
      
    
      11
      
      Trace load and store instructions as P0 instructions.
      
      
    TRCIDR0.INSTP0 indicates whether this field is supported. If it is not supported then this field is RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES1_TRCCONFIGR_0_0</spirit:name>
            <spirit:displayName>1</spirit:displayName>
            <spirit:description>Reserved, RES1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVAFF0</spirit:name>
          <spirit:description>Device Affinity Register 0 </spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000002</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVAFF0 -->
          <spirit:field>
            <spirit:name>MPIDR_EL1_31:0</spirit:name>
            <spirit:displayName>MPIDR_EL1[31:0]</spirit:displayName>
            <spirit:description>Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVAFF1</spirit:name>
          <spirit:description>Device Affinity Register 1 </spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVAFF1 -->
          <spirit:field>
            <spirit:name>MPIDR_EL1_63:32</spirit:name>
            <spirit:displayName>MPIDR_EL1[63:32]</spirit:displayName>
            <spirit:description>Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVARCH</spirit:name>
          <spirit:description>Device Architecture Register </spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47704A13</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For trace, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is RAO.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For trace, the revision defined by ETMv4 is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For trace, bits [15:12] are the architecture version, 0x4; bits [11:0] are the architecture part number, 0xA13.This corresponds to trace architecture version ETMv4.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVID</spirit:name>
          <spirit:description>Device ID Register </spirit:description>
          <spirit:addressOffset>0xFC8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCDEVID -->
          <spirit:field>
            <spirit:name>DEVID</spirit:name>
            <spirit:displayName>DEVID</spirit:displayName>
            <spirit:description>Indicates the capabilities of the trace unit. The implemented width of this field and its bit assignments are IMPLEMENTATION DEFINED. Unimplemented bits are RAZ/WI.If a component is configurable then ARM recommends that this field can also indicate which configuration options are implemented that differ from the standard configuration.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCDEVTYPE</spirit:name>
          <spirit:description>Device Type Register </spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000013</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_TRCDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Returns 0x1, to indicate that the ETM generates processor trace.All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAIN</spirit:name>
            <spirit:displayName>MAIN</spirit:displayName>
            <spirit:description>Returns 0x3, to indicate that the ETM is a trace source.All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCEVENTCTL0R</spirit:name>
          <spirit:description>Event Control 0 Register </spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0x70707070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCEVENTCTL0R -->
          <spirit:field>
            <spirit:name>TYPE3</spirit:name>
            <spirit:displayName>TYPE3</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 3</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_30_28</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL3</spirit:name>
            <spirit:displayName>SEL3</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE3</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE2</spirit:name>
            <spirit:displayName>TYPE2</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 2</spirit:description>
            <spirit:bitOffset>23</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_22_20</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL2</spirit:name>
            <spirit:displayName>SEL2</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE2</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE1</spirit:name>
            <spirit:displayName>TYPE1</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 1</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_14_12</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL1</spirit:name>
            <spirit:displayName>SEL1</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE1</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TYPE0</spirit:name>
            <spirit:displayName>TYPE0</spirit:displayName>
            <spirit:description>Selects the resource type for trace event 0</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL0R_6_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL0</spirit:name>
            <spirit:displayName>SEL0</spirit:displayName>
            <spirit:description>Selects the resource number based on the value of TYPE0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCEVENTCTL1R</spirit:name>
          <spirit:description>Event Control 1 Register </spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFE7F0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCEVENTCTL1R -->
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL1R_31_13</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>19</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LPOVERRIDE</spirit:name>
            <spirit:displayName>LPOVERRIDE</spirit:displayName>
            <spirit:description>Low power state behavior override</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATB</spirit:name>
            <spirit:displayName>ATB</spirit:displayName>
            <spirit:description>ATB trigger enable</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEVENTCTL1R_10_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EN</spirit:name>
            <spirit:displayName>EN</spirit:displayName>
            <spirit:description>One bit per event to enable generation of an event element in the instruction trace stream when the selected event occurs</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCEXTINSELR</spirit:name>
          <spirit:description>External Input Select Register </spirit:description>
          <spirit:addressOffset>0x120</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0x80808080</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCEXTINSELR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_31_29</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL3</spirit:name>
            <spirit:displayName>SEL3</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 3.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_23_21</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL2</spirit:name>
            <spirit:displayName>SEL2</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 2</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_15_13</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL1</spirit:name>
            <spirit:displayName>SEL1</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 1</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCEXTINSELR_7_5</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SEL0</spirit:name>
            <spirit:displayName>SEL0</spirit:displayName>
            <spirit:description>Selects an event from the external input bus for External Input Resource 0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR0</spirit:name>
          <spirit:description>ID Register 0 </spirit:description>
          <spirit:addressOffset>0x1E0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x28000EA1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_31_30</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COMMOPT</spirit:name>
            <spirit:displayName>COMMOPT</spirit:displayName>
            <spirit:description>Conditional instruction tracing support bit. Indicates if the trace unit supports conditional instruction tracing:
      0
      
      Conditional instruction tracing is not supported.
      
      
    
      1
      
      Conditional instruction tracing is supported, so TRCCONFIGR.COND is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TSSIZE</spirit:name>
            <spirit:displayName>TSSIZE</spirit:displayName>
            <spirit:description>Global timestamp size field. The permitted values are:
      00000
      
      Global timestamping is not implemented.
      
      
    
      00110
      
      Implementation supports a maximum global timestamp of 48bits.
      
      
    
      01000
      
      Implementation supports a maximum global timestamp of 64bits.
      
      
    All other values are reserved.When global timestamping is implemented then TRCCONFIGR.TS and TRCTSCTLR are supported.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_23_17</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>QSUPP</spirit:name>
            <spirit:displayName>QSUPP</spirit:displayName>
            <spirit:description>Q element support field. The permitted values are:
      00
      
      Q element support is not implemented. TRCCONFIGR.QE is RES0.
      
      
    
      01
      
      Q element support is implemented, and only supports Q elements with instruction counts. TRCCONFIGR.QE can only take the values 0b00 or 0b01.
      
      
    
      10
      
      Q element support is implemented, and only supports Q elements without instruction counts. TRCCONFIGR.QE can only take the values 0b00 or 0b11.
      
      
    
      11
      
      Q element support is implemented, and supports both Q elements with instruction counts and Q elements without instruction counts. TRCCONFIGR.QE is fully implemented.
      
      
    </spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>QFILT</spirit:name>
            <spirit:displayName>QFILT</spirit:displayName>
            <spirit:description>Q element filtering support field. The permitted values are:
      0
      
      Q element filtering is not implemented.
      
      
    
      1
      
      Q element filtering is implemented. TRCQCTLR is implemented.
      
      
    When QSUPP==0b00, this field is RES0.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CONDTYPE</spirit:name>
            <spirit:displayName>CONDTYPE</spirit:displayName>
            <spirit:description>Conditional tracing field. The permitted values are:
      00
      
      The trace unit indicates only if a conditional instruction is a pass or fail.
      
      
    
      01
      
      The trace unit provides the Current Program Status Register (CPSR) status, for a conditional instruction.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMEVENT</spirit:name>
            <spirit:displayName>NUMEVENT</spirit:displayName>
            <spirit:description>Number of events field. Indicates how many events the trace unit supports:
      00
      
      The trace unit supports 1 event.
      
      
    
      01
      
      The trace unit supports 2 events.
      
      
    
      10
      
      The trace unit supports 3 events.
      
      
    
      11
      
      The trace unit supports 4 events.
      
      
    This field controls how many fields are supported in TRCEVENTCTL0R, and indicates the size of TRCEVENTCTL1R.INSTEN.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RETSTACK</spirit:name>
            <spirit:displayName>RETSTACK</spirit:displayName>
            <spirit:description>Return stack bit. Indicates if the implementation supports a return stack:
      0
      
      Return stack is not implemented.
      
      
    
      1
      
      Return stack is implemented, so TRCCONFIGR.RS is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_8_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCCCI</spirit:name>
            <spirit:displayName>TRCCCI</spirit:displayName>
            <spirit:description>Cycle counting instruction bit. Indicates if the trace unit supports cycle counting for instructions:
      0
      
      Cycle counting in the instruction trace is not implemented.
      
      
    
      1
      
      Cycle counting in the instruction trace is implemented, so TRCCONFIGR.CCI and TRCCCCTLR are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCCOND</spirit:name>
            <spirit:displayName>TRCCOND</spirit:displayName>
            <spirit:description>Conditional instruction tracing support bit. Indicates if the trace unit supports conditional instruction tracing:
      0
      
      Conditional instruction tracing is not supported.
      
      
    
      1
      
      Conditional instruction tracing is supported, so TRCCONFIGR.COND is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCBB</spirit:name>
            <spirit:displayName>TRCBB</spirit:displayName>
            <spirit:description>Branch broadcast tracing support bit. Indicates if the trace unit supports branch broadcast tracing:
      0
      
      Branch broadcast tracing is not supported.
      
      
    
      1
      
      Branch broadcast tracing is supported, so TRCCONFIGR.BB and TRCBBCTLR are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCDATA</spirit:name>
            <spirit:displayName>TRCDATA</spirit:displayName>
            <spirit:description>Conditional tracing field. The permitted values are:
      00
      
      Data tracing is not supported.
      
      
    
      11
      
      Tracing of data addresses and data values is supported, so TRCCONFIGR.DA, TRCCONFIGR.DV, TRCSTALLCTLR.DATADISCARD, TRCSTALLCTLR.INSTPRIORITY, TRCSTALLCTLR.DSTALL, and TRCEVENTCTL1R.DATAEN are supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INSTP0</spirit:name>
            <spirit:displayName>INSTP0</spirit:displayName>
            <spirit:description>P0 tracing support field. The permitted values are:
      00
      
      Tracing of load and store instructions as P0 elements is not supported.
      
      
    
      11
      
      Tracing of load and store instructions as P0 elements is supported, so TRCCONFIGR.INSTP0 is supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR0_0_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR1</spirit:name>
          <spirit:description>ID Register 1 </spirit:description>
          <spirit:addressOffset>0x1E4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x4100F404</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR1 -->
          <spirit:field>
            <spirit:name>DESIGNER</spirit:name>
            <spirit:displayName>DESIGNER</spirit:displayName>
            <spirit:description>Indicates which company designed the trace unit. The permitted values are:
      01000001
      
      ARM Limited.
      
      
    
      01000100
      
      Digital Equipment Corporation.
      
      
    
      01001101
      
      Motorola, Freescale Semiconductor Inc.
      
      
    
      01010001
      
      QUALCOMM Inc.
      
      
    
      01010110
      
      Marvell Semiconductor Inc.
      
      
    
      01101001
      
      Intel Corporation.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR1_23_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES1_TRCIDR1_15_12</spirit:name>
            <spirit:displayName>1</spirit:displayName>
            <spirit:description>Reserved, RES1.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCARCHMAJ</spirit:name>
            <spirit:displayName>TRCARCHMAJ</spirit:displayName>
            <spirit:description>Indicates the major version of the ETM architecture. The permitted value is:
      100
      
      ETMv4.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCARCHMIN</spirit:name>
            <spirit:displayName>TRCARCHMIN</spirit:displayName>
            <spirit:description>Indicates the minor version of the ETM architecture. The permitted value is:
      0
      
      ETMv4 minor version 0.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Returns an IMPLEMENTATION DEFINED value that identifies the revision of the trace registers and the OS Save and Restore registers.ARM recommends:That the initial implementation sets REVISION==0x0 and the field then increments for any subsequent implementations. However, it is acceptable to omit some values or use another scheme to identify the revision number.That TRCPIDR2.REVISION==TRCIDR1.REVISION. However, in situations where it is difficult to align these fields, such as with a metal layer fix, then it is acceptable to change the REVISION fields independently.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR10</spirit:name>
          <spirit:description>ID Register 10 </spirit:description>
          <spirit:addressOffset>0x188</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR10 -->
          <spirit:field>
            <spirit:name>NUMP1KEY</spirit:name>
            <spirit:displayName>NUMP1KEY</spirit:displayName>
            <spirit:description>Indicates the number of P1 right-hand keys that the trace unit can use. The number includes normal and special keys.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR11</spirit:name>
          <spirit:description>ID Register 11 </spirit:description>
          <spirit:addressOffset>0x18C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR11 -->
          <spirit:field>
            <spirit:name>NUMP1SPC</spirit:name>
            <spirit:displayName>NUMP1SPC</spirit:displayName>
            <spirit:description>Indicates the number of special P1 right-hand keys that the trace unit can use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR12</spirit:name>
          <spirit:description>ID Register 12 </spirit:description>
          <spirit:addressOffset>0x190</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR12 -->
          <spirit:field>
            <spirit:name>NUMCONDKEY</spirit:name>
            <spirit:displayName>NUMCONDKEY</spirit:displayName>
            <spirit:description>Indicates the number of conditional instruction right-hand keys that the trace unit can use. The number includes normal and special keys.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR13</spirit:name>
          <spirit:description>ID Register 13 </spirit:description>
          <spirit:addressOffset>0x194</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR13 -->
          <spirit:field>
            <spirit:name>NUMCONDSPC</spirit:name>
            <spirit:displayName>NUMCONDSPC</spirit:displayName>
            <spirit:description>Indicates the number of special conditional instruction right-hand keys that the trace unit can use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR2</spirit:name>
          <spirit:description>ID Register 2 </spirit:description>
          <spirit:addressOffset>0x1E8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000488</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCIDR2_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCSIZE</spirit:name>
            <spirit:displayName>CCSIZE</spirit:displayName>
            <spirit:description>Indicates the size of the cycle counter in bits minus 12.
      0000
      
      The cycle counter is 12 bits in length.
      
      
    
      0001
      
      The cycle counter is 13 bits in length.
      
      
    and so on up to 0b1000, indicating the cycle counter is 20 bits in length.All other values are reserved.If cycle counting is not implemented, as indicated by TRCIDR0.TRCCCI, this field is 0b0000.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DVSIZE</spirit:name>
            <spirit:displayName>DVSIZE</spirit:displayName>
            <spirit:description>Indicates the data value size in bytes. The permitted values are:
      00000
      
      Data value tracing is not supported. Therefore, an implementation must also set TRCIDR0.TRCDATA==0b00.
      
      
    
      00100
      
      Maximum of 32-bit data value size.
      
      
    
      01000
      
      Maximum of 64-bit data value size.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DASIZE</spirit:name>
            <spirit:displayName>DASIZE</spirit:displayName>
            <spirit:description>Indicates the data address size in bytes. The permitted values are:
      00000
      
      Data address tracing is not supported. Therefore, an implementation must also set TRCIDR0.TRCDATA==0b00.
      
      
    
      00100
      
      Maximum of 32-bit data address size.
      
      
    
      01000
      
      Maximum of 64-bit data address size.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VMIDSIZE</spirit:name>
            <spirit:displayName>VMIDSIZE</spirit:displayName>
            <spirit:description>Indicates the VMID size. The permitted values are:
      00000
      
      VMID tracing is not supported.
      
      
    
      00001
      
      Maximum of 8-bit VMID size, so TRCCONFIGR.VMID is supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CIDSIZE</spirit:name>
            <spirit:displayName>CIDSIZE</spirit:displayName>
            <spirit:description>Indicates the Context ID size. The permitted values are:
      00000
      
      Context ID tracing is not supported.
      
      
    
      00100
      
      Maximum of 32-bit Context ID size, so TRCCONFIGR.CID is supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IASIZE</spirit:name>
            <spirit:displayName>IASIZE</spirit:displayName>
            <spirit:description>Indicates the instruction address size. The permitted values are:
      00100
      
      Maximum of 32-bit address size.
      
      
    
      01000
      
      Maximum of 64-bit address size.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR3</spirit:name>
          <spirit:description>ID Register 3 </spirit:description>
          <spirit:addressOffset>0x1EC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0D7B0004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR3 -->
          <spirit:field>
            <spirit:name>NOOVERFLOW</spirit:name>
            <spirit:displayName>NOOVERFLOW</spirit:displayName>
            <spirit:description>Indicates if TRCSTALLCTLR.NOOVERFLOW is supported:
      0
      
      TRCSTALLCTLR.NOOVERFLOW is not supported, or STALLCTL==0.
      
      
    
      1
      
      TRCSTALLCTLR.NOOVERFLOW is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMPROC</spirit:name>
            <spirit:displayName>NUMPROC</spirit:displayName>
            <spirit:description>Indicates the number of processors available for tracing. The possible values are:
      000
      
      The trace unit can trace one processor.
      
      
    
      001
      
      The trace unit can trace two processors.
      
      
    
      010
      
      The trace unit can trace three processors.
      
      
    and so on up to 0b111, which indicates the trace unit can trace eight processors.This field sets the maximum value of TRCPROCSELR.PROCSEL.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SYSSTALL</spirit:name>
            <spirit:displayName>SYSSTALL</spirit:displayName>
            <spirit:description>Indicates if the implementation can support stall control:
      0
      
      The system does not support stall control of the processor.
      
      
    
      1
      
      The system can support stall control of the processor.
      
      
    The system supports stalling of the processor only when SYSSTALL==1 and STALLCTL==1.</spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STALLCTL</spirit:name>
            <spirit:displayName>STALLCTL</spirit:displayName>
            <spirit:description>Indicates if TRCSTALLCTLR is supported:
      0
      
      TRCSTALLCTLR is not supported.
      
      
    
      1
      
      TRCSTALLCTLR is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SYNCPR</spirit:name>
            <spirit:displayName>SYNCPR</spirit:displayName>
            <spirit:description>Indicates if an implementation has a fixed synchronization period:
      0
      
      TRCSYNCPR is read-write so software can change the synchronization period.
      
      
    
      1
      
      TRCSYNCPR is read-only so the synchronization period is fixed.
      
      
    </spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCERR</spirit:name>
            <spirit:displayName>TRCERR</spirit:displayName>
            <spirit:description>Indicates if TRCVICTLR.TRCERR is supported:
      0
      
      TRCVICTLR.TRCERR is not supported
      
      
    
      1
      
      TRCVICTLR.TRCERR is supported.
      
      
    </spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit indicates whether instruction tracing is supported for the corresponding exception level:
      0
      
      In Non-secure state, exception level n is not supported so the corresponding bits in TRCACATRn.EXLEVEL_NS and TRCVICTLR.EXLEVEL_NS are not supported.
      
      
    
      1
      
      In Non-secure state, exception level n is supported so the corresponding bits in TRCACATRn.EXLEVEL_NS and TRCVICTLR.EXLEVEL_NS are supported.
      
      
    The exception levels are:Bit[20]Exception level 0.Bit[21]Exception level 1.Bit[22]Exception level 2.Bit[23]SBZ. EXLEVEL_NS[3] is never implemented.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit indicates whether instruction tracing is supported for the corresponding exception level:
      0
      
      In Secure state, exception level n is not supported so the corresponding bits in TRCACATRn.EXLEVEL_S and TRCVICTLR.EXLEVEL_S are not supported.
      
      
    
      1
      
      In Secure state, exception level n is supported so the corresponding bits in TRCACATRn.EXLEVEL_S and TRCVICTLR.EXLEVEL_S are supported.
      
      
    The exception levels are:Bit[16]Exception level 0.Bit[17]Exception level 1.Bit[18]SBZ. EXLEVEL_S[2] is never implemented.Bit[19]Exception level 3.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR3_15_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CCITMIN</spirit:name>
            <spirit:displayName>CCITMIN</spirit:displayName>
            <spirit:description>Indicates the minimum value that can be programmed in TRCCCCTLR.THRESHOLD.When cycle counting in the instruction trace is supported, that is TRCIDR0.TRCCCI==1, then the minimum value of this field is 0x001, otherwise it is 0x000.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR4</spirit:name>
          <spirit:description>ID Register 4 </spirit:description>
          <spirit:addressOffset>0x1F0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x11170004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR4 -->
          <spirit:field>
            <spirit:name>NUMVMIDC</spirit:name>
            <spirit:displayName>NUMVMIDC</spirit:displayName>
            <spirit:description>Indicates the number of VMID comparators that are available for tracing. The permitted values are:
      0000
      
      No VMID comparators are available.
      
      
    
      0001
      
      The implementation has one VMID comparator.
      
      
    
      0010
      
      The implementation has two VMID comparators.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight VMID comparators.All other values are reserved.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMCIDC</spirit:name>
            <spirit:displayName>NUMCIDC</spirit:displayName>
            <spirit:description>Indicates the number of Context ID comparators that are available for tracing. The permitted values are:
      0000
      
      No Context ID comparators are available.
      
      
    
      0001
      
      The implementation has one Context ID comparator.
      
      
    
      0010
      
      The implementation has two Context ID comparators.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight Context ID comparators.All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMSSCC</spirit:name>
            <spirit:displayName>NUMSSCC</spirit:displayName>
            <spirit:description>Indicates the number of single-shot comparator controls that are available for tracing. The permitted values are:
      0000
      
      No single-shot comparator controls are available.
      
      
    
      0001
      
      The implementation has one single-shot comparator control.
      
      
    
      0010
      
      The implementation has two single-shot comparator controls.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight single-shot comparator controls.All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMRSPAIR</spirit:name>
            <spirit:displayName>NUMRSPAIR</spirit:displayName>
            <spirit:description>Indicates the number of resource selection pairs that are available for tracing. The permitted values are:
      0000
      
      The implementation has one resource selection pair.
      
      
    
      0001
      
      The implementation has two resource selection pairs.
      
      
    
      0010
      
      The implementation has three resource selection pairs.
      
      
    and so on up to 0b1111, which indicates that the implementation has 16 resource selection pairs.Implementations always have at least one resource selection pair so that they can support the FALSE and TRUE resource selectors, 0 and 1.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMPC</spirit:name>
            <spirit:displayName>NUMPC</spirit:displayName>
            <spirit:description>Indicates the number of processor comparator inputs that are available for tracing. The permitted values are:
      0000
      
      No processor comparator inputs are available.
      
      
    
      0001
      
      The implementation has one processor comparator input.
      
      
    
      0010
      
      The implementation has two processor comparator inputs.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight processor comparator inputs.All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR4_11_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUPPDAC</spirit:name>
            <spirit:displayName>SUPPDAC</spirit:displayName>
            <spirit:description>Indicates if the implementation can support data address comparisons:
      0
      
      The implementation does not support data address comparisons.
      
      
    
      1
      
      The implementation can support data address comparisons
      
      
    </spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMDVC</spirit:name>
            <spirit:displayName>NUMDVC</spirit:displayName>
            <spirit:description>Indicates the number of data value comparators that are available for tracing. The permitted values are:
      0000
      
      No data value comparators are available.
      
      
    
      0001
      
      The implementation has one data value comparator.
      
      
    
      0010
      
      The implementation has two data value comparators.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight data value comparators.All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMACPAIRS</spirit:name>
            <spirit:displayName>NUMACPAIRS</spirit:displayName>
            <spirit:description>Indicates the number of address comparator pairs that are available for tracing. The permitted values are:
      0000
      
      No address comparator pairs are available.
      
      
    
      0001
      
      The implementation has one address comparator pair.
      
      
    
      0010
      
      The implementation has two address comparator pairs.
      
      
    and so on up to 0b1000, which indicates that the implementation has eight address comparator pairs.All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR5</spirit:name>
          <spirit:description>ID Register 5 </spirit:description>
          <spirit:addressOffset>0x1F4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x28C7081E</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCIDR5 -->
          <spirit:field>
            <spirit:name>REDFUNCNTR</spirit:name>
            <spirit:displayName>REDFUNCNTR</spirit:displayName>
            <spirit:description>Indicates if the reduced function counter is implemented:
      0
      
      The reduced function counter is not supported.
      
      
    
      1
      
      Counter 0 is implemented as a reduced function counter.
      
      
    </spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMCNTR</spirit:name>
            <spirit:displayName>NUMCNTR</spirit:displayName>
            <spirit:description>Indicates the number of counters that are available for tracing. The permitted values are:
      000
      
      No counters are available.
      
      
    
      001
      
      The implementation has one counter.
      
      
    
      010
      
      The implementation has two counters.
      
      
    
      011
      
      The implementation has three counters.
      
      
    
      100
      
      The implementation has four counters.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMSEQSTATE</spirit:name>
            <spirit:displayName>NUMSEQSTATE</spirit:displayName>
            <spirit:description>Indicates the number of sequencer states that are implemented. The permitted values are:
      000
      
      No sequencer states are implemented.
      
      
    
      100
      
      The implementation has four sequencer states.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR5_24_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LPOVERRIDE</spirit:name>
            <spirit:displayName>LPOVERRIDE</spirit:displayName>
            <spirit:description>Indicates if the implementation can support low-power state override:
      0
      
      The implementation does not support low-power state override.
      
      
    
      1
      
      The implementation supports low-power state override, and the TRCEVENTCTL1R.LPOVERRIDE field is implemented.
      
      
    The trace unit must support low-power state override if it can enter a low-power mode where the resources and event trace generation are disabled.</spirit:description>
            <spirit:bitOffset>23</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATBTRIG</spirit:name>
            <spirit:displayName>ATBTRIG</spirit:displayName>
            <spirit:description>Indicates if the implementation can support ATB triggers:
      0
      
      The implementation does not support ATB triggers.
      
      
    
      1
      
      The implementation supports ATB triggers, and the TRCEVENTCTL1R.ATBTRIG field is implemented.
      
      
    </spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRACEIDSIZE</spirit:name>
            <spirit:displayName>TRACEIDSIZE</spirit:displayName>
            <spirit:description>Indicates the trace ID width. The permitted value is:
      111
      
      The implementation supports a 7-bit trace ID. This sets the width of the TRCTRACEIDR.TRACEID field.
      
      
    All other values are reserved.The CoreSight ATB requires a 7-bit trace ID width.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCIDR5_15_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMEXTINSEL</spirit:name>
            <spirit:displayName>NUMEXTINSEL</spirit:displayName>
            <spirit:description>Indicates how many external input select resources are implemented. The permitted values are:
      000
      
      No external input select resources are available. If NUMEXTINSEL is zero, NUMEXTIN must also be zero.
      
      
    
      001
      
      The implementation has one external input select resource.
      
      
    
      010
      
      The implementation has two external input select resources.
      
      
    
      011
      
      The implementation has three external input select resources.
      
      
    
      100
      
      The implementation has four external input select resources.
      
      
    All other values are reserved.See TRCEXTINSELR for how to select an input select resource.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMEXTIN</spirit:name>
            <spirit:displayName>NUMEXTIN</spirit:displayName>
            <spirit:description>Indicates how many external inputs are implemented. The permitted values are:
      000000000
      
      No external inputs are available. If NUMEXTIN is zero, NUMEXTINSEL must also be zero.
      
      
    
      000000001
      
      The implementation has one external input.
      
      
    
      000000010
      
      The implementation has two external inputs.
      
      
    and so on up to 0b100000000, which indicates that the implementation has 256 external inputs.All other values &gt;0b100000000 are reserved.See TRCEXTINSELR for how to select an external input.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>9</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR8</spirit:name>
          <spirit:description>ID Register 8 </spirit:description>
          <spirit:addressOffset>0x180</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR8 -->
          <spirit:field>
            <spirit:name>MAXSPEC</spirit:name>
            <spirit:displayName>MAXSPEC</spirit:displayName>
            <spirit:description>Indicates the maximum speculation depth of the instruction trace stream. This is the maximum number of P0 elements in the trace stream that can be speculative at any time.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIDR9</spirit:name>
          <spirit:description>ID Register 9 </spirit:description>
          <spirit:addressOffset>0x184</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCIDR9 -->
          <spirit:field>
            <spirit:name>NUMP0KEY</spirit:name>
            <spirit:displayName>NUMP0KEY</spirit:displayName>
            <spirit:description>Indicates the number of P0 right-hand keys that the trace unit can use. A value of 0 or 1 indicates one P0 key.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCIMSPEC0</spirit:name>
          <spirit:description>Implementation Specific Register 0 </spirit:description>
          <spirit:addressOffset>0x1C0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: TRCIMSPEC0 -->
          <spirit:field>
            <spirit:name>RES0_TRCIMSPEC0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EN</spirit:name>
            <spirit:displayName>EN</spirit:displayName>
            <spirit:description>If SUPPORT is not 0b0000, controls whether the IMPLEMENTATION DEFINED features are enabled. The permitted values are:
      0000
      
      The IMPLEMENTATION DEFINED features are not enabled. The trace unit must behave as if the IMPLEMENTATION DEFINED features are not supported.
      
      
    and any other value, which indicates that the trace unit behavior is IMPLEMENTATION DEFINED.If SUPPORT is 0b0000, this field is RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUPPORT</spirit:name>
            <spirit:displayName>SUPPORT</spirit:displayName>
            <spirit:description>Indicates whether the implementation supports IMPLEMENTATION DEFINED features. The permitted values are:
      0000
      
      No IMPLEMENTATION DEFINED features are supported. The EN field is RES0.
      
      
    and any other value, which indicates that IMPLEMENTATION DEFINED features are supported. Use of these values requires written permission from ARM.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITATBIDR</spirit:name>
          <spirit:description>Integration ATB Identification Register </spirit:description>
          <spirit:addressOffset>0xEE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCITATBIDR -->
          <spirit:field>
            <spirit:name>ID</spirit:name>
            <spirit:displayName>ID</spirit:displayName>
            <spirit:description>Drives the ATIDMn[6:0] output pins</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCITATBIDR_31_7</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>25</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITCTRL</spirit:name>
          <spirit:description>Integration Mode Control Register </spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCITCTRL -->
          <spirit:field>
            <spirit:name>RES0_TRCITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ITEN</spirit:name>
            <spirit:displayName>ITEN</spirit:displayName>
            <spirit:description>Integration mode enable bit:
      0
      
      The trace unit is not in integration mode.
      
      
    
      1
      
      The trace unit is in integration mode. This mode enables a debug agent to perform topology detection, and System-on-Chip (SoC) test software to perform integration testing.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITIATBINR</spirit:name>
          <spirit:description>Integration Instruction ATB In Register </spirit:description>
          <spirit:addressOffset>0xEF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCITIATBINR -->
          <spirit:field>
            <spirit:name>ATREADYM</spirit:name>
            <spirit:displayName>ATREADYM</spirit:displayName>
            <spirit:description>Returns the value of the ATREADYMn input pin</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AFVALIDM</spirit:name>
            <spirit:displayName>AFVALIDM</spirit:displayName>
            <spirit:description>Returns the value of the AFVALIDMn input pin</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCITIATBINR_31_2</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved. Read undefined.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITIATBOUTR</spirit:name>
          <spirit:description>Integration Instruction ATB Out Register </spirit:description>
          <spirit:addressOffset>0xEFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCITIATBOUTR -->
          <spirit:field>
            <spirit:name>ATVALID</spirit:name>
            <spirit:displayName>ATVALID</spirit:displayName>
            <spirit:description>Drives the ATVALIDMn output pin</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AFREADY</spirit:name>
            <spirit:displayName>AFREADY</spirit:displayName>
            <spirit:description>Drives the AFREADYMn output pin</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCITIATBOUTR_7_2</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved. Read undefined.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BYTES</spirit:name>
            <spirit:displayName>BYTES</spirit:displayName>
            <spirit:description>Drives the ATBYTESMn[1:0] output pins</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCITIATBOUTR_31_10</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved. Read undefined.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>22</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCITIDATAR</spirit:name>
          <spirit:description>Integration Instruction ATB Data Register </spirit:description>
          <spirit:addressOffset>0xEEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCITIDATAR -->
          <spirit:field>
            <spirit:name>ATDATAM_0</spirit:name>
            <spirit:displayName>ATDATAM_0</spirit:displayName>
            <spirit:description>Drives the ATDATAM[0] output</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_7</spirit:name>
            <spirit:displayName>ATDATAM_7</spirit:displayName>
            <spirit:description>Drives the ATDATAM[7] output</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_15</spirit:name>
            <spirit:displayName>ATDATAM_15</spirit:displayName>
            <spirit:description>Drives the ATDATAM[15] output</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_23</spirit:name>
            <spirit:displayName>ATDATAM_23</spirit:displayName>
            <spirit:description>Drives the ATDATAM[23] output</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ATDATAM_31</spirit:name>
            <spirit:displayName>ATDATAM_31</spirit:displayName>
            <spirit:description>Drives the ATDATAM[31] output</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCITIDATAR_31_5</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>27</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCLAR</spirit:name>
          <spirit:description>Software Lock Access Register </spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCLAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Writing the key value 0xC5ACCE55 to this field clears the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register sets the lock, disabling write accesses to this component's registers through a memory mapped interface.Software can use the Software Lock to prevent accidental modification of the trace unit registers by software being debugged. For example, software that accidentally initializes an incorrect region of memory might disable the trace unit and make it impossible to trace the software.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCLSR</spirit:name>
          <spirit:description>Software Lock Status Register </spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCLSR -->
          <spirit:field>
            <spirit:name>RES0_TRCLSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. Possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. RAO.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCOSLAR</spirit:name>
          <spirit:description>OS Lock Access Register </spirit:description>
          <spirit:addressOffset>0x300</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: TRCOSLAR -->
          <spirit:field>
            <spirit:name>RES0_TRCOSLAR_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LOCK</spirit:name>
            <spirit:displayName>LOCK</spirit:displayName>
            <spirit:description>OS Lock control bit:
      0
      
      Unlocks the OS Lock.
      
      
    
      1
      
      Locks the OS Lock. This setting disables the trace unit.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCOSLSR</spirit:name>
          <spirit:description>OS Lock Status Register </spirit:description>
          <spirit:addressOffset>0x304</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000A</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCOSLSR -->
          <spirit:field>
            <spirit:name>RES0_TRCOSLSR_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>Indicates whether the OS Lock is implemented.This bit is RES1, which indicates that the OS Lock is always implemented.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BIT32</spirit:name>
            <spirit:displayName>32BIT</spirit:displayName>
            <spirit:description>This bit is RES0, which indicates that software must perform a 32-bit write to update the TRCOSLAR.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LOCKED</spirit:name>
            <spirit:displayName>LOCKED</spirit:displayName>
            <spirit:description>OS Lock status bit:
      0
      
      The OS Lock is unlocked.
      
      
    
      1
      
      The OS Lock is locked.
      
      
    When the trace unit core power domain is powered down the value is UNKNOWN. The TRCPDSR indicates if the trace unit core power domain is powered down.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCOSLSR_0_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPDCR</spirit:name>
          <spirit:description>Power Down Control Register </spirit:description>
          <spirit:addressOffset>0x310</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPDCR -->
          <spirit:field>
            <spirit:name>RES0_TRCPDCR_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PU</spirit:name>
            <spirit:displayName>PU</spirit:displayName>
            <spirit:description>Powerup request bit:
      0
      
      The system can remove power from the trace unit. The TRCPDSR indicates if the trace unit is powered down.
      
      
    
      1
      
      The system must provide power to the trace unit.
      
      
    Typically, a trace unit drives a signal representing the value of this bit to a power controller to request that the trace unit core power domain is powered up. However, if the trace unit and the processor are in the same power domain then the implementation might combine the PU status with a signal from the processor.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCPDCR_2_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPDSR</spirit:name>
          <spirit:description>Power Down Status Register </spirit:description>
          <spirit:addressOffset>0x314</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCPDSR -->
          <spirit:field>
            <spirit:name>RES0_TRCPDSR_31_6</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>26</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LOCKED</spirit:name>
            <spirit:displayName>LOCKED</spirit:displayName>
            <spirit:description>OS Lock status bit:
      0
      
      The OS Lock is unlocked.
      
      
    
      1
      
      The OS Lock is locked.
      
      
    The value is UNKNOWN when the trace unit core power domain is powered down, that is, when POWER==0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCPDSR_4_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STICKYPD</spirit:name>
            <spirit:displayName>STICKYPD</spirit:displayName>
            <spirit:description>Sticky powerdown status bit. Indicates whether the trace register state is valid:
      0
      
      If POWER==1 then the state of TRCOSLSR and the trace registers are valid. If POWER==0 then it is UNKNOWN whether the state of TRCOSLSR and the trace registers are valid.
      
      
    
      1
      
      The state of TRCOSLSR and the trace registers might not be valid. The trace unit sets this bit to 1 if either the trace unit is reset, or the power to the trace unit core power domain is removed and the trace register state is not valid.
      
      
    After this register is read, if the Software Lock is unlocked and the trace unit core power domain is powered up, then the trace unit sets this bit to 0. The TRCLAR controls whether the Software Lock is locked.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>POWER</spirit:name>
            <spirit:displayName>POWER</spirit:displayName>
            <spirit:description>Power status bit:
      0
      
      The trace unit core power domain is not powered. The trace registers are not accessible and they all return an error response.
      
      
    
      1
      
      The trace unit core power domain is powered. The trace registers are accessible.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR0</spirit:name>
          <spirit:description>Peripheral Identification Register 0 </spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000005D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, bits[7:0].</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR1</spirit:name>
          <spirit:description>Peripheral Identification Register 1 </spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B9</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, bits[3:0] of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, bits[11:8].</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR2</spirit:name>
          <spirit:description>Peripheral Identification Register 2 </spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>The IMPLEMENTATION DEFINED revision number for the ETM implementation. See also TRCIDR1.REVISION.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR3</spirit:name>
          <spirit:description>Peripheral Identification Register 3 </spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>The IMPLEMENTATION DEFINED manufacturing revision number for the implementation. After silicon is available, if metal fixes are necessary, the manufacturer can alter the top metal layer so that this field can indicate any post-fab silicon changes.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR4</spirit:name>
          <spirit:description>Peripheral Identification Register 4 </spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RES0. This indicates that the ETM memory map occupies 4KB.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR5</spirit:name>
          <spirit:description>Peripheral Identification Register 5</spirit:description>
          <spirit:addressOffset>0xFD4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR5 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR5_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCPIDR5_7_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>RES0, reserved for future use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR6</spirit:name>
          <spirit:description>Peripheral Identification Register 6</spirit:description>
          <spirit:addressOffset>0xFD8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR6 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR6_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCPIDR6_7_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>RES0, reserved for future use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPIDR7</spirit:name>
          <spirit:description>Peripheral Identification Register 7</spirit:description>
          <spirit:addressOffset>0xFDC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPIDR7 -->
          <spirit:field>
            <spirit:name>RES0_TRCPIDR7_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCPIDR7_7_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>RES0, reserved for future use.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCPRGCTLR</spirit:name>
          <spirit:description>Programming Control Register</spirit:description>
          <spirit:addressOffset>0x004</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCPRGCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCPRGCTLR_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EN</spirit:name>
            <spirit:displayName>EN</spirit:displayName>
            <spirit:description>Trace unit enable bit. Possible values are:
      0
      
      The trace unit is disabled. All trace resources are inactive and no trace is generated.
      
      
    
      1
      
      The trace unit is enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR10</spirit:name>
          <spirit:description>Resource Selection Control Registers 10</spirit:description>
          <spirit:addressOffset>0x228</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR10 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR10_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR11</spirit:name>
          <spirit:description>Resource Selection Control Registers 11</spirit:description>
          <spirit:addressOffset>0x22c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR11 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR11_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR12</spirit:name>
          <spirit:description>Resource Selection Control Registers 12</spirit:description>
          <spirit:addressOffset>0x230</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR12 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR12_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR13</spirit:name>
          <spirit:description>Resource Selection Control Registers 13</spirit:description>
          <spirit:addressOffset>0x234</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR13 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR13_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR14</spirit:name>
          <spirit:description>Resource Selection Control Registers 14</spirit:description>
          <spirit:addressOffset>0x238</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR14 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR14_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR15</spirit:name>
          <spirit:description>Resource Selection Control Registers 15</spirit:description>
          <spirit:addressOffset>0x23c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR15 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR15_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR2</spirit:name>
          <spirit:description>Resource Selection Control Registers 2</spirit:description>
          <spirit:addressOffset>0x208</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR2_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR3</spirit:name>
          <spirit:description>Resource Selection Control Registers 3</spirit:description>
          <spirit:addressOffset>0x20c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR3 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR3_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR4</spirit:name>
          <spirit:description>Resource Selection Control Registers 4</spirit:description>
          <spirit:addressOffset>0x210</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR4 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR4_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR5</spirit:name>
          <spirit:description>Resource Selection Control Registers 5</spirit:description>
          <spirit:addressOffset>0x214</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR5 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR5_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR6</spirit:name>
          <spirit:description>Resource Selection Control Registers 6</spirit:description>
          <spirit:addressOffset>0x218</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR6 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR6_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR7</spirit:name>
          <spirit:description>Resource Selection Control Registers 7</spirit:description>
          <spirit:addressOffset>0x21c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR7 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR7_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR8</spirit:name>
          <spirit:description>Resource Selection Control Registers 8</spirit:description>
          <spirit:addressOffset>0x220</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR8 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR8_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCRSCTLR9</spirit:name>
          <spirit:description>Resource Selection Control Registers 9</spirit:description>
          <spirit:addressOffset>0x224</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFC8FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCRSCTLR9 -->
          <spirit:field>
            <spirit:name>RES0_TRCRSCTLR9_31_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAIRINV</spirit:name>
            <spirit:displayName>PAIRINV</spirit:displayName>
            <spirit:description>If n is an even number, controls whether the combined result from a resource pair is inverted:
      0
      
      The combined result is not inverted.
      
      
    
      1
      
      The combined result is inverted.
      
      
    If n is an odd number, this field is RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INV</spirit:name>
            <spirit:displayName>INV</spirit:displayName>
            <spirit:description>Controls whether the resource that GROUP and SELECT selects is inverted:
      0
      
      The selected resource is not inverted.
      
      
    
      1
      
      The selected resource is inverted.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GROUP</spirit:name>
            <spirit:displayName>GROUP</spirit:displayName>
            <spirit:description>Selects a group of resources. Possible values are:
      0000
      
      For SELECT bits 0 to 3, selects external input selector 0 to 3; other bits are reserved.
      
      
    
      0001
      
      For SELECT bits 0 to 7, selects processor comparator inputs 0 to 7; other bits are reserved.
      
      
    
      0010
      
      For SELECT bits 0 to 3, selects counter at zero 0 to 3; for SELECT bits 4 to 7, selects sequencer states 0 to 3; other bits are reserved.
      
      
    
      0011
      
      For SELECT bits 0 to 7, selects single-shot comparator control 0 to 7; other bits are reserved.
      
      
    
      0100
      
      For SELECT bits 0 to 15, selects single address comparator 0 to 15.
      
      
    
      0101
      
      For SELECT bits 0 to 7, selects address range comparator 0 to 7; other bits are reserved.
      
      
    
      0110
      
      For SELECT bits 0 to 7, selects Context ID comparator 0 to 7; other bits are reserved.
      
      
    
      0111
      
      For SELECT bits 0 to 7, selects VMID comparator 0 to 7; other bits are reserved.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SELECT</spirit:name>
            <spirit:displayName>SELECT</spirit:displayName>
            <spirit:description>Selects one or more resources from the group that the GROUP field selects. Each bit represents a resource from the selected group.See the GROUP field description for details.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQEVR0</spirit:name>
          <spirit:description>Sequencer State Transition Control Registers 0</spirit:description>
          <spirit:addressOffset>0x100</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQEVR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQEVR0_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>B_n</spirit:name>
            <spirit:displayName>B&lt;n&gt;</spirit:displayName>
            <spirit:description>Backward field. Contains an event number. When the event occurs then the sequencer state moves from state n+1 to state n.For example, for TRCSEQEVR2, if B2==0x14 then when event 0x14 occurs, the sequencer moves from state 3 to state 2.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_n</spirit:name>
            <spirit:displayName>F&lt;n&gt;</spirit:displayName>
            <spirit:description>Forward field. Contains an event number. When the event occurs then the sequencer state moves from state n to state n+1.For example, for TRCSEQEVR1, if F1==0x12 then when event 0x12 occurs, the sequencer moves from state 1 to state 2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQEVR1</spirit:name>
          <spirit:description>Sequencer State Transition Control Registers 1</spirit:description>
          <spirit:addressOffset>0x104</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQEVR1 -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQEVR1_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>B_n</spirit:name>
            <spirit:displayName>B&lt;n&gt;</spirit:displayName>
            <spirit:description>Backward field. Contains an event number. When the event occurs then the sequencer state moves from state n+1 to state n.For example, for TRCSEQEVR2, if B2==0x14 then when event 0x14 occurs, the sequencer moves from state 3 to state 2.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_n</spirit:name>
            <spirit:displayName>F&lt;n&gt;</spirit:displayName>
            <spirit:description>Forward field. Contains an event number. When the event occurs then the sequencer state moves from state n to state n+1.For example, for TRCSEQEVR1, if F1==0x12 then when event 0x12 occurs, the sequencer moves from state 1 to state 2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQEVR2</spirit:name>
          <spirit:description>Sequencer State Transition Control Registers 2</spirit:description>
          <spirit:addressOffset>0x108</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFF7070</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQEVR2 -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQEVR2_31_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>B_n</spirit:name>
            <spirit:displayName>B&lt;n&gt;</spirit:displayName>
            <spirit:description>Backward field. Contains an event number. When the event occurs then the sequencer state moves from state n+1 to state n.For example, for TRCSEQEVR2, if B2==0x14 then when event 0x14 occurs, the sequencer moves from state 3 to state 2.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_n</spirit:name>
            <spirit:displayName>F&lt;n&gt;</spirit:displayName>
            <spirit:description>Forward field. Contains an event number. When the event occurs then the sequencer state moves from state n to state n+1.For example, for TRCSEQEVR1, if F1==0x12 then when event 0x12 occurs, the sequencer moves from state 1 to state 2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQRSTEVR</spirit:name>
          <spirit:description>Sequencer Reset Control Register </spirit:description>
          <spirit:addressOffset>0x118</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF70</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQRSTEVR -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQRSTEVR_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RST</spirit:name>
            <spirit:displayName>RST</spirit:displayName>
            <spirit:description>Contains an event number. When the event occurs then the sequencer state moves to state 0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSEQSTR</spirit:name>
          <spirit:description>Sequencer State Register </spirit:description>
          <spirit:addressOffset>0x11C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSEQSTR -->
          <spirit:field>
            <spirit:name>RES0_TRCSEQSTR_31_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STATE</spirit:name>
            <spirit:displayName>STATE</spirit:displayName>
            <spirit:description>Sets or returns the state of the sequencer:
      00
      
      State 0.
      
      
    
      01
      
      State 1.
      
      
    
      10
      
      State 2.
      
      
    
      11
      
      State 3.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSSCCR0</spirit:name>
          <spirit:description>Single-Shot Comparator Control Register 0 </spirit:description>
          <spirit:addressOffset>0x280</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSSCCR0 -->
          <spirit:field>
            <spirit:name>RES0_TRCSSCCR0_31_25</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RST</spirit:name>
            <spirit:displayName>RST</spirit:displayName>
            <spirit:description>Controls whether the single-shot comparator resource is reset when it fires.
      0
      
      When the single-shot comparator resource fires, it is not reset.
      
      
    
      1
      
      When the single-shot comparator resource fires, it is reset. This enables the single-shot comparator resource to fire multiple times.
      
      
    </spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARC</spirit:name>
            <spirit:displayName>ARC</spirit:displayName>
            <spirit:description>Selects one or more address range comparators for single-shot control.Each bit represents an address range comparator pair, so bit[n-16] controls the selection of address range comparator pair n-16. If bit[n-16] is:
      0
      
      The address range comparator pair n-16 is not selected for single-shot control.
      
      
    
      1
      
      The address range comparator pair n-16 is selected for single-shot control.
      
      
    The width of this field is IMPLEMENTATION DEFINED. The field contains a number of implemented bits equal to TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SAC</spirit:name>
            <spirit:displayName>SAC</spirit:displayName>
            <spirit:description>Selects one or more single address comparators for single-shot control.Each bit represents a single address comparator, so bit[n] controls the selection of single address comparator n. If bit[n] is:
      0
      
      The single address comparator n, is not selected for single-shot control.
      
      
    
      1
      
      The single address comparator n, is selected for single-shot control.
      
      
    The width of this field is IMPLEMENTATION DEFINED. The field contains a number of implemented bits equal to 2 x TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSSCSR0</spirit:name>
          <spirit:description>Single-Shot Comparator Status Register 0 </spirit:description>
          <spirit:addressOffset>0x2A0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000001</spirit:value>
            <spirit:mask>0x7FFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSSCSR0 -->
          <spirit:field>
            <spirit:name>STATUS</spirit:name>
            <spirit:displayName>STATUS</spirit:displayName>
            <spirit:description>Single-shot status bit. Indicates if any of the comparators that TRCSSCCRn.SAC or TRCSSCCRn.ARC selects have matched:
      0
      
      No match has occurred.
      
      
    
      1
      
      One or more matches has occurred. If TRCSSCCRn.RST==0 then there is only one match and no more matches are possible, and software must reset this bit to 0 to re-enable the single-shot control.
      
      
    STATUS must be written to set an initial state when configuring the trace unit, if the single-shot comparator is to be used.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCSSCSR0_30_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DV</spirit:name>
            <spirit:displayName>DV</spirit:displayName>
            <spirit:description>Data value comparator support bit. Indicates if the trace unit supports data address with data value comparisons:
      0
      
      Single-shot data address with data value comparisons are not supported.
      
      
    
      1
      
      Single-shot data address with data value comparisons are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DA</spirit:name>
            <spirit:displayName>DA</spirit:displayName>
            <spirit:description>Data address comparator support bit. Indicates if the trace unit supports data address comparisons:
      0
      
      Single-shot data address comparisons are not supported.
      
      
    
      1
      
      Single-shot data address comparisons are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INST</spirit:name>
            <spirit:displayName>INST</spirit:displayName>
            <spirit:description>Instruction address comparator support bit. Indicates if the trace unit supports instruction address comparisons:
      0
      
      Single-shot instruction address comparisons are not supported.
      
      
    
      1
      
      Single-shot instruction address comparisons are supported.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSTALLCTLR</spirit:name>
          <spirit:description>Stall Control Register </spirit:description>
          <spirit:addressOffset>0x02C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSTALLCTLR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCSTALLCTLR_31_9</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>23</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ISTALL</spirit:name>
            <spirit:displayName>Instruction stall bit</spirit:displayName>
            <spirit:description>Controls if the trace unit can stall the processor when the instruction trace buffer space is less than LEVEL</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCSTALLCTLR_7_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LEVEL</spirit:name>
            <spirit:displayName>Threshold level field</spirit:displayName>
            <spirit:description>The field can support 4 monotonic levels from 0b00 to 0b11</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESERVED_TRCSTALLCTLR_1_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSTATR</spirit:name>
          <spirit:description>Status Register </spirit:description>
          <spirit:addressOffset>0x00C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: TRCSTATR -->
          <spirit:field>
            <spirit:name>RES0_TRCSTATR_31_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMSTABLE</spirit:name>
            <spirit:displayName>PMSTABLE</spirit:displayName>
            <spirit:description>Programmer's model stable bit:
      0
      
      The programmer's model is not stable.
      
      
    
      1
      
      The programmer's model is stable. When polled, the trace unit trace registers return stable data.
      
      
    The programmer's model is stable when all of the following are true:TRCPRGCTLR.EN==0 or the OS Lock is locked.Reads from trace unit registers return stable data.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IDLE</spirit:name>
            <spirit:displayName>IDLE</spirit:displayName>
            <spirit:description>Idle status bit:
      0
      
      The trace unit is not idle.
      
      
    
      1
      
      The trace unit is idle.
      
      
    The trace unit is idle when all of the following are true:TRCPRGCTLR.EN==0 or the OS Lock is locked.The trace unit is drained of any trace.With the exception of the programming interfaces, all external interfaces on the trace unit are quiescent.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCSYNCPR</spirit:name>
          <spirit:description>Synchronization Period Register </spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFE0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCSYNCPR -->
          <spirit:field>
            <spirit:name>RES0_TRCSYNCPR_31_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>27</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PERIOD</spirit:name>
            <spirit:displayName>PERIOD</spirit:displayName>
            <spirit:description>Controls how many bytes of trace, the sum of instruction and data, that a trace unit can generate before a periodic trace synchronization request occurs. The number of bytes is always a power of two and the permitted values are:
      00000
      
      Periodic trace synchronization requests are disabled. This setting does not disable other types of trace synchronization request.
      
      
    
      01000
      
      Periodic trace synchronization request occurs after 2^8, or 256, bytes of trace.
      
      
    
      01001
      
      Periodic trace synchronization request occurs after 2^9, or 512, bytes of trace.
      
      
    
      01010
      
      Periodic trace synchronization request occurs after 2^10, or 1024, bytes of trace.
      
      
    and so on up to 0b10100, for which the request occurs after 2^20, or 1048576, bytes of trace.Values between 0b00001 and 0b001111 are reserved, as are values from 0b10101 onwards.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCTRACEIDR</spirit:name>
          <spirit:description>Trace ID Register </spirit:description>
          <spirit:addressOffset>0x040</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCTRACEIDR -->
          <spirit:field>
            <spirit:name>RESERVED_TRCTRACEIDR_31_7</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>25</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRACEID</spirit:name>
            <spirit:displayName>TRACEID</spirit:displayName>
            <spirit:description>Trace ID value. When only instruction tracing is enabled this provides the trace ID.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCTSCTLR</spirit:name>
          <spirit:description>Global Timestamp Control Register </spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF70</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCTSCTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCTSCTLR_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EVENT</spirit:name>
            <spirit:displayName>EVENT</spirit:displayName>
            <spirit:description>An event selector. When the selected event is triggered, the trace unit inserts a global timestamp into the trace streams.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVICTLR</spirit:name>
          <spirit:description>ViewInst Main Control Register </spirit:description>
          <spirit:addressOffset>0x080</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFF84F370</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVICTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCVICTLR_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_NS</spirit:name>
            <spirit:displayName>EXLEVEL_NS</spirit:displayName>
            <spirit:description>In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level:
      0
      
      The trace unit generates instruction trace, in Non-secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not generate instruction trace, in Non-secure state, for exception level n.
      
      
    The exception levels are:Bit[20]Exception level 0.Bit[21]Exception level 1.Bit[22]Exception level 2.Bit[23]RAZ/WI. EXLEVEL_NS[3] is never implemented.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_NS. If instruction tracing is not implemented for a given exception level, the corresponding bit in this field is not implemented. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXLEVEL_S</spirit:name>
            <spirit:displayName>EXLEVEL_S</spirit:displayName>
            <spirit:description>In Secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level:
      0
      
      The trace unit generates instruction trace, in Secure state, for exception level n.
      
      
    
      1
      
      The trace unit does not generate instruction trace, in Secure state, for exception level n.
      
      
    The exception levels are:Bit[16]Exception level 0.Bit[17]Exception level 1.Bit[18]RAZ/WI. EXLEVEL_S[2] is never implemented.Bit[19]Exception level 3.The content of the field is IMPLEMENTATION DEFINED and is set by the value of TRCIDR3.EXLEVEL_S. If instruction tracing is not implemented for a given exception level, the corresponding bit in this field is not implemented. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCVICTLR_15_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCERR</spirit:name>
            <spirit:displayName>TRCERR</spirit:displayName>
            <spirit:description>If TRCIDR3.TRCERR==1, this bit controls whether a trace unit must trace a system error exception:
      0
      
      The trace unit does not trace a system error exception unless it traces the exception or instruction immediately prior to the system error exception.
      
      
    
      1
      
      The trace unit always traces a system error exception.
      
      
    If TRCIDR3.TRCERR==0, this bit is RES0.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRCRESET</spirit:name>
            <spirit:displayName>TRCRESET</spirit:displayName>
            <spirit:description>Controls whether a trace unit must trace a Reset exception:
      0
      
      The trace unit does not trace a Reset exception unless it traces the exception or instruction immediately prior to the Reset exception.
      
      
    
      1
      
      The trace unit always traces a Reset exception.
      
      
    </spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSSTATUS</spirit:name>
            <spirit:displayName>SSSTATUS</spirit:displayName>
            <spirit:description>IF TRCIDR4.NUMACPAIRS&gt;0 or TRCIDR.NUMPC&gt;0, this bit returns the status of the start-stop logic:
      0
      
      The start-stop logic is in the stopped state.
      
      
    
      1
      
      The start-stop logic is in the started state.
      
      
    The bit only returns stable data when TRCSTATR.PMSTABLE==1.Before software enables the trace unit, TRCPRGCTLR.EN==1, it must write to this bit to set the initial state of the start-stop logic. If the start-stop logic is not used then set this bit to 1. ARM recommends that the value of this bit is set before each trace run begins.If TRCIDR4.NUMACPAIRS==0 and TRCIDR4.NUMPC==0, this bit is RES0, indicating that the start-stop logic is not implemented.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCVICTLR_8_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EVENT</spirit:name>
            <spirit:displayName>EVENT</spirit:displayName>
            <spirit:description>An event selector. [TODO: Add the bit assignments for EVENT fields into the descriptions directly?]</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVIIECTLR</spirit:name>
          <spirit:description>ViewInst Include-Exclude Control Register </spirit:description>
          <spirit:addressOffset>0x084</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFF0FFF0</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVIIECTLR -->
          <spirit:field>
            <spirit:name>RES0_TRCVIIECTLR_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXCLUDE</spirit:name>
            <spirit:displayName>EXCLUDE</spirit:displayName>
            <spirit:description>
      0
      
      
      
      
    
      1
      
      
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_TRCVIIECTLR_15_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INCLUDE</spirit:name>
            <spirit:displayName>INCLUDE</spirit:displayName>
            <spirit:description>Include range field. Selects which address range comparator pairs are in use with ViewInst include control. Each bit represents an address range comparator pair, so bit[m] controls the selection of address range comparator pair m. If bit[m] is:
      0
      
      The address range that address range comparator pair m defines is not selected for ViewInst include control.
      
      
    
      1
      
      The address range that address range comparator pair m defines is selected for ViewInst include control.
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.Selecting no include comparators indicates that all instructions are included by default. The exclude control then indicates which ranges are excluded.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVISSCTLR</spirit:name>
          <spirit:description>ViewInst Start-Stop Control Register </spirit:description>
          <spirit:addressOffset>0x088</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFF00FF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVISSCTLR -->
          <spirit:field>
            <spirit:name>STOP</spirit:name>
            <spirit:displayName>STOP</spirit:displayName>
            <spirit:description>Selects which single address comparators are in use with ViewInst start-stop control, for the purpose of stopping trace. Each bit represents a single address comparator, so bit[m] controls the selection of single address comparator m-16. If bit[m] is:
      0
      
      The single address comparator m-16 is not selected as a stop resource.
      
      
    
      1
      
      The single address comparator m-16 is selected as a stop resource.
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of 2 x TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>START</spirit:name>
            <spirit:displayName>START</spirit:displayName>
            <spirit:description>Selects which single address comparators are in use with ViewInst start-stop control, for the purpose of starting trace. Each bit represents a single address comparator, so bit[n] controls the selection of single address comparator n. If bit[n] is:
      0
      
      The single address comparator n is not selected as a start resource.
      
      
    
      1
      
      The single address comparator n is selected as a start resource.
      
      
    The implemented width of the field, n, is IMPLEMENTATION DEFINED and is set by the value of 2 x TRCIDR4.NUMACPAIRS. Unimplemented bits are RAZ/WI.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>TRCVMIDCVR0</spirit:name>
          <spirit:description>VMID Comparator Value Register 0 </spirit:description>
          <spirit:addressOffset>0x640</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: TRCVMIDCVR0 -->
          <spirit:field>
            <spirit:name>RESERVED_TRCVMIDCVR0_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VALUE</spirit:name>
            <spirit:displayName>VALUE</spirit:displayName>
            <spirit:description>Contains a VMID value.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_CTI_CPU1</spirit:name>
        <spirit:displayName>APBADDR_CTI_1</spirit:displayName>
        <spirit:description>APBADDR_CTI_1</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">1179648</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_CTI_CPU1>  -->
        <spirit:register>
          <spirit:name>ASICCTL</spirit:name>
          <spirit:description>CTI External Multiplexor Control register</spirit:description>
          <spirit:addressOffset>0x144</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ASICCTL -->
          <spirit:field>
            <spirit:name>RES0_ASICCTL_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ASICCTL</spirit:name>
            <spirit:displayName>ASICCTL</spirit:displayName>
            <spirit:description>IMPLEMENTATION DEFINED ASIC control. Provides a control for external multiplexing of additional triggers into the CTI.If external multiplexing of trigger signals is implemented then the number of multiplexed signals on each trigger must be reflected in CTIDEVID.EXTMUXNUM.If CTIDEVID.EXTMUXNUM is zero, this field is RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAPPCLEAR</spirit:name>
          <spirit:description>CTI Application Trigger Clear Register</spirit:description>
          <spirit:addressOffset>0x018</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTIAPPCLEAR -->
          <spirit:field>
            <spirit:name>RESERVED_CTIAPPCLEAR_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTIAPPCLEARx</spirit:name>
            <spirit:displayName>CTIAPPCLEARx</spirit:displayName>
            <spirit:description>Application trigger &lt;x&gt; disable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAPPPULSE</spirit:name>
          <spirit:description>CTI Application Pulse Register</spirit:description>
          <spirit:addressOffset>0x01C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTIAPPPULSE -->
          <spirit:field>
            <spirit:name>RESERVED_CTIAPPPULSE_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTIAPPPULSEx</spirit:name>
            <spirit:displayName>CTIAPPPULSEx</spirit:displayName>
            <spirit:description>Generate event pulse on ECT channel &lt;x&gt;.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAPPSET</spirit:name>
          <spirit:description>CTI Application Trigger Set Register</spirit:description>
          <spirit:addressOffset>0x014</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIAPPSET -->
          <spirit:field>
            <spirit:name>RESERVED_CTIAPPSET_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTIAPPSETx</spirit:name>
            <spirit:displayName>CTIAPPSETx</spirit:displayName>
            <spirit:description>Application trigger &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIAUTHSTATUS</spirit:name>
          <spirit:description>CTI Authentication Status Register</spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000A</spirit:value>
            <spirit:mask>0xFFFFFFAA</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIAUTHSTATUS -->
          <spirit:field>
            <spirit:name>RES0_CTIAUTHSTATUS_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>If EL3 is not implemented and the processor is Secure, holds the same value as DBGAUTHSTATUS_EL1.SNID.Otherwise, holds the same value as DBGAUTHSTATUS_EL1.NSNID.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSID</spirit:name>
            <spirit:displayName>NSID</spirit:displayName>
            <spirit:description>If EL3 is not implemented and the processor is Secure, holds the same value as DBGAUTHSTATUS_EL1.SID.Otherwise, holds the same value as DBGAUTHSTATUS_EL1.NSID.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICHINSTATUS</spirit:name>
          <spirit:description>CTI Channel In Status Register</spirit:description>
          <spirit:addressOffset>0x138</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICHINSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTICHINSTATUS_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CHINn</spirit:name>
            <spirit:displayName>CHINn</spirit:displayName>
            <spirit:description>Provides the raw status of the ECT channel inputs to the CTI</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICHOUTSTATUS</spirit:name>
          <spirit:description>CTI Channel Out Status Register</spirit:description>
          <spirit:addressOffset>0x13C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICHOUTSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTICHOUTSTATUS_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CHOUTn</spirit:name>
            <spirit:displayName>CHOUTn</spirit:displayName>
            <spirit:description>Provides the status of the ECT channel outputs from the CTI</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR0</spirit:name>
          <spirit:description>CTI Component Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR0 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR1</spirit:name>
          <spirit:description>CTI Component Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR1 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, debug component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR2</spirit:name>
          <spirit:description>CTI Component Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR2 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICIDR3</spirit:name>
          <spirit:description>CTI Component Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICIDR3 -->
          <spirit:field>
            <spirit:name>RES0_CTICIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICLAIMCLR</spirit:name>
          <spirit:description>CTI Claim Clear</spirit:description>
          <spirit:addressOffset>0xFA4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICLAIMCLR -->
          <spirit:field>
            <spirit:name>RESERVED_CTICLAIMCLR_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIMx</spirit:name>
            <spirit:displayName>CLAIMx</spirit:displayName>
            <spirit:description>Clear CLAIM tag</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICLAIMSET</spirit:name>
          <spirit:description>CTI Claim Set</spirit:description>
          <spirit:addressOffset>0xFA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000f</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICLAIMSET -->
          <spirit:field>
            <spirit:name>RESERVED_CTICLAIMSET_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIMx</spirit:name>
            <spirit:displayName>CLAIMx</spirit:displayName>
            <spirit:description>CLAIM tag set bit</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTICONTROL</spirit:name>
          <spirit:description>CTI Control Register</spirit:description>
          <spirit:addressOffset>0x000</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTICONTROL -->
          <spirit:field>
            <spirit:name>RES0_CTICONTROL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GLBEN</spirit:name>
            <spirit:displayName>GLBEN</spirit:displayName>
            <spirit:description>Enables or disables the CTI mapping functions. Possible values of this field are:
      0
      
      CTI mapping functions disabled.
      
      
    
      1
      
      CTI mapping functions enabled.
      
      
    When the mapping functions are disabled, no new events are signaled on either output triggers or output channels. If a previously asserted output trigger has not been acknowledged, it remains asserted after the mapping functions are disabled. All output triggers are disabled by CTI reset.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVAFF0</spirit:name>
          <spirit:description>CTI Device Affinity Register 0</spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000001</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVAFF0 -->
          <spirit:field>
            <spirit:name>CTIDEVAFF0</spirit:name>
            <spirit:displayName>CTIDEVAFF0</spirit:displayName>
            <spirit:description>MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVAFF1</spirit:name>
          <spirit:description>CTI Device Affinity Register 1</spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVAFF1 -->
          <spirit:field>
            <spirit:name>CTIDEVAFF1</spirit:name>
            <spirit:displayName>CTIDEVAFF1</spirit:displayName>
            <spirit:description>MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVARCH</spirit:name>
          <spirit:description>CTI Device Architecture Register</spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47701A14</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For CTI, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For CTI, the revision defined by v8-A is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For CTI:Bits [15:12] are the architecture version, 0x1.Bits [11:0] are the architecture part number, 0xA14.This corresponds to CTI architecture version CTIv2.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVID</spirit:name>
          <spirit:description>CTI Device ID Register 0</spirit:description>
          <spirit:addressOffset>0xFC8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x01040800</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVID -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_31_26</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INOUT</spirit:name>
            <spirit:displayName>INOUT</spirit:displayName>
            <spirit:description>Input/output options. Indicates presence of the input gate. If the CTM is not implemented, this field is RAZ.
      00
      
      CTIGATE does not mask propagation of input events from external channels.
      
      
    
      01
      
      CTIGATE masks propagation of input events from external channels.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_23_22</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMCHAN</spirit:name>
            <spirit:displayName>NUMCHAN</spirit:displayName>
            <spirit:description>Number of ECT channels implemented. IMPLEMENTATION DEFINED. For v8-A, valid values are:
      000011
      
      3 channels (0..2) implemented.
      
      
    
      000100
      
      4 channels (0..3) implemented.
      
      
    
      000101
      
      5 channels (0..4) implemented.
      
      
    
      000110
      
      6 channels (0..5) implemented.
      
      
    and so on up to 0b100000, 32 channels (0..31) implemented.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_15_14</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NUMTRIG</spirit:name>
            <spirit:displayName>NUMTRIG</spirit:displayName>
            <spirit:description>Number of triggers implemented. IMPLEMENTATION DEFINED. This is one more than the index of the largest trigger, rather than the actual number of triggers.For v8-A, valid values are:
      000011
      
      Up to 3 triggers (0..2) implemented.
      
      
    
      001000
      
      Up to 8 triggers (0..7) implemented.
      
      
    
      001001
      
      Up to 9 triggers (0..8) implemented.
      
      
    
      001010
      
      Up to 10 triggers (0..9) implemented.
      
      
    and so on up to 0b100000, 32 triggers (0..31) implemented.All other values are reserved. If the Trace Extension is implemented, this field must be at least 001000. There is no guarantee that any of the implemented triggers, including the highest numbered, are connected to any components.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_CTIDEVID_7_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EXTMUXNUM</spirit:name>
            <spirit:displayName>EXTMUXNUM</spirit:displayName>
            <spirit:description>Maximum number of external triggers available for multiplexing into the CTI. This relates only to additional external triggers outside those defined for v8-A.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVID1</spirit:name>
          <spirit:description>CTI Device ID Register 1</spirit:description>
          <spirit:addressOffset>0xFC4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVID1 -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVID1_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVID2</spirit:name>
          <spirit:description>CTI Device ID Register 2</spirit:description>
          <spirit:addressOffset>0xFC0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVID2 -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVID2_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIDEVTYPE</spirit:name>
          <spirit:description>CTI Device Type Register</spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000014</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_CTIDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Subtype. Must read as 0x1 to indicate this is a processor component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAJOR</spirit:name>
            <spirit:displayName>MAJOR</spirit:displayName>
            <spirit:description>Major type. Must read as 0x4 to indicate this is a cross-trigger component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIGATE</spirit:name>
          <spirit:description>CTI Channel Gate Enable Register</spirit:description>
          <spirit:addressOffset>0x140</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000F</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIGATE -->
          <spirit:field>
            <spirit:name>RESERVED_CTIGATE_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GATEx</spirit:name>
            <spirit:displayName>GATEx</spirit:displayName>
            <spirit:description>Determines whether events on channels propagate through the CTM to other ECT components or from the CTM into the CTI</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN0</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 0</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN0 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN0_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 0 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN1</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 1</spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN1 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN1_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 1 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN2</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 2</spirit:description>
          <spirit:addressOffset>0x028</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN2 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN2_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 2 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN3</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 3</spirit:description>
          <spirit:addressOffset>0x02c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN3 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN3_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 3 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN4</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 4</spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN4 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN4_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 4 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN5</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 5</spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN5 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN5_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 5 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN6</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 6</spirit:description>
          <spirit:addressOffset>0x038</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN6 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN6_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 6 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINEN7</spirit:name>
          <spirit:description>CTI Input Trigger to Output Channel Enable Register 7</spirit:description>
          <spirit:addressOffset>0x03c</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIINEN7 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINEN7_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INENx</spirit:name>
            <spirit:displayName>INENx</spirit:displayName>
            <spirit:description>Input trigger 7 to output channel &lt;x&gt; enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIINTACK</spirit:name>
          <spirit:description>CTI Output Trigger Acknowledge Register</spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTIINTACK -->
          <spirit:field>
            <spirit:name>RESERVED_CTIINTACK_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ACK_n</spirit:name>
            <spirit:displayName>ACK_n</spirit:displayName>
            <spirit:description>Can be used to create soft acknowledges for output triggers</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIITCTRL</spirit:name>
          <spirit:description>CTI Integration mode Control Register</spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIITCTRL -->
          <spirit:field>
            <spirit:name>RES0_CTIITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IME</spirit:name>
            <spirit:displayName>IME</spirit:displayName>
            <spirit:description>Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.
      0
      
      Normal operation.
      
      
    
      1
      
      Integration mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTILAR</spirit:name>
          <spirit:description>CTI Lock Access Register</spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: CTILAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTILSR</spirit:name>
          <spirit:description>CTI Lock Status Register</spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFC</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTILSR -->
          <spirit:field>
            <spirit:name>RES0_CTILSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:
      0
      
      Software lock not implemented or not memory-mapped access.
      
      
    
      1
      
      Software lock implemented and memory-mapped access.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN0</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 0</spirit:description>
          <spirit:addressOffset>0x0A0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN0 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN0_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 0 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN1</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 1</spirit:description>
          <spirit:addressOffset>0x0A4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN1 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN1_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 1 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN2</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 2</spirit:description>
          <spirit:addressOffset>0x0A8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN2 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN2_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 2 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN3</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 3</spirit:description>
          <spirit:addressOffset>0x0AC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN3 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN3_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 3 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN4</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 4</spirit:description>
          <spirit:addressOffset>0x0B0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN4 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN4_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 4 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN5</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 5</spirit:description>
          <spirit:addressOffset>0x0B4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN5 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN5_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 5 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN6</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 6</spirit:description>
          <spirit:addressOffset>0x0B8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN6 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN6_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 6 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIOUTEN7</spirit:name>
          <spirit:description>CTI Input Channel to Output Trigger Enable Register 7</spirit:description>
          <spirit:addressOffset>0x0BC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIOUTEN7 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIOUTEN7_31_4</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OUTENx</spirit:name>
            <spirit:displayName>OUTENx</spirit:displayName>
            <spirit:description>Input channel &lt;x&gt; to output trigger 7 enable</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR0</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000A8</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, least significant byte.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR1</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B9</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, most significant nibble.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR2</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Part major revision. Parts can also use this field to extend Part number to 16-bits.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR3</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>Part minor revision. Parts using CTIPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR4</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 4</spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_CTIPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR5</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 5</spirit:description>
          <spirit:addressOffset>0xFD4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR5 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIPIDR5_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR6</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 6</spirit:description>
          <spirit:addressOffset>0xFD8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR6 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIPIDR6_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTIPIDR7</spirit:name>
          <spirit:description>CTI Peripheral Identification Register 7</spirit:description>
          <spirit:addressOffset>0xFDC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTIPIDR7 -->
          <spirit:field>
            <spirit:name>RESERVED_CTIPIDR7_31_0</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTITRIGINSTATUS</spirit:name>
          <spirit:description>CTI Trigger In Status Register</spirit:description>
          <spirit:addressOffset>0x130</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTITRIGINSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTITRIGINSTATUS_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TRINn</spirit:name>
            <spirit:displayName>TRINn</spirit:displayName>
            <spirit:description>Provides the status of the trigger inputs</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>CTITRIGOUTSTATUS</spirit:name>
          <spirit:description>CTI Trigger Out Status Register</spirit:description>
          <spirit:addressOffset>0x134</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: CTITRIGOUTSTATUS -->
          <spirit:field>
            <spirit:name>RESERVED_CTITRIGOUTSTATUS_31_8</spirit:name>
            <spirit:displayName>RESERVED</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TROUTn</spirit:name>
            <spirit:displayName>TROUTn</spirit:displayName>
            <spirit:description>Provides the status of the trigger outputs</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
      <spirit:addressBlock>
        <spirit:name>APBADDR_DBG_CPU0</spirit:name>
        <spirit:displayName>APBADDR_DBG_0</spirit:displayName>
        <spirit:description>APBADDR_DBG_0</spirit:description>
        <spirit:baseAddress spirit:format="long" spirit:resolve="immediate">65536</spirit:baseAddress>
        <spirit:range>4K</spirit:range>
        <spirit:width>32</spirit:width>
        <!--  Registers for Local/Memory Map for APB_Memory_Map <APBADDR_DBG_CPU0>  -->
        <spirit:register>
          <spirit:name>DBGAUTHSTATUS_EL1</spirit:name>
          <spirit:description>Debug Authentication Status register</spirit:description>
          <spirit:addressOffset>0xFB8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000AA</spirit:value>
            <spirit:mask>0xFFFFFFAA</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: DBGAUTHSTATUS_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGAUTHSTATUS_EL1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNID</spirit:name>
            <spirit:displayName>SNID</spirit:displayName>
            <spirit:description>Secure non-invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Non-secure.
      
      
    
      10
      
      Implemented and disabled. ExternalSecureNoninvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalSecureNoninvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SID</spirit:name>
            <spirit:displayName>SID</spirit:displayName>
            <spirit:description>Secure invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Non-secure.
      
      
    
      10
      
      Implemented and disabled. ExternalSecureInvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalSecureInvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSNID</spirit:name>
            <spirit:displayName>NSNID</spirit:displayName>
            <spirit:description>Non-secure non-invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Secure.
      
      
    
      10
      
      Implemented and disabled. ExternalNoninvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalNoninvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSID</spirit:name>
            <spirit:displayName>NSID</spirit:displayName>
            <spirit:description>Non-secure invasive debug. Possible values of this field are:
      00
      
      Not implemented. EL3 is not implemented and the processor is Secure.
      
      
    
      10
      
      Implemented and disabled. ExternalInvasiveDebugEnabled() == FALSE.
      
      
    
      11
      
      Implemented and enabled. ExternalInvasiveDebugEnabled() == TRUE.
      
      
    Other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR0_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 0</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR0_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR0_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR0_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR0_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR1_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 1</spirit:description>
          <spirit:addressOffset>0x418</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR1_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR1_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR1_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR1_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR2_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 2</spirit:description>
          <spirit:addressOffset>0x428</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR2_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR2_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR2_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR2_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR3_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 3</spirit:description>
          <spirit:addressOffset>0x438</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR3_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR3_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR3_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR3_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR4_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 4</spirit:description>
          <spirit:addressOffset>0x448</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR4_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR4_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR4_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR4_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBCR5_EL1</spirit:name>
          <spirit:description>Debug Breakpoint Control Register 5</spirit:description>
          <spirit:addressOffset>0x458</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBCR5_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGBCR5_EL1_31_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BT</spirit:name>
            <spirit:displayName>BT</spirit:displayName>
            <spirit:description>Breakpoint Type. Possible values are:
      0000
      
      Unlinked instruction address match.
      
      
    
      0001
      
      Linked instruction address match.
      
      
    
      0010
      
      Unlinked context ID match.
      
      
    
      0011
      
      Linked context ID match
      
      
    
      0100
      
      Unlinked instruction address mismatch.
      
      
    
      0101
      
      Linked instruction address mismatch.
      
      
    
      1000
      
      Unlinked VMID match.
      
      
    
      1001
      
      Linked VMID match.
      
      
    
      1010
      
      Unlinked VMID and context ID match.
      
      
    
      1011
      
      Linked VMID and context ID match.
      
      
    The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&lt;n&gt;_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&lt;n&gt;_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID.100Match VMID. DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&lt;n&gt;_EL1[31:0] is a context ID, and DBGBVR&lt;n&gt;_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR5_EL1_12_9</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&lt;n&gt;_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&lt;n&gt;_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&lt;n&gt;_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&lt;n&gt;_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGBCR5_EL1_4_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMC</spirit:name>
            <spirit:displayName>PMC</spirit:displayName>
            <spirit:description>Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable breakpoint DBGBVR&lt;n&gt;_EL1. Possible values are:
      0
      
      Breakpoint disabled.
      
      
    
      1
      
      Breakpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR0_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR0_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR0_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR0_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR0_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR0_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR0_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR0_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR1_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR1_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR1_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR1_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR1_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR1_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR1_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR1_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR2_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR2_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x420</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR2_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR2_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR2_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR2_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR2_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x424</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR2_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR2_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR2_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR3_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR3_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x430</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR3_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR3_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR3_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR3_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR3_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x434</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR3_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR3_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR3_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR4_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR4_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x440</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR4_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR4_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR4_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR4_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR4_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x444</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR4_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR4_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR4_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR5_EL1_31:0</spirit:name>
          <spirit:description>Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR5_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x450</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR5_EL1_31:0 -->
          <spirit:field>
            <spirit:name>DBGBVR5_EL1_31:0</spirit:name>
            <spirit:displayName>DBGBVR5_EL1_31:0</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGBVR5_EL1_63:32</spirit:name>
          <spirit:description>Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR5_EL1. Multiple uses of this register refer to ARMv8</spirit:description>
          <spirit:addressOffset>0x454</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGBVR5_EL1_63:32 -->
          <spirit:field>
            <spirit:name>DBGBVR5_EL1_63:32</spirit:name>
            <spirit:displayName>DBGBVR5_EL1_63:32</spirit:displayName>
            <spirit:description>Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGCLAIMCLR_EL1</spirit:name>
          <spirit:description>Debug Claim Tag Clear Register</spirit:description>
          <spirit:addressOffset>0xFA4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: DBGCLAIMCLR_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGCLAIMCLR_EL1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RAZ/SBZ. Software can rely on these bits reading as zero, and must use a should-be-zero policy on writes. Implementations must ignore writes.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIM</spirit:name>
            <spirit:displayName>CLAIM</spirit:displayName>
            <spirit:description>Claim clear bits. Reading this field returns the current value of the CLAIM bits.Writing a 1 to one of these bits clears the corresponding CLAIM bit to 0. This is an indirect write to the CLAIM bits.A single write operation can clear multiple bits to 0. Writing 0 to one of these bits has no effect.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGCLAIMSET_EL1</spirit:name>
          <spirit:description>Debug Claim Tag Set Register</spirit:description>
          <spirit:addressOffset>0xFA0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000FF</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: DBGCLAIMSET_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGCLAIMSET_EL1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RAZ/SBZ. Software can rely on these bits reading as zero, and must use a should-be-zero policy on writes. Implementations must ignore writes.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLAIM</spirit:name>
            <spirit:displayName>CLAIM</spirit:displayName>
            <spirit:description>Claim set bits. RAO.Writing a 1 to one of these bits sets the corresponding CLAIM bit to 1. This is an indirect write to the CLAIM bits.A single write operation can set multiple bits to 1. Writing 0 to one of these bits has no effect.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGDTRRX_EL0</spirit:name>
          <spirit:description>Debug Data Transfer Register Receive</spirit:description>
          <spirit:addressOffset>0x080</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGDTRRX_EL0 -->
          <spirit:field>
            <spirit:name>DBGDTRRX_EL0</spirit:name>
            <spirit:displayName>DBGDTRRX_EL0</spirit:displayName>
            <spirit:description>Update DTRRX. Writes to this register update the value in DTRRX and set RXfull to 1.Reads of this register return the last value written to DTRRX and do not change RXfull.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGDTRTX_EL0</spirit:name>
          <spirit:description>Debug Data Transfer Register Transmit</spirit:description>
          <spirit:addressOffset>0x08C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGDTRTX_EL0 -->
          <spirit:field>
            <spirit:name>DBGDTRTX_EL0</spirit:name>
            <spirit:displayName>DBGDTRTX_EL0</spirit:displayName>
            <spirit:description>Return DTRTX. Reads of this register return the value in DTRTX and clear TXfull to 0.Writes of this register update the value in DTRTX and do not change TXfull.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR0_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 0</spirit:description>
          <spirit:addressOffset>0x808</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR0_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR0_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR0_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR1_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 1</spirit:description>
          <spirit:addressOffset>0x818</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR1_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR1_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR1_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR2_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 2</spirit:description>
          <spirit:addressOffset>0x828</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR2_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR2_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR2_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWCR3_EL1</spirit:name>
          <spirit:description>Debug Watchpoint Control Register 3</spirit:description>
          <spirit:addressOffset>0x838</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWCR3_EL1 -->
          <spirit:field>
            <spirit:name>RES0_DBGWCR3_EL1_31_29</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MASK</spirit:name>
            <spirit:displayName>MASK</spirit:displayName>
            <spirit:description>Address mask. Only objects up to 2GB can be watched using a single mask.
      00000
      
      No mask.
      
      
    
      00001
      
      Reserved.
      
      
    
      00010
      
      Reserved.
      
      
    Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWCR3_EL1_23_21</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WT</spirit:name>
            <spirit:displayName>WT</spirit:displayName>
            <spirit:description>Watchpoint type. Possible values are:
      0
      
      Unlinked data address match.
      
      
    
      1
      
      Linked data address match.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBN</spirit:name>
            <spirit:displayName>LBN</spirit:displayName>
            <spirit:description>Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SSC</spirit:name>
            <spirit:displayName>SSC</spirit:displayName>
            <spirit:description>Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HMC</spirit:name>
            <spirit:displayName>HMC</spirit:displayName>
            <spirit:description>Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BAS</spirit:name>
            <spirit:displayName>BAS</spirit:displayName>
            <spirit:description>Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&lt;n&gt;_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&lt;n&gt;_EL1xxxxxx1xMatch byte at DBGWVR&lt;n&gt;_EL1+1xxxxx1xxMatch byte at DBGWVR&lt;n&gt;_EL1+2xxxx1xxxMatch byte at DBGWVR&lt;n&gt;_EL1+3In cases where DBGWVR&lt;n&gt;_EL1 addresses a double-word:BASDescription, if DBGWVR&lt;n&gt;_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&lt;n&gt;_EL1+4xx1xxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+5x1xxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+61xxxxxxxMatch byte at DBGWVR&lt;n&gt;_EL1+7If DBGWVR&lt;n&gt;_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&lt;n&gt;_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>LSC</spirit:name>
            <spirit:displayName>LSC</spirit:displayName>
            <spirit:description>Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:
      01
      
      Match instructions that load from a watchpointed address.
      
      
    
      10
      
      Match instructions that store to a watchpointed address.
      
      
    
      11
      
      Match instructions that load from or store to a watchpointed address.
      
      
    All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAC</spirit:name>
            <spirit:displayName>PAC</spirit:displayName>
            <spirit:description>Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E</spirit:name>
            <spirit:displayName>E</spirit:displayName>
            <spirit:description>Enable watchpoint n. Possible values are:
      0
      
      Watchpoint disabled.
      
      
    
      1
      
      Watchpoint enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR0_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 0</spirit:description>
          <spirit:addressOffset>0x800</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR0_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR0_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 0</spirit:description>
          <spirit:addressOffset>0x804</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR1_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 1</spirit:description>
          <spirit:addressOffset>0x810</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR1_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR1_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 1</spirit:description>
          <spirit:addressOffset>0x814</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR2_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 2</spirit:description>
          <spirit:addressOffset>0x820</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR2_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR2_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR2_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 2</spirit:description>
          <spirit:addressOffset>0x824</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR2_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR3_EL1_31:0</spirit:name>
          <spirit:description>Debug Watchpoint Value Register 3</spirit:description>
          <spirit:addressOffset>0x830</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR3_EL1_31:0 -->
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>30</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_DBGWVR3_EL1_31:0_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>DBGWVR3_EL1_63:32</spirit:name>
          <spirit:description>Debug Watchpoint Extended Value Register 3</spirit:description>
          <spirit:addressOffset>0x834</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: DBGWVR3_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RESS</spirit:name>
            <spirit:displayName>RESS</spirit:displayName>
            <spirit:description>Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VA</spirit:name>
            <spirit:displayName>VA</spirit:displayName>
            <spirit:description>Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&lt;n&gt;_EL1[2] == 1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>17</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDACR</spirit:name>
          <spirit:description>External Debug Auxiliary Control Register</spirit:description>
          <spirit:addressOffset>0x094</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <!--  Adding Fields for register: EDACR -->
          <spirit:field>
            <spirit:name>RES0_EDACR_31_0</spirit:name>
            <spirit:displayName>Reserved RES0</spirit:displayName>
            <spirit:description>Reserved RES0</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR0</spirit:name>
          <spirit:description>External Debug Component Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFF0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000000D</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR0 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_0</spirit:name>
            <spirit:displayName>PRMBL_0</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x0D.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR1</spirit:name>
          <spirit:description>External Debug Component Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFF4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000090</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR1 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CLASS</spirit:name>
            <spirit:displayName>CLASS</spirit:displayName>
            <spirit:description>Component class. Reads as 0x9, debug component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_1</spirit:name>
            <spirit:displayName>PRMBL_1</spirit:displayName>
            <spirit:description>Preamble. RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR2</spirit:name>
          <spirit:description>External Debug Component Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFF8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000005</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR2 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_2</spirit:name>
            <spirit:displayName>PRMBL_2</spirit:displayName>
            <spirit:description>Preamble. Must read as 0x05.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDR3</spirit:name>
          <spirit:description>External Debug Component Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFFC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000B1</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDCIDR3 -->
          <spirit:field>
            <spirit:name>RES0_EDCIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRMBL_3</spirit:name>
            <spirit:displayName>PRMBL_3</spirit:displayName>
            <spirit:description>Preamble. Must read as 0xB1.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDCIDSR</spirit:name>
          <spirit:description>External Debug Context ID Sample Register</spirit:description>
          <spirit:addressOffset>0x0A4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDCIDSR -->
          <spirit:field>
            <spirit:name>CONTEXTIDR</spirit:name>
            <spirit:displayName>CONTEXTIDR</spirit:displayName>
            <spirit:description>The sampled value of CONTEXTIDR_EL1, captured on reading the low half of EDPCSR.If EL3 is implemented and using AArch32 then CONTEXTIDR is a Banked register, and EDCIDSR samples the current Banked copy of CONTEXTIDR.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVAFF0</spirit:name>
          <spirit:description>External Debug Device Affinity Register 0</spirit:description>
          <spirit:addressOffset>0xFA8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x80000000</spirit:value>
            <spirit:mask>0xFF0000FF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVAFF0 -->
          <spirit:field>
            <spirit:name>EDDEVAFF0</spirit:name>
            <spirit:displayName>EDDEVAFF0</spirit:displayName>
            <spirit:description>MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVAFF1</spirit:name>
          <spirit:description>External Debug Device Affinity Register 1</spirit:description>
          <spirit:addressOffset>0xFAC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVAFF1 -->
          <spirit:field>
            <spirit:name>EDDEVAFF1</spirit:name>
            <spirit:displayName>EDDEVAFF1</spirit:displayName>
            <spirit:description>MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVARCH</spirit:name>
          <spirit:description>External Debug Device Architecture Register</spirit:description>
          <spirit:addressOffset>0xFBC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x47706A15</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVARCH -->
          <spirit:field>
            <spirit:name>ARCHITECT</spirit:name>
            <spirit:displayName>ARCHITECT</spirit:displayName>
            <spirit:description>Defines the architecture of the component. For debug, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>11</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PRESENT</spirit:name>
            <spirit:displayName>PRESENT</spirit:displayName>
            <spirit:description>When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Defines the architecture revision. For architectures defined by ARM this is the minor revision.For debug, the revision defined by v8-A is 0x0.All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ARCHID</spirit:name>
            <spirit:displayName>ARCHID</spirit:displayName>
            <spirit:description>Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For debug:Bits [15:12] are the architecture version, 0x6.Bits [11:0] are the architecture part number, 0xA15.This corresponds to debug architecture version v8-A.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVID</spirit:name>
          <spirit:description>External Debug Device ID Register 0</spirit:description>
          <spirit:addressOffset>0xFC8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVID -->
          <spirit:field>
            <spirit:name>RES0_EDDEVID_31_28</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AuxRegs</spirit:name>
            <spirit:displayName>AuxRegs</spirit:displayName>
            <spirit:description>Indicates support for Auxiliary registers. Permitted values for this field are:
      0000
      
      None supported.
      
      
    
      0001
      
      Support for External Debug Auxiliary Control Register, EDACR.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDDEVID_23_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PCSample</spirit:name>
            <spirit:displayName>PCSample</spirit:displayName>
            <spirit:description>Indicates the level of Sample-based profiling support using external debug registers 40 through 43. Permitted values of this field in v8-A are:
      0000
      
      Architecture-defined form of Sample-based profiling not implemented.
      
      
    
      0010
      
      EDPCSR and EDCIDSR are implemented (only permitted if EL3 and EL2 are not implemented).
      
      
    
      0011
      
      EDPCSR, EDCIDSR, and EDVIDSR are implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVID1</spirit:name>
          <spirit:description>External Debug Device ID Register 1</spirit:description>
          <spirit:addressOffset>0xFC4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000002</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVID1 -->
          <spirit:field>
            <spirit:name>RES0_EDDEVID1_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PCSROffset</spirit:name>
            <spirit:displayName>PCSROffset</spirit:displayName>
            <spirit:description>This field indicates the offset applied to PC samples returned by reads of EDPCSR. Permitted values of this field in v8-A are:
      0000
      
      EDPCSR not implemented.
      
      
    
      0010
      
      EDPCSR implemented, and samples have no offset applied and do not sample the instruction set state in AArch32 state.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVID2</spirit:name>
          <spirit:description>External Debug Device ID Register 2</spirit:description>
          <spirit:addressOffset>0xFC0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVID2 -->
          <spirit:field>
            <spirit:name>RES0_EDDEVID2_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDDEVTYPE</spirit:name>
          <spirit:description>External Debug Device Type Register</spirit:description>
          <spirit:addressOffset>0xFCC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000015</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDDEVTYPE -->
          <spirit:field>
            <spirit:name>RES0_EDDEVTYPE_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SUB</spirit:name>
            <spirit:displayName>SUB</spirit:displayName>
            <spirit:description>Subtype. Must read as 0x1 to indicate this is a processor component.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MAJOR</spirit:name>
            <spirit:displayName>MAJOR</spirit:displayName>
            <spirit:description>Major type. Must read as 0x5 to indicate this is a debug logic component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDECCR</spirit:name>
          <spirit:description>External Debug Exception Catch Control Register</spirit:description>
          <spirit:addressOffset>0x098</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDECCR -->
          <spirit:field>
            <spirit:name>RES0_EDECCR_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NSE</spirit:name>
            <spirit:displayName>NSE</spirit:displayName>
            <spirit:description>Coarse-grained Non-secure exception catch. Possible values of this field are:
      0000
      
      Exception catch debug event disabled for Non-secure exception levels.
      
      
    
      0010
      
      Exception catch debug event enabled for Non-secure EL1.
      
      
    
      0100
      
      Exception catch debug event enabled for Non-secure EL2.
      
      
    
      0110
      
      Exception catch debug event enabled for Non-secure EL1 and EL2.
      
      
    All other values are reserved. Bits [7,4] are reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SE</spirit:name>
            <spirit:displayName>SE</spirit:displayName>
            <spirit:description>Coarse-grained Secure exception catch. Possible values of this field are:
      0000
      
      Exception catch debug event disabled for Secure exception levels.
      
      
    
      0010
      
      Exception catch debug event enabled for Secure EL1.
      
      
    
      1000
      
      Exception catch debug event enabled for Secure EL3.
      
      
    
      1010
      
      Exception catch debug event enabled for Secure EL1 and EL3.
      
      
    All other values are reserved. Bits [2,0] are reserved. RES0. Ignored if ExternalSecureInvasiveDebugEnabled() == FALSE.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDECR</spirit:name>
          <spirit:description>External Debug Execution Control Register</spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDECR -->
          <spirit:field>
            <spirit:name>RES0_EDECR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SS</spirit:name>
            <spirit:displayName>SS</spirit:displayName>
            <spirit:description>Halting step enable. Possible values of this field are:
      0
      
      Halting step debug event disabled.
      
      
    
      1
      
      Halting step debug event enabled.
      
      
    If the value of EDECR.SS is changed when the processor is in Non-debug state, the resulting value of EDECR.SS is UNKNOWN.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RCE</spirit:name>
            <spirit:displayName>RCE</spirit:displayName>
            <spirit:description>Reset catch enable. Possible values of this field are:
      0
      
      Reset catch debug event disabled.
      
      
    
      1
      
      Reset catch debug event enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSUCE</spirit:name>
            <spirit:displayName>OSUCE</spirit:displayName>
            <spirit:description>OS unlock catch enabled. Possible values of this field are:
      0
      
      OS unlock catch debug event disabled.
      
      
    
      1
      
      OS unlock catch debug event enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDESR</spirit:name>
          <spirit:description>External Debug Event Status Register</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF9</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDESR -->
          <spirit:field>
            <spirit:name>RES0_EDESR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SS</spirit:name>
            <spirit:displayName>SS</spirit:displayName>
            <spirit:description>Halting step debug event pending. Possible values of this field are:
      0
      
      Reading this means that a Halting step debug event is not pending. Writing this means no action.
      
      
    
      1
      
      Reading this means that a Halting step debug event is pending. Writing this clears the pending Halting step debug event.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RC</spirit:name>
            <spirit:displayName>RC</spirit:displayName>
            <spirit:description>Reset catch debug event pending. Possible values of this field are:
      0
      
      Reading this means that a Reset catch debug event is not pending. Writing this means no action.
      
      
    
      1
      
      Reading this means that a Reset catch debug event is pending. Writing this clears the pending Reset catch debug event.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSUC</spirit:name>
            <spirit:displayName>OSUC</spirit:displayName>
            <spirit:description>OS unlock debug event pending. Possible values of this field are:
      0
      
      Reading this means that an OS unlock catch debug event is not pending. Writing this means no action.
      
      
    
      1
      
      Reading this means that an OS unlock catch debug event is pending. Writing this clears the pending OS unlock catch debug event.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDITCTRL</spirit:name>
          <spirit:description>External Debug Integration mode Control Register</spirit:description>
          <spirit:addressOffset>0xF00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDITCTRL -->
          <spirit:field>
            <spirit:name>RES0_EDITCTRL_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>IME</spirit:name>
            <spirit:displayName>IME</spirit:displayName>
            <spirit:description>Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.
      0
      
      Normal operation.
      
      
    
      1
      
      Integration mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDITR</spirit:name>
          <spirit:description>External Debug Instruction Transfer Register</spirit:description>
          <spirit:addressOffset>0x084</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: EDITR -->
          <spirit:field>
            <spirit:name>EDITR</spirit:name>
            <spirit:displayName>EDITR</spirit:displayName>
            <spirit:description>Used in Debug state for passing instructions to the processor for execution</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDLAR</spirit:name>
          <spirit:description>External Debug Lock Access Register</spirit:description>
          <spirit:addressOffset>0xFB0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <!--  Adding Fields for register: EDLAR -->
          <spirit:field>
            <spirit:name>KEY</spirit:name>
            <spirit:displayName>KEY</spirit:displayName>
            <spirit:description>Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDLSR</spirit:name>
          <spirit:description>External Debug Lock Status Register</spirit:description>
          <spirit:addressOffset>0xFB4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF8</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDLSR -->
          <spirit:field>
            <spirit:name>RES0_EDLSR_31_3</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>29</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>nTT</spirit:name>
            <spirit:displayName>nTT</spirit:displayName>
            <spirit:description>Not thirty-two bit access required. RAZ.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLK</spirit:name>
            <spirit:displayName>SLK</spirit:displayName>
            <spirit:description>Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:
      0
      
      Lock clear. Writes are permitted to this component's registers.
      
      
    
      1
      
      Lock set. Writes to this component's registers are ignored, and reads have no side effects.
      
      
    </spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLI</spirit:name>
            <spirit:displayName>SLI</spirit:displayName>
            <spirit:description>Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:
      0
      
      Software lock not implemented or not memory-mapped access.
      
      
    
      1
      
      Software lock implemented and memory-mapped access.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPCSR_31:0</spirit:name>
          <spirit:description>External Debug Program Counter Sample Register (low word)</spirit:description>
          <spirit:addressOffset>0x0A0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDPCSR_31:0 -->
          <spirit:field>
            <spirit:name>EDPCSR_31:0</spirit:name>
            <spirit:displayName>EDPCSR_31:0</spirit:displayName>
            <spirit:description>PC Sample low word, EDPCSRlo. Bits [31:0] of the sampled instruction address value. Reading EDPCSRlo has the side-effect of updating EDCIDSR, EDVIDSR, and EDPCSRhi. However:If the processor is in Debug state, or Sample-based profiling is prohibited, EDPCSRlo reads as 0xFFFFFFFF and EDCIDSR, EDVIDSR, and EDPCSRhi become UNKNOWN.If the processor is in Reset state, the sampled value is unknown and EDCIDSR, EDVIDSR and EDPCSRhi become UNKNOWN.If no instruction has been retired since the processor left Reset state, Debug state, or a state where Non-invasive debug is not permitted, the sampled value is UNKNOWN and EDCIDSR, EDVIDSR, and EDPCSRhi become UNKNOWN.For a read of EDPCSRlo from the memory-mapped interface, if EDLSR.SLK == 1, meaning the Software Lock is locked, then the access has no side-effects. That is, EDCIDSR, EDVIDSR, and EDPCSRhi are unchanged.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPCSR_63:32</spirit:name>
          <spirit:description>External Debug Program Counter Sample Register (high word)</spirit:description>
          <spirit:addressOffset>0x0AC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDPCSR_63:32 -->
          <spirit:field>
            <spirit:name>EDPCSR_63:32</spirit:name>
            <spirit:displayName>EDPCSR_63:32</spirit:displayName>
            <spirit:description>PC Sample high word, EDPCSRhi. If EDVIDSR.HV == 0 then this field is RAZ, otherwise bits [63:32] of the sampled PC.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR0</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 0</spirit:description>
          <spirit:addressOffset>0xFE0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR0 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR0_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_0</spirit:name>
            <spirit:displayName>PART_0</spirit:displayName>
            <spirit:description>Part number, least significant byte.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR1</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 1</spirit:description>
          <spirit:addressOffset>0xFE4</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x000000BD</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR1 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR1_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_0</spirit:name>
            <spirit:displayName>DES_0</spirit:displayName>
            <spirit:description>Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PART_1</spirit:name>
            <spirit:displayName>PART_1</spirit:displayName>
            <spirit:description>Part number, most significant nibble.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR2</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 2</spirit:description>
          <spirit:addressOffset>0xFE8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x0000004B</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR2 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR2_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVISION</spirit:name>
            <spirit:displayName>REVISION</spirit:displayName>
            <spirit:description>Part major revision. Parts can also use this field to extend Part number to 16-bits.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>JEDEC</spirit:name>
            <spirit:displayName>JEDEC</spirit:displayName>
            <spirit:description>RAO. Indicates a JEP106 identity code is used.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_1</spirit:name>
            <spirit:displayName>DES_1</spirit:displayName>
            <spirit:description>Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>3</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR3</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 3</spirit:description>
          <spirit:addressOffset>0xFEC</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR3 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR3_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>REVAND</spirit:name>
            <spirit:displayName>REVAND</spirit:displayName>
            <spirit:description>Part minor revision. Parts using EDPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CMOD</spirit:name>
            <spirit:displayName>CMOD</spirit:displayName>
            <spirit:description>Customer modified. Indicates someone other than the Designer has modified the component.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPIDR4</spirit:name>
          <spirit:description>External Debug Peripheral Identification Register 4</spirit:description>
          <spirit:addressOffset>0xFD0</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000004</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPIDR4 -->
          <spirit:field>
            <spirit:name>RES0_EDPIDR4_31_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>24</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SIZE</spirit:name>
            <spirit:displayName>SIZE</spirit:displayName>
            <spirit:description>Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DES_2</spirit:name>
            <spirit:displayName>DES_2</spirit:displayName>
            <spirit:description>Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPRCR</spirit:name>
          <spirit:description>External Debug Power/Reset Control Register</spirit:description>
          <spirit:addressOffset>0x310</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFF6</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPRCR -->
          <spirit:field>
            <spirit:name>RES0_EDPRCR_31_4</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>28</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>COREPURQ</spirit:name>
            <spirit:displayName>COREPURQ</spirit:displayName>
            <spirit:description>Core powerup request. Allows a debugger to request that the power controller power up the core, enabling access to the debug register in the Core power domain. The actions on writing to this bit are:
      0
      
      No effect.
      
      
    
      1
      
      Request the power controller to powerup the core.
      
      
    In an implementation that includes the recommended external debug interface, this bit drives the DBGPWRUPREQ signal.This bit can be read and written when the Core power domain is powered off.The power controller must not allow the Core power domain to switch off while this bit is one.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDPRCR_2_2</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CWRR</spirit:name>
            <spirit:displayName>CWRR</spirit:displayName>
            <spirit:description>Warm reset request. Write only bit that reads as zero. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Request Warm reset.
      
      
    The processor ignores writes to this bit if any of the following are the case:ExternalInvasiveDebugEnabled() == FALSE, EL3 is not implemented, and the processor is Non-secure.ExternalSecureInvasiveDebugEnabled() == FALSE and one of the following is true:EL3 is implemented.The processor is Secure.The Core power domain is either completely off or in a low-power state where the Core power domain registers cannot be accessed.DoubleLockStatus() == TRUE (OS Double Lock is set).OSLSR.OSLK == 1 (OS lock is locked).In an implementation that includes the recommended external debug interface, this bit drives the DBGRSTREQ signal.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CORENPDRQ</spirit:name>
            <spirit:displayName>CORENPDRQ</spirit:displayName>
            <spirit:description>Core no powerdown request. Requests emulation of powerdown. Possible values of this bit are:
      0
      
      On a powerdown request, the system powers down the Core power domain.
      
      
    
      1
      
      On a powerdown request, the system emulates powerdown of the Core power domain. In this emulation mode the Core power domain is not actually powered down.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDPRSR</spirit:name>
          <spirit:description>External Debug Processor Status Register</spirit:description>
          <spirit:addressOffset>0x314</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000003</spirit:value>
            <spirit:mask>0xFFFFF543</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDPRSR -->
          <spirit:field>
            <spirit:name>RES0_EDPRSR_31_12</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SDR</spirit:name>
            <spirit:displayName>SDR</spirit:displayName>
            <spirit:description>Sticky debug restart. Set to 1 when the processor exits Debug state and cleared to 0 following reads of EDPRSR.
      0
      
      The processor has not restarted since EDPRSR was last read.
      
      
    
      1
      
      The processor has restarted since EDPRSR was last read.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 when following a read of EDPRSR.</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SPMAD</spirit:name>
            <spirit:displayName>SPMAD</spirit:displayName>
            <spirit:description>Sticky EPMAD error. Set to 1 if an access returns an error because AllowExternalPMUAccess() == FALSE.
      0
      
      No accesses to the external performance monitors registers have failed since EDPRSR was last read.
      
      
    
      1
      
      At least one access to the external performance monitors registers has failed since EDPRSR was last read.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 when following a read of EDPRSR.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EPMAD</spirit:name>
            <spirit:displayName>EPMAD</spirit:displayName>
            <spirit:description>External performance monitors access disable status.
      0
      
      External performance monitors access enabled.
      
      
    
      1
      
      External performance monitors access disabled.
      
      
    If external performance monitors access is not implemented, EPMAD is RAO. This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SDAD</spirit:name>
            <spirit:displayName>SDAD</spirit:displayName>
            <spirit:description>Sticky EDAD error. Set to 1 if an access returns an error because AllowExternalDebugAccess() == FALSE.
      0
      
      No accesses to the external debug registers have failed since EDPRSR was last read.
      
      
    
      1
      
      At least one access to the external debug registers has failed since EDPRSR was last read.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 following a read of EDPRSR.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EDAD</spirit:name>
            <spirit:displayName>EDAD</spirit:displayName>
            <spirit:description>External debug access disable status.
      0
      
      External debug access enabled.
      
      
    
      1
      
      External debug access disabled.
      
      
    This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DLK</spirit:name>
            <spirit:displayName>DLK</spirit:displayName>
            <spirit:description>OS Double Lock status bit.
      0
      
      OSDLR_EL1.DLK == 0 or EDPRCR.CORENPDRQ == 1 or the processor is in Debug state.
      
      
    
      1
      
      OSDLR_EL1.DLK == 1 and EDPRCR.CORENPDRQ == 0 and the processor is in Non-debug state.
      
      
    This bit is UNKNOWN on reads if EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSLK</spirit:name>
            <spirit:displayName>OSLK</spirit:displayName>
            <spirit:description>OS lock status bit. A read of this bit returns the value of OSLSR_EL1.OSLK.This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1 or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HALTED</spirit:name>
            <spirit:displayName>HALTED</spirit:displayName>
            <spirit:description>Halted status bit. Possible values are:
      0
      
      EDSCR.STATUS is 0b000010 (processor in Non-debug state).
      
      
    
      1
      
      EDSCR.STATUS is not 0b000010.
      
      
    This bit is UNKNOWN on reads if EDPRSR.PU is 0. </spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SR</spirit:name>
            <spirit:displayName>SR</spirit:displayName>
            <spirit:description>Sticky core reset status bit. Possible values are:
      0
      
      The non-debug logic of the processor is not in reset state and has not been reset since the last time EDPRSR was read.
      
      
    
      1
      
      The non-debug logic of the processor is in reset state or has been reset since the last time EDPRSR was read.
      
      
    This bit is UNKNOWN on reads if EDPRSR.DLK is 1 or EDPRSR.PU is 0.This bit clears to 0 following a read of EDPRSR if the non-debug logic of the processor is not in reset state.</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>R</spirit:name>
            <spirit:displayName>R</spirit:displayName>
            <spirit:description>Core reset status bit. Possible values are:
      0
      
      The non-debug logic of the processor is not in reset state.
      
      
    
      1
      
      The non-debug logic of the processor is in reset state.
      
      
    This bit is UNKNOWN on reads if either EDPRSR.DLK is 1 or EDPRSR.PU is 0.</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SPD</spirit:name>
            <spirit:displayName>SPD</spirit:displayName>
            <spirit:description>Sticky core power-down status bit.This bit is set to 1 on Cold reset to indicate the state of the debug registers has been lost. Since a Cold reset is required on powering up the processor, this usually indicates the Core power domain has been completely powered off.Possible values are:
      0
      
      If the Core power domain is off (EDPRSR.PU is 0), it is not known whether the state of the debug registers in the Core power domain is lost. Otherwise, the Core power domain is on, and the state of the debug registers in the Core power domain has not been lost.
      
      
    
      1
      
      The state of the debug registers in the Core power domain is lost.
      
      
    This bit is UNKNOWN on reads if both EDPRSR.DLK and EDPRSR.PU are 1.This bit clears to 0 following a read of EDPRSR if the processor is not in the powered down state. There are two logical power off states for the Core power domain:RetentionThe states of the debug registers, including EDPRSR.SPD, in the Core power domain is preserved, and restored on leaving retention state.Power-downThe states of the debug registers in the Core power domain is lost, and a Cold reset is asserted on leaving power-down state.In these states, it is IMPLEMENTATION DEFINED whether:EDPRSR.SPD shows whether the state of the debug registers in the Core power domain has been lost since the last time EDPRSR was read when the Core power domain was on.EDPRSR.SPD reads-as-zero.EDPRSR.SPD is not cleared following a read of EDPRSR in these states.This means it is IMPLEMENTATION DEFINED whether a processor implements EDPRSR.SPD as:Fixed RAZ when in one or both of the retention and power-down states.Retaining its previous value when in the retention state.Fixed RAO in the power-down state.Note that this definition does not allow EDPRSR.SPD to be fixed RAO in the low-power retention state, as the state of the debug registers in the Core power domain is not lost by entering this state. However, the bit can be read as 1 in this state if the state of the registers was lost before entering this state (i.e. EDPRSR has not been read since the last Cold reset).ARM recommends that an implementation make EDPRSR.SPD fixed RAO when in the power-down state, particularly if it does not support a low-power retention state.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PU</spirit:name>
            <spirit:displayName>PU</spirit:displayName>
            <spirit:description>Core power-up status bit. Indicates whether the Core power domain debug registers can be accessed:
      0
      
      Core is in a low-power or power-down state where the debug registers cannot be accessed.
      
      
    
      1
      
      Core is in a power-up state where the debug registers can be accessed.
      
      
    </spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDRCR</spirit:name>
          <spirit:description>External Debug Reserve Control Register</spirit:description>
          <spirit:addressOffset>0x090</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDRCR -->
          <spirit:field>
            <spirit:name>RES0_EDRCR_31_5</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>27</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CBRRQ</spirit:name>
            <spirit:displayName>CBRRQ</spirit:displayName>
            <spirit:description>Allow imprecise entry to Debug state. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Allow imprecise entry to Debug state, for example by canceling pending bus accesses.
      
      
    Setting this bit to 1 allows a debugger to request imprecise entry to Debug state. An External Debug Request debug event must be pending before the debugger sets this bit to 1.This feature is optional. If this feature is not implemented, writes to this bit are ignored.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSPA</spirit:name>
            <spirit:displayName>CSPA</spirit:displayName>
            <spirit:description>Clear Sticky Pipeline Advance. This bit is used to clear the EDSCR.PipeAdv bit to 0. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Clear the EDSCR.PipeAdv bit to 0.
      
      
    </spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSE</spirit:name>
            <spirit:displayName>CSE</spirit:displayName>
            <spirit:description>Clear Sticky Error. Used to clear the EDSCR cumulative error bits to 0. The actions on writing to this bit are:
      0
      
      No action.
      
      
    
      1
      
      Clear the EDSCR.{TXU, RXO, ERR} bits, and, if the processor is in Debug state, the EDSCR.ITO bit, to 0.
      
      
    </spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDRCR_1_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDSCR</spirit:name>
          <spirit:description>External Debug Status and Control Register</spirit:description>
          <spirit:addressOffset>0x088</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xECFAC040</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDSCR -->
          <spirit:field>
            <spirit:name>RES0_EDSCR_31_31</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXfull</spirit:name>
            <spirit:displayName>RXfull</spirit:displayName>
            <spirit:description>DTRRX full. This bit is RO.</spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXfull</spirit:name>
            <spirit:displayName>TXfull</spirit:displayName>
            <spirit:description>DTRTX full. This bit is RO.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ITO</spirit:name>
            <spirit:displayName>ITO</spirit:displayName>
            <spirit:description>EDITR overrun. This bit is RO.If the processor is not in Debug state, this bit is UNKNOWN. ITO is set to 0 on entry to Debug state.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXO</spirit:name>
            <spirit:displayName>RXO</spirit:displayName>
            <spirit:description>DTRRX overrun. This bit is RO.</spirit:description>
            <spirit:bitOffset>27</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXU</spirit:name>
            <spirit:displayName>TXU</spirit:displayName>
            <spirit:description>DTRTX underrun. This bit is RO.</spirit:description>
            <spirit:bitOffset>26</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PipeAdv</spirit:name>
            <spirit:displayName>PipeAdv</spirit:displayName>
            <spirit:description>Pipeline advance. Read-only. Set to 1 every time the processor pipeline retires one or more instructions. Cleared to 0 by a write to EDRCR.CSPA.The architecture does not define precisely when this bit is set to 1. It requires only that this happen periodically in Non-debug state to indicate that software execution is progressing.</spirit:description>
            <spirit:bitOffset>25</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ITE</spirit:name>
            <spirit:displayName>ITE</spirit:displayName>
            <spirit:description>ITR empty. This bit is RO.If the processor is not in Debug state, this bit is UNKNOWN. It is always valid in Debug state.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>INTdis</spirit:name>
            <spirit:displayName>INTdis</spirit:displayName>
            <spirit:description>Interrupt disable. Disables taking interrupts (including virtual interrupts and System Error interrupts) in Non-Debug state.If external invasive debug is disabled, the value of this field is ignored.If external invasive debug is enabled, the possible values of this field are:
      00
      
      Do not disable interrupts
      
      
    
      01
      
      Disable interrupts targeting Non-secure EL1.
      
      
    
      10
      
      Disable interrupts targeting only Non-secure EL1 and Non-secure EL2. If external secure invasive debug is enabled, also disable interrupts targeting Secure EL1.
      
      
    
      11
      
      Disable interrupts targeting only Non-secure EL1 and Non-secure EL2. If external secure invasive debug is enabled, also disable all other interrupts.
      
      
    The value of INTdis does not affect whether an interrupt is a WFI wake-up event, but can mask an interrupt as a WFE wake-up event.If EL3 and EL2 are not implemented, INTdis[0] is RO and reads the same value as INTdis[1], meaning only the values 0b00 and 0b11 can be selected.</spirit:description>
            <spirit:bitOffset>22</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TDA</spirit:name>
            <spirit:displayName>TDA</spirit:displayName>
            <spirit:description>Trap debug registers accesses.</spirit:description>
            <spirit:bitOffset>21</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>MA</spirit:name>
            <spirit:displayName>MA</spirit:displayName>
            <spirit:description>Memory access mode. Controls use of memory-access mode for accessing EDITR and the DCC. This bit is ignored if in Non-debug state and set to zero on entry to Debug state.Possible values of this field are:
      0
      
      Normal access mode
      
      
    
      1
      
      Memory access mode.
      
      
    </spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDSCR_19_19</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>19</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>NS</spirit:name>
            <spirit:displayName>NS</spirit:displayName>
            <spirit:description>Non-secure status. Read-only. When in Debug state, gives the current security state:
      0
      
      Secure state, IsSecure() == TRUE
      
      
    
      1
      
      Non-secure state, IsSecure() == FALSE.
      
      
    In Non-debug state, this bit is UNKNOWN.</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDSCR_17_17</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SDD</spirit:name>
            <spirit:displayName>SDD</spirit:displayName>
            <spirit:description>Secure debug disabled. This bit is RO.On entry to Debug state:If entering in Secure state, SDD is set to 0.If entering in Non-secure state, SDD is set to the inverse of ExternalSecureInvasiveDebugEnabled().In Debug state, the value of the SDD bit does not change, even if ExternalSecureInvasiveDebugEnabled() changes.In Non-debug state:SDD returns the inverse of ExternalSecureInvasiveDebugEnabled(). If the authentication signals that control ExternalSecureInvasiveDebugEnabled() change, a context synchronization operation is required to guarantee their effect.This bit is unaffected by the Security state of the processor.If EL3 is not implemented and the implementation is Non-secure, this bit is RES1.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDSCR_15_15</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HDE</spirit:name>
            <spirit:displayName>HDE</spirit:displayName>
            <spirit:description>Halting debug mode enable. Possible values of this bit are:
      0
      
      Halting debug mode disabled.
      
      
    
      1
      
      Halting debug mode enabled.
      
      
    </spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RW</spirit:name>
            <spirit:displayName>RW</spirit:displayName>
            <spirit:description>Exception level register-width status. Read-only. In Debug state, each bit gives the current register width status of each EL:
      1111
      
      All exception levels are AArch64 state.
      
      
    
      1110
      
      EL0 is AArch32 state. All other exception levels are AArch64 state.
      
      
    
      1100
      
      EL0 and EL1 are AArch32 state. All other exception levels are AArch64 state. Never seen if EL2 is not implemented in the current security state.
      
      
    
      1000
      
      EL0, EL1, and, if implemented in the current security state, EL2 are AArch32 state. All other exception levels are AArch64 state.
      
      
    
      0000
      
      All exception levels are set to AArch32 state (32-bit configuration).
      
      
    However:If not at EL0: RW[0] == RW[1].If EL2 is not implemented in the current security state: RW[2] == RW[1].If EL3 is not implemented: RW[3] == RW[2].In Non-debug state, this field is RAO.</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL</spirit:name>
            <spirit:displayName>EL</spirit:displayName>
            <spirit:description>Exception level. Read-only. In Debug state, this gives the current EL of the processor.In Non-debug state, this field is RAZ.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>A</spirit:name>
            <spirit:displayName>A</spirit:displayName>
            <spirit:description>System Error interrupt pending. Read-only. In Debug state, indicates whether a SError interrupt is pending:If HCR_EL2.{AMO, TGE} = {1, 0} and in Non-secure EL0 or EL1, a virtual SError interrupt.Otherwise, a physical SError interrupt.
      0
      
      No SError interrupt pending.
      
      
    
      1
      
      SError interrupt pending.
      
      
    A debugger can read EDSCR to check whether a SError interrupt is pending without having to execute further instructions. A pending SError might indicate data from target memory is corrupted.UNKNOWN in Non-debug state.</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERR</spirit:name>
            <spirit:displayName>ERR</spirit:displayName>
            <spirit:description>Cumulative error flag. This field is RO. It is set to 1 following exceptions in Debug state and on any signaled overrun or underrun on the DTR or EDITR.</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>STATUS</spirit:name>
            <spirit:displayName>STATUS</spirit:displayName>
            <spirit:description>Debug status flags. This field is RO.The possible values of this field are:
      000010
      
      Processor is in Non-debug state.
      
      
    
      000001
      
      Processor is restarting (exiting Debug state).
      
      
    
      000111
      
      Breakpoint.
      
      
    
      010011
      
      External debug request.
      
      
    
      011011
      
      Halting step, normal.
      
      
    
      011111
      
      Halting step, exclusive.
      
      
    
      100011
      
      OS unlock catch.
      
      
    
      100111
      
      Reset catch.
      
      
    
      101011
      
      Watchpoint.
      
      
    
      101111
      
      HLT instruction.
      
      
    
      110011
      
      Software access to debug register.
      
      
    
      110111
      
      Exception catch.
      
      
    
      111011
      
      Halting step, no syndrome.
      
      
    All other values of STATUS are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>6</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDVIDSR</spirit:name>
          <spirit:description>External Debug Virtual Context Sample Register</spirit:description>
          <spirit:addressOffset>0x0A8</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0x0FFFFF00</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: EDVIDSR -->
          <spirit:field>
            <spirit:name>NS</spirit:name>
            <spirit:displayName>NS</spirit:displayName>
            <spirit:description>Non-secure state sample. Indicates the security state associated with the most recent EDPCSR sample.</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E2</spirit:name>
            <spirit:displayName>E2</spirit:displayName>
            <spirit:description>Exception level 2 status sample. Indicates whether the most recent EDPCSR sample was associated with EL2. If EDVIDSR.NS == 0, this bit is 0.</spirit:description>
            <spirit:bitOffset>30</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>E3</spirit:name>
            <spirit:displayName>E3</spirit:displayName>
            <spirit:description>Exception level 3 status sample. Indicates whether the most recent EDPCSR sample was associated with AArch64 EL3. If EDVIDSR.NS == 1 or the processor was in AArch32 state when EDPCSR was read, this bit is 0.</spirit:description>
            <spirit:bitOffset>29</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>HV</spirit:name>
            <spirit:displayName>HV</spirit:displayName>
            <spirit:description>EDPCSR high half valid. Indicates whether bits [63:32] of the most recent EDPCSR sample are valid. If EDVIDSR.HV == 0, the value of EDPCSR[63:32] is RAZ.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_EDVIDSR_27_8</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>VMID</spirit:name>
            <spirit:displayName>VMID</spirit:displayName>
            <spirit:description>VMID sample. The value of VTTBR_EL2.VMID associated with the most recent EDPCSR sample. If EDVIDSR.NS == 0 or EDVIDSR.E2 == 1, this field is RAZ.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDWAR_31:0</spirit:name>
          <spirit:description>External Debug Watchpoint Address Register (low word)</spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDWAR_31:0 -->
          <spirit:field>
            <spirit:name>EDWAR_31:0</spirit:name>
            <spirit:displayName>EDWAR_31:0</spirit:displayName>
            <spirit:description>Watchpoint address. The virtual data address being accessed when a watchpoint debug event was triggered and caused entry to Debug state.UNKNOWN if the processor is not in Debug state, or if Debug state was entered other than for a watchpoint debug event.The address must be within a naturally-aligned block of memory of power-of-two size no larger than the DC ZVA block size.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>EDWAR_63:32</spirit:name>
          <spirit:description>External Debug Watchpoint Address Register (high word)</spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <!--  Adding Fields for register: EDWAR_63:32 -->
          <spirit:field>
            <spirit:name>EDWAR_63:32</spirit:name>
            <spirit:displayName>EDWAR_63:32</spirit:displayName>
            <spirit:description>Watchpoint address. The virtual data address being accessed when a watchpoint debug event was triggered and caused entry to Debug state.UNKNOWN if the processor is not in Debug state, or if Debug state was entered other than for a watchpoint debug event.The address must be within a naturally-aligned block of memory of power-of-two size no larger than the DC ZVA block size.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR0_EL1_31:0</spirit:name>
          <spirit:description>Debug Feature Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD28</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x10305106</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>CTX_CMPs</spirit:name>
            <spirit:displayName>CTX_CMPs</spirit:displayName>
            <spirit:description>Number of breakpoints that are context-aware, minus 1. These are the highest numbered breakpoints.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR0_EL1_31:0_27_24</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>WRPs</spirit:name>
            <spirit:displayName>WRPs</spirit:displayName>
            <spirit:description>Number of watchpoints, minus 1. The value of 0b0000 is reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR0_EL1_31:0_19_16</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BRPs</spirit:name>
            <spirit:displayName>BRPs</spirit:displayName>
            <spirit:description>Number of breakpoints, minus 1. The value of 0b0000 is reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PMUVer</spirit:name>
            <spirit:displayName>PMUVer</spirit:displayName>
            <spirit:description>Performance Monitors extension version. Indicates whether system register interface to Performance Monitors extension is implemented. Permitted values are:
      0000
      
      Performance Monitors extension system registers not implemented.
      
      
    
      0001
      
      Performance Monitors extension system registers implemented, PMUv3.
      
      
    
      1111
      
      IMPLEMENTATION DEFINED form of performance monitors supported, PMUv3 not supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TraceVer</spirit:name>
            <spirit:displayName>TraceVer</spirit:displayName>
            <spirit:description>Trace extension. Indicates whether system register interface to Trace extension is implemented. Permitted values are:
      0000
      
      Trace extension system registers not implemented.
      
      
    
      0001
      
      Trace extension system registers implemented.
      
      
    All other values are reserved.A value of 0b0000 only indicates that no system register interface to the trace extension is implemented. A trace extension may nevertheless be implemented without a system register interface.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>DebugVer</spirit:name>
            <spirit:displayName>DebugVer</spirit:displayName>
            <spirit:description>Debug architecture version. Indicates presence of v8-A debug architecture.
      0110
      
      v8-A debug architecture.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR0_EL1_63:32</spirit:name>
          <spirit:description>Debug Feature Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD2C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR1_EL1_31:0</spirit:name>
          <spirit:description>Auxiliary Feature Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD48</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64DFR1_EL1_63:32</spirit:name>
          <spirit:description>Auxiliary Feature Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD4C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64DFR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64DFR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR0_EL1_31:0</spirit:name>
          <spirit:description>Instruction Set Attribute Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD30</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="immediate">65536</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR0_EL1_31:0_31_20</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRC32</spirit:name>
            <spirit:displayName>CRC32</spirit:displayName>
            <spirit:description>CRC32 instructions in AArch64. Possible values of this field are:
      0000
      
      No CRC32 instructions implemented.
      
      
    
      0001
      
      CRC32B, CRC32H, CRC32W, CRC32X, CRC32CB, CRC32CH, CRC32CW, and CRC32CX instructions implemented.
      
      
    All other values are reserved.This field must have the same value as ID_ISAR5.CRC32. The architecture requires that if CRC32 is supported in one Execution state, it must be supported in both Execution states.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SHA2</spirit:name>
            <spirit:displayName>SHA2</spirit:displayName>
            <spirit:description>SHA2 instructions in AArch64. Possible values of this field are:
      0000
      
      No SHA2 instructions implemented.
      
      
    
      0001
      
      SHA256H, SHA256H2, SHA256SU0, and SHA256SU1 instructions implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SHA1</spirit:name>
            <spirit:displayName>SHA1</spirit:displayName>
            <spirit:description>SHA1 instructions in AArch64. Possible values of this field are:
      0000
      
      No SHA1 instructions implemented.
      
      
    
      0001
      
      SHA1C, SHA1P, SHA1M, SHA1H, SHA1SU0, and SHA1SU1 instructions implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AES</spirit:name>
            <spirit:displayName>AES</spirit:displayName>
            <spirit:description>AES instructions in AArch64. Possible values of this field are:
      0000
      
      No AES instructions implemented.
      
      
    
      0001
      
      AESE, AESD, AESMC, and AESIMC instructions implemented.
      
      
    
      0010
      
      As for 0b0001, plus PMULL/PMULL2 instructions operating on 64-bit data quantities.
      
      
    </spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR0_EL1_31:0_3_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR0_EL1_63:32</spirit:name>
          <spirit:description>Instruction Set Attribute Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD34</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR1_EL1_31:0</spirit:name>
          <spirit:description>Instruction Set Attribute Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD50</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64ISAR1_EL1_63:32</spirit:name>
          <spirit:description>Instruction Set Attribute Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD54</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64ISAR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64ISAR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR0_EL1_31:0</spirit:name>
          <spirit:description>Memory Model Feature Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD38</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00001122</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>TGran4</spirit:name>
            <spirit:displayName>TGran4</spirit:displayName>
            <spirit:description>Support for 4 Kbyte memory translation granule size. Permitted values are:
      0000
      
      4 KB granule supported.
      
      
    
      1111
      
      4 KB granule not supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGran64</spirit:name>
            <spirit:displayName>TGran64</spirit:displayName>
            <spirit:description>Support for 64 Kbyte memory translation granule size. Permitted values are:
      0000
      
      64 KB granule supported.
      
      
    
      1111
      
      64 KB granule not supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGran16</spirit:name>
            <spirit:displayName>TGran16</spirit:displayName>
            <spirit:description>Support for 16 Kbyte memory translation granule size. Permitted values are:
      0000
      
      16 KB granule not supported.
      
      
    
      0001
      
      16 KB granule supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BigEndEL0</spirit:name>
            <spirit:displayName>BigEndEL0</spirit:displayName>
            <spirit:description>Mixed-endian support at EL0 only. Permitted values are:
      0000
      
      No mixed-endian support at EL0. The SCTLR_EL1.E0E bit has a fixed value.
      
      
    
      0001
      
      Mixed-endian support at EL0. The SCTLR_EL1.E0E bit can be configured.
      
      
    All other values are reserved.This field is invalid and is RES0 if the BigEnd field, bits [11:8], is not 0b0000.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNSMem</spirit:name>
            <spirit:displayName>SNSMem</spirit:displayName>
            <spirit:description>Secure versus Non-secure Memory distinction. Permitted values are:
      0000
      
      Does not support a distinction between Secure and Non-secure Memory.
      
      
    
      0001
      
      Does support a distinction between Secure and Non-secure Memory.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>BigEnd</spirit:name>
            <spirit:displayName>BigEnd</spirit:displayName>
            <spirit:description>Mixed-endian configuration support. Permitted values are:
      0000
      
      No mixed-endian support. The SCTLR_ELx.EE bits have a fixed value. See the BigEndEL0 field, bits[19:16], for whether EL0 supports mixed-endian.
      
      
    
      0001
      
      Mixed-endian support. The SCTLR_ELx.EE and SCTLR_EL1.E0E bits can be configured.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>ASIDBits</spirit:name>
            <spirit:displayName>ASIDBits</spirit:displayName>
            <spirit:description>Number of ASID bits. Permitted values are:
      0000
      
      8 bits.
      
      
    
      0010
      
      16 bits.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PARange</spirit:name>
            <spirit:displayName>PARange</spirit:displayName>
            <spirit:description>Physical Address range supported. Permitted values are:
      0000
      
      32 bits, 4 GB.
      
      
    
      0001
      
      36 bits, 64 GB.
      
      
    
      0010
      
      40 bits, 1 TB.
      
      
    
      0011
      
      42 bits, 4 TB.
      
      
    
      0100
      
      44 bits, 16 TB.
      
      
    
      0101
      
      48 bits, 256 TB.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR0_EL1_63:32</spirit:name>
          <spirit:description>Memory Model Feature Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD3C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64MMFR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR1_EL1_31:0</spirit:name>
          <spirit:description>Memory Model Feature Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD58</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64MMFR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64MMFR1_EL1_63:32</spirit:name>
          <spirit:description>Memory Model Feature Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD5C</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64MMFR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64MMFR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR0_EL1_31:0</spirit:name>
          <spirit:description>Processor Feature Register 0 (low word)</spirit:description>
          <spirit:addressOffset>0xD20</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="immediate">16785954</spirit:value>
            <spirit:mask>0xF0FFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR0_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR0_EL1_31:0_31_28</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>28</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>GIC</spirit:name>
            <spirit:displayName>GIC</spirit:displayName>
            <spirit:description>GIC system register interface. Permitted values are:
      0000
      
      No GIC system registers are supported.
      
      
    
      0001
      
      GICv3 system registers are supported.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>AdvSIMD</spirit:name>
            <spirit:displayName>AdvSIMD</spirit:displayName>
            <spirit:description>Advanced SIMD. Permitted values are:
      0000
      
      Advanced SIMD is implemented.
      
      
    
      1111
      
      Advanced SIMD is not implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>FP</spirit:name>
            <spirit:displayName>FP</spirit:displayName>
            <spirit:description>Floating-point. Permitted values are:
      0000
      
      Floating-point is implemented.
      
      
    
      1111
      
      Floating-point is not implemented.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL3</spirit:name>
            <spirit:displayName>EL3</spirit:displayName>
            <spirit:description>EL3 exception level handling. Permitted values are:
      0000
      
      EL3 is not implemented.
      
      
    
      0001
      
      EL3 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL3 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL2</spirit:name>
            <spirit:displayName>EL2</spirit:displayName>
            <spirit:description>EL2 exception level handling. Permitted values are:
      0000
      
      EL2 is not implemented.
      
      
    
      0001
      
      EL2 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL2 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL1</spirit:name>
            <spirit:displayName>EL1</spirit:displayName>
            <spirit:description>EL1 exception level handling. Permitted values are:
      0000
      
      EL1 is not implemented.
      
      
    
      0001
      
      EL1 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL1 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>EL0</spirit:name>
            <spirit:displayName>EL0</spirit:displayName>
            <spirit:description>EL0 exception level handling. Permitted values are:
      0000
      
      EL0 is not implemented.
      
      
    
      0001
      
      EL0 can be executed in AArch64 state only.
      
      
    
      0010
      
      EL0 can be executed in either AArch64 or AArch32 state.
      
      
    All other values are reserved.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR0_EL1_63:32</spirit:name>
          <spirit:description>Processor Feature Register 0 (high word)</spirit:description>
          <spirit:addressOffset>0xD24</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR0_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR0_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR1_EL1_31:0</spirit:name>
          <spirit:description>Processor Feature Register 1 (low word)</spirit:description>
          <spirit:addressOffset>0xD40</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR1_EL1_31:0 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR1_EL1_31:0_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>ID_AA64PFR1_EL1_63:32</spirit:name>
          <spirit:description>Processor Feature Register 1 (high word)</spirit:description>
          <spirit:addressOffset>0xD44</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: ID_AA64PFR1_EL1_63:32 -->
          <spirit:field>
            <spirit:name>RES0_ID_AA64PFR1_EL1_63:32_31_0</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>MIDR_EL1</spirit:name>
          <spirit:description>Main ID Register</spirit:description>
          <spirit:addressOffset>0xD00</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x410FD034</spirit:value>
            <spirit:mask>0xFFFFFFFF</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: MIDR_EL1 -->
          <spirit:field>
            <spirit:name>Implementer</spirit:name>
            <spirit:displayName>Implementer</spirit:displayName>
            <spirit:description>The Implementer code. This field must hold an implementer code that has been assigned by ARM.</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>Variant</spirit:name>
            <spirit:displayName>Variant</spirit:displayName>
            <spirit:description>An IMPLEMENTATION DEFINED variant number. Typically this field is used to distinguish between different product variants or major revisions of a product.</spirit:description>
            <spirit:bitOffset>20</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>Architecture</spirit:name>
            <spirit:displayName>Architecture</spirit:displayName>
            <spirit:description> </spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>PartNum</spirit:name>
            <spirit:displayName>PartNum</spirit:displayName>
            <spirit:description>An IMPLEMENTATION DEFINED primary part number for the device. On processors implemented by ARM if the top four bits of the primary part number are 0x0 or 0x7 the variant and architecture are encoded differently</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>Revision</spirit:name>
            <spirit:displayName>Revision</spirit:displayName>
            <spirit:description>An IMPLEMENTATION DEFINED revision number for the device</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        <spirit:register>
          <spirit:name>OSLAR_EL1</spirit:name>
          <spirit:description>OS Lock Access Register</spirit:description>
          <spirit:addressOffset>0x300</spirit:addressOffset>
          <spirit:size>32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value>0x00000000</spirit:value>
            <spirit:mask>0xFFFFFFFE</spirit:mask>
          </spirit:reset>
          <!--  Adding Fields for register: OSLAR_EL1 -->
          <spirit:field>
            <spirit:name>RES0_OSLAR_EL1_31_1</spirit:name>
            <spirit:displayName>0</spirit:displayName>
            <spirit:description>Reserved, RES0.</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>31</spirit:bitWidth>
          </spirit:field>
          <spirit:field>
            <spirit:name>OSLK</spirit:name>
            <spirit:displayName>OSLK</spirit:displayName>
            <spirit:description>On writes to OSLAR_EL1, bit[0] is copied to the OS lock.Use EDPRSR.OSLK to check the current status of the lock.</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
          </spirit:field>
          
        </spirit:register>
        
      </spirit:addressBlock>
    </spirit:memoryMap>
  </spirit:memoryMaps>
  <!-- Model Section -->
  <spirit:model>
    <!-- Views Section -->
    <spirit:views>
      <spirit:view>
        <spirit:name>RTL</spirit:name>
        <spirit:displayName>CPU RTL</spirit:displayName>
        <spirit:description>CPU RTL for CortexA53</spirit:description>
        <spirit:envIdentifier>verilogSource:*Simulation:</spirit:envIdentifier>
        <spirit:envIdentifier>verilogSource:*Synthesis:</spirit:envIdentifier>
        <spirit:language>verilog</spirit:language>
        <spirit:modelName>CORTEXA53</spirit:modelName>
        <spirit:fileSetRef>
          <spirit:localName>RTL</spirit:localName>
        </spirit:fileSetRef>
      </spirit:view>
    </spirit:views>
    <!--  model=>ports section  -->
    <spirit:ports>
      <spirit:port>
        <spirit:name>CLKIN</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nCPUPORESET</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nCORERESET</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nL2RESET</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>L2RSTDISABLE</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CFGEND</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>VINITHI</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CFGTE</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CP15SDISABLE</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CLUSTERIDAFF1</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>7</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CLUSTERIDAFF2</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>7</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>AA64nAA32</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>RVBARADDR0</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>39</spirit:left>
            <spirit:right>2</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RVBARADDR1</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>39</spirit:left>
            <spirit:right>2</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RVBARADDR2</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>39</spirit:left>
            <spirit:right>2</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RVBARADDR3</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>39</spirit:left>
            <spirit:right>2</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      
      <spirit:port>
        <spirit:name>nFIQ</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nIRQ</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nSEI</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nVFIQ</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nVIRQ</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nVSEI</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nREI</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>PERIPHBASE</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>39</spirit:left>
            <spirit:right>18</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>GICCDISABLE</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ICDTVALID</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ICDTDATA</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>15</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0000</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ICDTLAST</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ICDTDEST</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ICCTREADY</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CNTVALUEB</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>63</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0000000000000000</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CNTCLKEN</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CLREXMONREQ</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>EVENTI</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>L2FLUSHREQ</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>CPUQREQn</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>NEONQREQn</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>L2QREQn</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>BROADCASTCACHEMAINT</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>BROADCASTINNER</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>BROADCASTOUTER</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>SYSBARDISABLE</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
      </spirit:port>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <spirit:port>
        <spirit:name>ACLKENM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ACINACTM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWREADYM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WREADYM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>BVALIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>BIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>4</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>BRESPM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARREADYM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RVALIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>5</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RDATAM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>127</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RRESPM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RLASTM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ACVALIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ACADDRM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>43</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ACPROTM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>2</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ACSNOOPM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>CRREADYM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>CDREADYM</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ACLKENS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AINACTS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWVALIDS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWIDS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>4</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x00</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWADDRS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>39</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0000000000</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWLENS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>7</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x00</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWCACHES</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWUSERS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWPROTS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>2</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WVALIDS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WDATAS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>127</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x00000000000000000000000000000000</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WSTRBS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>15</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0000</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WLASTS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>BREADYS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARVALIDS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARIDS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>4</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x00</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARADDRS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>39</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0000000000</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARLENS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>7</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x00</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARCACHES</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARUSERS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARPROTS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>2</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RREADYS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>nPRESETDBG</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>PCLKENDBG</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>PSELDBG</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>PADDRDBG</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>21</spirit:left>
            <spirit:right>2</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x00000</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>PADDRDBG31</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>PENABLEDBG</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>PWRITEDBG</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>PWDATADBG</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>31</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x00000000</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DBGROMADDR</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>39</spirit:left>
            <spirit:right>12</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DBGROMADDRV</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>EDBGRQ</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DBGEN</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>NIDEN</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>SPIDEN</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>SPNIDEN</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DBGPWRDUP</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DBGL1RSTDISABLE</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ATCLKEN</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ATREADYM0</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATREADYM1</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATREADYM2</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATREADYM3</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AFVALIDM0</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AFVALIDM1</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AFVALIDM2</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AFVALIDM3</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>SYNCREQM0</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>SYNCREQM1</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>SYNCREQM2</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>SYNCREQM3</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>TSVALUEB</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>63</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CTICHIN</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CTICHOUTACK</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CISBYPASS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CIHSBYPASS</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left>3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CTIIRQACK</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DFTSE</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DFTRSTDISABLE</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DFTRAMHOLD</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DFTMCPHOLD</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>MBISTREQ</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:driver>
            <spirit:defaultValue>0x0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nMBISTRESET</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>WARMRSTREQ</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nVCPUMNTIRQ</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ICDTREADY</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ICCTVALID</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ICCTDATA</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>15</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ICCTLAST</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ICCTID</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nCNTPNSIRQ</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nCNTPSIRQ</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nCNTVIRQ</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nCNTHPIRQ</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CLREXMONACK</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>EVENTO</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>STANDBYWFI</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>STANDBYWFE</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>STANDBYWFIL2</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>L2FLUSHDONE</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>SMPEN</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CPUQACTIVE</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CPUQDENY</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CPUQACCEPTn</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>NEONQACTIVE</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>NEONQDENY</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>NEONQACCEPTn</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>L2QACTIVE</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>L2QDENY</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>L2QACCEPTn</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      
      <spirit:port>
        <spirit:name>nEXTERRIRQ</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
      </spirit:port>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <spirit:port>
        <spirit:name>RDMEMATTR</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>7</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WRMEMATTR</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>7</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWVALIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>4</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWADDRM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>43</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWLENM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>7</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWSIZEM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>2</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWBURSTM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWBARM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWDOMAINM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWLOCKM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWCACHEM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWPROTM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>2</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWSNOOPM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>2</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWUNIQUEM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WVALIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>4</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WDATAM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>127</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WSTRBM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>15</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WLASTM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>BREADYM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARVALIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>5</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARADDRM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>43</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARLENM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>7</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARSIZEM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>2</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARBURSTM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARBARM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARDOMAINM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARLOCKM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARCACHEM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARPROTM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>2</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARSNOOPM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RREADYM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ACREADYM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>CRVALIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>CRRESPM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>4</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>CDVALIDM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>CDDATAM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>127</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>CDLASTM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RACKM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WACKM</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AWREADYS</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>WREADYS</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>BVALIDS</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>BIDS</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>4</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>BRESPS</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ARREADYS</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RVALIDS</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RIDS</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>4</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RDATAS</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>127</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RRESPS</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>RLASTS</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>PRDATADBG</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>31</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>PREADYDBG</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>PSLVERRDBG</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DBGACK</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nCOMMIRQ</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>COMMRX</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>COMMTX</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DBGRSTREQ</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DBGNOPWRDWN</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>DBGPWRUPREQ</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ATDATAM0</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>31</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATDATAM1</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>31</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATDATAM2</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>31</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATDATAM3</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>31</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATVALIDM0</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATVALIDM1</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATVALIDM2</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATVALIDM3</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATBYTESM0</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATBYTESM1</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATBYTESM2</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATBYTESM3</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>1</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AFREADYM0</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AFREADYM1</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AFREADYM2</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>AFREADYM3</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATIDM0</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>6</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATIDM1</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>6</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATIDM2</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>6</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>ATIDM3</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>6</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>CTICHOUT</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CTICHINACK</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>CTIIRQ</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>nPMUIRQ</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="immediate">3</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>PMUEVENT0</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>29</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>PMUEVENT1</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>29</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>PMUEVENT2</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>29</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
      <spirit:port>
        <spirit:name>PMUEVENT3</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left>29</spirit:left>
            <spirit:right>0</spirit:right>
          </spirit:vector>
        </spirit:wire>
        
      </spirit:port>
    </spirit:ports>
  </spirit:model>
  <!--  Choices section  -->
  <spirit:choices>
    <spirit:choice>
      <spirit:name>l2_size</spirit:name>
      <spirit:enumeration spirit:text="1024K">0111</spirit:enumeration>
      <spirit:enumeration spirit:text="256K">0001</spirit:enumeration>
      <spirit:enumeration spirit:text="2048K">1111</spirit:enumeration>
      <spirit:enumeration spirit:text="128K">0000</spirit:enumeration>
      <spirit:enumeration spirit:text="512K">0011</spirit:enumeration>
    </spirit:choice>
    <spirit:choice>
      <spirit:name>l1_size</spirit:name>
      <spirit:enumeration spirit:text="32K">011</spirit:enumeration>
      <spirit:enumeration spirit:text="8K">000</spirit:enumeration>
      <spirit:enumeration spirit:text="64K">111</spirit:enumeration>
      <spirit:enumeration spirit:text="16K">001</spirit:enumeration>
    </spirit:choice>
    <spirit:choice>
      <spirit:name>yes_no</spirit:name>
      <spirit:enumeration spirit:text="No">0</spirit:enumeration>
      <spirit:enumeration spirit:text="Yes">1</spirit:enumeration>
    </spirit:choice>
  </spirit:choices>
  <!--  Filesets section  -->
  <spirit:fileSets>
    <!--  Verilog File Section  -->
    <spirit:fileSet>
      <spirit:name>RTL</spirit:name>
      <spirit:displayName>CortexA53 RTL source</spirit:displayName>
      <spirit:description>This is the RTL source for CortexA53</spirit:description>
      <spirit:file>
        <spirit:name>../../cortexa53/verilog/ca53_cpu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../cortexa53/verilog/ca53_l2.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../cortexa53/verilog/ca53_l2noram.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../cortexa53/verilog/ca53_noram.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../cortexa53/verilog/ca53_cpu_reset.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_acpslv.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_afb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_buf_age.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_clk.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_config.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_cpuslv.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_dvmcomp.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_l2db.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_lfsr.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_lfsr_arb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_master.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_master_ace.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_master_retries.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_master_skyros.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_ramctl.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_reqbuf_acp.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_reqbuf_ecc.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_reqbuf_cpu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_reqbuf_snp.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_reqbuf_sync.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_sam.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_snpslv.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_tagctl.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_tagctl_ecc.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53scu/verilog/ca53scu_victimctl.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_agu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_au.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_clz.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_crc32.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_extract.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_extract_64.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_gen_sat.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_lu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_mask_imm.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_maskgen.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_masksel.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_rbit.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_rbit_64.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_sat_dbl.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_sbitx.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_shift.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_alu_simd_sat.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_br.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_cp.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_cpsr.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      
      
      
      
      
      
      
      
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_ctl.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_ctl_reg_aa32_aa64.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_ctl_reg_trans.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_ctl_regexpand.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dbg.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_de.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_de_pc.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_de_reg_extract.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_de_reg_trans.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_de_regexpand.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_de_rp_dec.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec0_br.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec0_dp.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec0_ls.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec0_neon.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec0_other.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec1.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec1_br.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec1_late_neon.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec1_ls.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec1_neon.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec_forceop.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec_imm_dp.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec_imm_ls.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec_imm_other.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dec_late_neon.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_div.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_div_csa.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_div_quot.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_dp.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_early_exception.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_etmif.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_exception.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_alu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_alu_denorm.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_alu_renorm.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_cg.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_clz106.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_clz24.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_clz54.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_clz64.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_div.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_dp.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_mul.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_mul_array.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_regbank.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_shift7.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_unpack_opa.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_fp_unpack_opb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_functions.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_iq.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_iq_dih.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_ldst.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_mac.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_neon_ld.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_neon_lu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_neon_perm_ctl.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_neon_permutation.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_neon_polymul.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_neon_reduce.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_neon_shift.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_neon_shift8.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_neon_shift_sat.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_neon_swap_max.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_neon_vector_maxmin.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_neon_vrec_est.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_params.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_pmu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_psr_regfile.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_regbank.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_search_rl.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_special.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_store.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_swizzle_load.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_swizzle_store.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_utlb_intf_entry.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dpu/verilog/ca53dpu_utlb_main_entry.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53tlb/verilog/ca53tlb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53tlb/verilog/ca53tlb_cp_regs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53tlb/verilog/ca53tlb_dbg.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53tlb/verilog/ca53tlb_lookup.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53tlb/verilog/ca53tlb_pagewalk.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53tlb/verilog/ca53tlb_ramctl.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53tlb/verilog/ca53tlb_dbg_bkpt.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53tlb/verilog/ca53tlb_dbg_wpt.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53tlb/verilog/ca53tlb_remap.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53tlb/verilog/ca53tlb_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53stb/verilog/ca53stb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53stb/verilog/ca53stb_slot.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53stb/verilog/ca53stb_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53cti/verilog/ca53cti.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53cti/verilog/ca53cti_apbif.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53cti/verilog/ca53cti_ci.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53cti/verilog/ca53cti_mapper.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53cti/verilog/ca53cti_ti.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53cti/verilog/ca53cti_clkgate.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_apb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_clk.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_cmp.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_counter.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_derived_res.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_event.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_extin.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_extout.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_fifo.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_fifo_pack.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_fifo_rotate.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_params.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_resources.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_rsrc_sel.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_rsrc_sel_pair.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_trace_gen.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_traceout.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_val_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53etm/verilog/ca53etm_viewinst.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_cp15.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_ctl.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_lfb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_lfb_ctl.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pd.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pd_a32.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pd_a64.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pd_debug_dec.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pd_debug_dec_a64.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pd_debug_dec_t32.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pd_slice.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pd_t16.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pd_t32.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pd_thumb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pdc.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pdc_t16.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pdc_t32.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_bpd.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_btac.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_btic.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_crs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_dec_branch.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_dec_branch_s32.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_dec_class.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_dec_d1.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_dec_t16t32.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_iq_format_i0.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_iq_format_i1.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_iq_format_ret.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_it_undef.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_pdc_checker.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_throttle.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_utlb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_utlb_intf_entry.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53ifu/verilog/ca53ifu_pf_utlb_main_entry.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dcu/verilog/ca53dcu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dcu/verilog/ca53dcu_cachearb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dcu/verilog/ca53dcu_ccbctl.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dcu/verilog/ca53dcu_cp15.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dcu/verilog/ca53dcu_lspipe.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dcu/verilog/ca53dcu_cachearb_seq_state.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dcu/verilog/ca53dcu_dvm.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dcu/verilog/ca53dcu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53dcu/verilog/ca53dcu_ecc_correction.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ace_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_biu_dpu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_biu_dpu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_biu_rams.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_biu_rams_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_biu_scu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_biu_scu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_biu_tlb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_biu_tlb_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dcu_biu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dcu_biu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dcu_ifu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dcu_ifu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dcu_rams.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dcu_rams_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dcu_stb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dcu_stb_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dcu_tlb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dcu_tlb_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_dcu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_dcu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_etm.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_etm_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_gic.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_gic_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_gov.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_gov_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_ifu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_ifu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_l2rams.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_l2rams_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_rams.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_rams_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_scu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_scu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_tlb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_dpu_tlb_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ecc_check32.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ecc_check33.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ecc_check64.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ecc_fatal32.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ecc_fatal33.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ecc_fatal64.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ecc_generate32.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ecc_generate33.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ecc_generate64.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ecc_repair32.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ecc_repair33.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ecc_repair64.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_etm_gov.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_etm_gov_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gic_ext.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gic_ext_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gic_gov.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gic_gov_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gicarb_ext.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gicarb_ext_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gov_biu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gov_biu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gov_dcu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gov_dcu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gov_ifu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gov_ifu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gov_scu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gov_scu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gov_stb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gov_stb_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gov_tlb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_gov_tlb_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ifu_biu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ifu_biu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ifu_rams.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ifu_rams_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ifu_tlb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_ifu_tlb_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_rr_arb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_rr_reg_arb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_scu_dcu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_scu_dcu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_scu_ext.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_scu_ext_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_scu_rams.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_scu_rams_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_stb_biu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_stb_biu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_stb_dpu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_stb_dpu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_stb_rams.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_stb_rams_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_stb_scu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_stb_scu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_tlb_etm.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_tlb_etm_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_tlb_rams.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/ca53_tlb_rams_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../shared/verilog/cortexa53params.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../models/rams/generic/ca53_caches_tlb_rams.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../models/rams/generic/ca53_l2_datarams.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../models/rams/generic/ca53_l2_tagrams.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../models/rams/generic/ca53scu_l1d_tagrams.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../models/rams/generic/ca53_generic_ram.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53biu/verilog/ca53biu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53biu/verilog/ca53biu_addr_req_arbiter.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53biu/verilog/ca53biu_data_read_buffers.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53biu/verilog/ca53biu_data_write_buffers.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53biu/verilog/ca53biu_devsplit_mngmt.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53biu/verilog/ca53biu_linefills_mngmt.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53biu/verilog/ca53biu_dvm_enc.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53biu/verilog/ca53biu_linefill_descriptor.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53biu/verilog/ca53biu_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53biu/verilog/ca53biu_prefetch_stream_mngmt.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53biu/verilog/ca53biu_dcu_alloc_mngmt.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gic/verilog/ca53gic_arb.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gic/verilog/ca53gic_arb_m.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gic/verilog/ca53gic_arb_s.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gic/verilog/ca53gic_cpu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gic/verilog/ca53gic_cpu_cpacket.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gic/verilog/ca53gic_cpu_cpo.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gic/verilog/ca53gic_cpu_dpacket.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gic/verilog/ca53gic_cpu_pcpu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gic/verilog/ca53gic_cpu_vcpu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gic/verilog/ca53gic_defs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_apb_bridge.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_apb_dec.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_cpu.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_cpu_atb_bridge.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_cpu_clk_reset.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_cpu_debug.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_cpu_power.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_cpu_slice.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_cpu_timers.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_ctm.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_power.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_romtable.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ca53gov/verilog/ca53governor_slice.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../models/cells/generic/ca53_cell_inter_clkgate.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../models/cells/generic/ca53_cell_clkgate.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../models/cells/generic/ca53_cell_sync.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../cortexa53/verilog/CORTEXA53.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
      </spirit:file>
      <spirit:dependency>../../ca53gic/verilog</spirit:dependency>
      <spirit:dependency>../../ca53stb/verilog</spirit:dependency>
      <spirit:dependency>../../ca53scu/verilog</spirit:dependency>
      <spirit:dependency>../../ca53etm/verilog</spirit:dependency>
      <spirit:dependency>../../ca53gov/verilog</spirit:dependency>
      <spirit:dependency>../../cortexa53/verilog</spirit:dependency>
      <spirit:dependency>../../ca53dcu/verilog</spirit:dependency>
      <spirit:dependency>../../ca53cti/verilog</spirit:dependency>
      <spirit:dependency>../../ca53ifu/verilog</spirit:dependency>
      <spirit:dependency>../../models/cells/generic</spirit:dependency>
      <spirit:dependency>../../ca53biu/verilog</spirit:dependency>
      <spirit:dependency>../../models/rams/generic</spirit:dependency>
      <spirit:dependency>../../ca53dpu/verilog</spirit:dependency>
      <spirit:dependency>../../ca53tlb/verilog</spirit:dependency>
      <spirit:dependency>../../shared/verilog</spirit:dependency>
    </spirit:fileSet>
  </spirit:fileSets>
  <!--  CPUs section  -->
  <spirit:cpus>
    <spirit:cpu>
      <spirit:name>CPU0</spirit:name>
      <spirit:displayName>CPU Core 0</spirit:displayName>
      <spirit:description>CPU Core 0</spirit:description>
      <spirit:addressSpaceRef spirit:addressSpaceRef="Main_Bus"/>
      <spirit:addressSpaceRef spirit:addressSpaceRef="GIC_CPU0"/>
      
    </spirit:cpu>
    <spirit:cpu>
      <spirit:name>CPU1</spirit:name>
      <spirit:displayName>CPU Core 1</spirit:displayName>
      <spirit:description>CPU Core 1</spirit:description>
      <spirit:addressSpaceRef spirit:addressSpaceRef="Main_Bus"/>
      <spirit:addressSpaceRef spirit:addressSpaceRef="GIC_CPU1"/>
      
    </spirit:cpu>
    <spirit:cpu>
      <spirit:name>CPU2</spirit:name>
      <spirit:displayName>CPU Core 2</spirit:displayName>
      <spirit:description>CPU Core 2</spirit:description>
      <spirit:addressSpaceRef spirit:addressSpaceRef="Main_Bus"/>
      <spirit:addressSpaceRef spirit:addressSpaceRef="GIC_CPU2"/>
      
    </spirit:cpu>
    <spirit:cpu>
      <spirit:name>CPU3</spirit:name>
      <spirit:displayName>CPU Core 3</spirit:displayName>
      <spirit:description>CPU Core 3</spirit:description>
      <spirit:addressSpaceRef spirit:addressSpaceRef="Main_Bus"/>
      <spirit:addressSpaceRef spirit:addressSpaceRef="GIC_CPU3"/>
      
    </spirit:cpu>
  </spirit:cpus>
  <!--  Parameters section  -->
  <spirit:parameters>
    <spirit:parameter>
      <spirit:name>L2_CACHE</spirit:name>
      <spirit:displayName>L2_CACHE REQUIRED</spirit:displayName>
      <spirit:description>L2_CACHE</spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="L2_CACHE" spirit:order="6" spirit:format="long" spirit:choiceRef="yes_no" spirit:configGroups="RTLconfiguration" spirit:prompt="L2_CACHE">1</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>ACP</spirit:name>
      <spirit:displayName>ACP REQUIRED</spirit:displayName>
      <spirit:description>ACP</spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="ACP" spirit:order="7" spirit:format="long" spirit:choiceRef="yes_no" spirit:configGroups="RTLconfiguration" spirit:prompt="ACP">1</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>ACE</spirit:name>
      <spirit:displayName>ACE REQUIRED</spirit:displayName>
      <spirit:description>ACE</spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="ACE" spirit:order="5" spirit:format="long" spirit:choiceRef="yes_no" spirit:configGroups="RTLconfiguration" spirit:prompt="ACE">1</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>L1_ICACHE_SIZE</spirit:name>
      <spirit:displayName>L1 ICACHE SIZE</spirit:displayName>
      <spirit:description>L1 ICACHE SIZE</spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="L1_ICACHE_SIZE" spirit:order="9" spirit:format="bitString" spirit:choiceRef="l1_size" spirit:configGroups="RTLconfiguration" spirit:prompt="L1 ICACHE SIZE">011</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>SCU_CACHE_PROTECTION</spirit:name>
      <spirit:displayName>SCU_CACHE_PROTECTION REQUIRED</spirit:displayName>
      <spirit:description>SCU_CACHE_PROTECTION</spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="SCU_CACHE_PROTECTION" spirit:order="8" spirit:format="long" spirit:choiceRef="yes_no" spirit:configGroups="RTLconfiguration" spirit:prompt="SCU_CACHE_PROTECTION">0</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>L2_OUTPUT_LATENCY</spirit:name>
      <spirit:displayName>L2 OUTPUT LATENCY </spirit:displayName>
      <spirit:description>L2 OUTPUT LATENCY </spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="L2_OUTPUT_LATENCY" spirit:order="13" spirit:format="long" spirit:minimum="0" spirit:maximum="1" spirit:rangeType="int" spirit:configGroups="RTLconfiguration" spirit:prompt="L2 OUTPUT LATENCY ">1</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>L1_DCACHE_SIZE</spirit:name>
      <spirit:displayName>L1 DCACHE SIZE</spirit:displayName>
      <spirit:description>L1 DCACHE SIZE</spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="L1_DCACHE_SIZE" spirit:order="10" spirit:format="bitString" spirit:choiceRef="l1_size" spirit:configGroups="RTLconfiguration" spirit:prompt="L1 DCACHE SIZE">011</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>CPU_CACHE_PROTECTION</spirit:name>
      <spirit:displayName>CPU_CACHE_PROTECTION REQUIRED</spirit:displayName>
      <spirit:description>CPU_CACHE_PROTECTION</spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="CPU_CACHE_PROTECTION" spirit:order="4" spirit:format="long" spirit:choiceRef="yes_no" spirit:configGroups="RTLconfiguration" spirit:prompt="CPU_CACHE_PROTECTION">0</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>LEGACY_V7_DEBUG_MAP</spirit:name>
      <spirit:displayName>LEGACY V7 DEBUG MAP</spirit:displayName>
      <spirit:description>LEGACY V7 DEBUG MAP</spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="LEGACY_V7_DEBUG_MAP" spirit:order="14" spirit:format="long" spirit:choiceRef="yes_no" spirit:configGroups="RTLconfiguration" spirit:prompt="LEGACY V7 DEBUG MAP">0</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>L2_CACHE_SIZE</spirit:name>
      <spirit:displayName>L2 ICACHE SIZE</spirit:displayName>
      <spirit:description>L2 ICACHE SIZE</spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="L2_CACHE_SIZE" spirit:order="11" spirit:format="bitString" spirit:choiceRef="l2_size" spirit:configGroups="RTLconfiguration" spirit:prompt="L2 ICACHE SIZE">0111</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>L2_INPUT_LATENCY</spirit:name>
      <spirit:displayName>L2 INPUT LATENCY </spirit:displayName>
      <spirit:description>L2 INPUT LATENCY </spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="L2_INPUT_LATENCY" spirit:order="12" spirit:format="long" spirit:minimum="0" spirit:maximum="1" spirit:rangeType="int" spirit:configGroups="RTLconfiguration" spirit:prompt="L2 INPUT LATENCY ">1</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>NUM_CPUS</spirit:name>
      <spirit:displayName>Number of CPUS</spirit:displayName>
      <spirit:description>Number of CPUS</spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="NUM_CPUS" spirit:order="1" spirit:format="long" spirit:minimum="1" spirit:maximum="4" spirit:rangeType="int" spirit:configGroups="RTLconfiguration" spirit:prompt="Number of CPUS">4</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>CRYPTO</spirit:name>
      <spirit:displayName>CRYPTO REQUIRED</spirit:displayName>
      <spirit:description>CRYPTO</spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="CRYPTO" spirit:order="3" spirit:format="long" spirit:choiceRef="yes_no" spirit:configGroups="RTLconfiguration" spirit:prompt="CRYPTO">0</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>NEON_FP</spirit:name>
      <spirit:displayName>Neon FP REQUIRED</spirit:displayName>
      <spirit:description>Neon FP </spirit:description>
      <spirit:value spirit:resolve="immediate" spirit:id="NEON_FP" spirit:order="2" spirit:format="long" spirit:choiceRef="yes_no" spirit:configGroups="RTLconfiguration" spirit:prompt="Neon FP ">1</spirit:value>
    </spirit:parameter>
  </spirit:parameters>
</spirit:component>
